<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>LEGOS Ring Memory - Tetrad Analyzer with Temporal Intelligence</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='75' font-size='80'>✦</text></svg>">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }

    :root {
      --transition: cubic-bezier(0.4, 0, 0.2, 1);
      --column-width: min(100vw, 420px);
    }

    body {
      --bg: #03180c;
      --panel: #052010;
      --panel-dark: #03140d;
      --border: #0c3a23;
      --border-light: #1b6e3e;
      --text: #aef3c1;
      --text-muted: #5ea275;
      --accent: #56ff9f;
      --accent-soft: rgba(86, 255, 159, 0.12);
      --accent-glow: rgba(86, 255, 159, 0.32);
      --danger: #ff5c7c;
      --success: #56ff9f;
      --grid-highlight: rgba(86, 255, 159, 0.08);
      --shadow: rgba(0, 0, 0, 0.45);
      --overlay-backdrop: rgba(4, 20, 12, 0.88);
      font-family: 'Courier New', monospace;
      font-size: clamp(11px, 2.4vw, 13px);
      background: var(--bg);
      color: var(--text);
      overflow: hidden;
      min-height: 100vh;
      min-height: 100dvh;
    }

    body.theme-crt {
      --bg: #03180c;
      --panel: #052010;
      --panel-dark: #03140d;
      --border: #0c3a23;
      --border-light: #1b6e3e;
      --text: #aef3c1;
      --text-muted: #5ea275;
      --accent: #56ff9f;
      --accent-soft: rgba(86, 255, 159, 0.12);
      --accent-glow: rgba(86, 255, 159, 0.32);
      --danger: #ff5c7c;
      --success: #56ff9f;
      --grid-highlight: rgba(86, 255, 159, 0.08);
      --overlay-backdrop: rgba(4, 20, 12, 0.88);
      --shadow: rgba(0, 0, 0, 0.45);
    }

    body.theme-parchment {
      --bg: #f6efdd;
      --panel: #efe4c8;
      --panel-dark: #e4d3b0;
      --border: #cdb181;
      --border-light: #b99158;
      --text: #3b3322;
      --text-muted: #7b6d4d;
      --accent: #d17b24;
      --accent-soft: rgba(209, 123, 36, 0.14);
      --accent-glow: rgba(209, 123, 36, 0.32);
      --danger: #c2463b;
      --success: #2e8f4d;
      --grid-highlight: rgba(209, 123, 36, 0.16);
      --overlay-backdrop: rgba(247, 240, 222, 0.92);
      --shadow: rgba(74, 58, 32, 0.28);
    }

    body.theme-thousand {
      --bg: #050507;
      --panel: rgba(28, 12, 18, 0.92);
      --panel-dark: rgba(18, 8, 12, 0.92);
      --border: #2f121a;
      --border-light: #812934;
      --text: #f6f2ef;
      --text-muted: #d3cdc9;
      --accent: #ff3d4e;
      --accent-soft: rgba(255, 61, 78, 0.18);
      --accent-glow: rgba(255, 61, 78, 0.35);
      --danger: #ff6d7a;
      --success: #f8d66a;
      --grid-highlight: rgba(255, 61, 78, 0.14);
      --overlay-backdrop: rgba(12, 6, 12, 0.88);
      --shadow: rgba(0, 0, 0, 0.6);
    }

    .app-shell {
      position: relative;
      width: 100vw;
      height: 100vh;
      height: 100dvh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
    }

    .scroll-container {
      .channel-scroller {
        display: flex;
        overflow-x: auto;
        overflow-y: hidden;
        gap: 0;
        scroll-snap-type: x mandatory;
        scroll-behavior: smooth;
        -webkit-overflow-scrolling: touch;
        position: relative;
      }
      
      .channel-scroller::-webkit-scrollbar {
        height: 6px;
      }
      
      .channel-scroller::-webkit-scrollbar-track {
        background: var(--panel-dark);
      }
      
      .channel-scroller::-webkit-scrollbar-thumb {
        background: var(--accent);
        border-radius: 3px;
      }
      flex: 1;
      display: flex;
      overflow-x: auto;
      overflow-y: hidden;
      scroll-snap-type: x mandatory;
      scroll-behavior: smooth;
      -webkit-overflow-scrolling: touch;
      background: var(--bg);
      gap: 1px;
      border-top: 1px solid var(--border);
    }

    .channel-column {
      position: relative;
      flex: 0 0 var(--column-width);
      max-width: var(--column-width);
      height: calc(100vh - env(safe-area-inset-top) - env(safe-area-inset-bottom));
      height: calc(100dvh - env(safe-area-inset-top) - env(safe-area-inset-bottom));
      background: var(--panel-dark);
      border-right: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      scroll-snap-align: start;
      transition: transform 0.45s var(--transition), opacity 0.45s var(--transition);
      padding: 0 16px;
      box-sizing: border-box;
    }

    .channel-column.collapsed {
      flex: 0 0 52px;
      max-width: 52px;
      min-width: 52px;
      border-right: 1px solid var(--border);
      box-shadow: 2px 0 8px var(--shadow);
      overflow: visible;
      position: relative;
    }

    .channel-head {
      display: flex;
      flex-direction: column;
      gap: 12px;
      align-items: stretch;
      padding: 12px 16px;
      border-bottom: 1px solid var(--border);
      background: var(--panel);
      transition: opacity 0.3s var(--transition);
    }

    .channel-column.collapsed .channel-head,
    .channel-column.collapsed .channel-body {
      opacity: 0;
      pointer-events: none;
    }

    .channel-meta {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
      text-align: center;
    }

    .channel-name {
      display: none !important;
    }

    .channel-lineage {
      font-size: 7.5px;
      color: var(--text-muted);
      letter-spacing: 0.18em;
      text-transform: uppercase;
    }

    .channel-actions {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }

    .channel-head select,
    .channel-head button {
      touch-action: manipulation;
    }

    .channel-number-rail {
      display: flex;
      flex-direction: column;
      gap: 12px;
      align-items: center;
      justify-content: flex-start;
      width: 32px;
      flex-shrink: 0;
      overflow-y: auto;
      overflow-x: hidden;
      padding: 12px 0;
      position: sticky;
      top: 0;
      max-height: 100%;
      z-index: 2;
    }
    
    .channel-number-rail::-webkit-scrollbar {
      width: 4px;
    }
    
    .channel-number-rail::-webkit-scrollbar-thumb {
      background: var(--border);
      border-radius: 2px;
    }

    .channel-number {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      border: 2px solid var(--border);
      background: var(--panel-dark);
      color: var(--text-muted);
      font-size: 9px;
      font-weight: 700;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.2s var(--transition);
      flex-shrink: 0;
    }

    .channel-number.active {
      background: var(--accent);
      color: var(--bg);
      border-color: var(--accent);
      box-shadow: 0 0 12px var(--accent-glow);
    }

    .channel-number.add {
      border-style: dashed;
    }

    select.channel-scenario {
      background: var(--panel-dark);
      border: 1px solid var(--border);
      color: var(--text-muted);
      font-size: 9px;
      letter-spacing: 0.18em;
      padding: 6px 10px;
      border-radius: 3px;
      cursor: pointer;
      position: relative;
      z-index: 100;
    }

    .channel-btn {
      width: 30px;
      height: 30px;
      border-radius: 50%;
      background: var(--panel-dark);
      border: 1px solid var(--border);
      color: var(--text-muted);
      font-size: 12px;
      cursor: pointer;
      transition: all 0.25s var(--transition);
    }

    .channel-btn:active {
      transform: scale(0.9);
      color: var(--text);
      background: var(--panel);
    }

    .channel-head {
      margin-top: 0;
      border-radius: 0;
    }

    .channel-body {
      flex: 1;
      display: flex;
      flex-direction: column;
      min-height: 0;
      margin-bottom: clamp(44px, 10vw, 64px);
      gap: 8px;
    }

    .channel-column.collapsed .channel-body {
      margin-bottom: 0;
    }
    
    .channel-column:not([data-channel-id]) {
      opacity: 0.5;
      filter: grayscale(0.3);
    }
    
    .channel-column.inactive {
      opacity: 0.4;
      filter: saturate(0.5);
      transition: opacity 0.3s var(--transition), filter 0.3s var(--transition);
    }
    
    .channel-column.channel-active {
      box-shadow: 0 0 0 3px var(--accent), 0 0 30px var(--accent-glow);
      position: relative;
      z-index: 10;
      opacity: 1 !important;
    }
    
    .channel-column.channel-active::before {
      content: '';
      position: absolute;
      top: -2px;
      left: -2px;
      right: -2px;
      bottom: -2px;
      border: 3px solid var(--accent);
      border-radius: 8px;
      pointer-events: none;
      animation: pulse-border 1.5s ease-in-out infinite;
      opacity: 0.9;
    }
    
    @keyframes pulse-border {
      0%, 100% { opacity: 0.7; transform: scale(1); }
      50% { opacity: 1; transform: scale(1.005); }
    }
    
    @keyframes sparkle {
      0%, 100% { opacity: 1; text-shadow: 0 0 8px currentColor; }
      50% { opacity: 0.6; text-shadow: 0 0 16px currentColor, 0 0 24px currentColor; }
    }
    
    /* Channel color theming */
    .channel-column .channel-btn:hover {
      background: var(--channel-color, var(--accent)) !important;
      color: var(--bg) !important;
      border-color: var(--channel-color, var(--accent)) !important;
    }
    
    .channel-column .send-btn {
      background: var(--channel-color, var(--accent));
      border-color: var(--channel-color, var(--accent));
    }
    
    .channel-column .grid-cell.occupied {
      border-color: var(--channel-color, var(--accent));
    }
    
    .channel-column .message-dot {
      color: var(--channel-color, var(--accent));
      border-color: var(--channel-color, var(--accent));
    }
    
    .channel-column .channel-head {
      border-bottom-color: var(--channel-color, var(--border));
    }
    
    .channel-column .channel-footer {
      border-top-color: var(--channel-color, var(--border));
    }
    
    .channel-column .channel-scenario:hover,
    .channel-column .channel-scenario:focus {
      border-color: var(--channel-color, var(--accent));
    }

    .overlay-section {
      padding: 12px 0;
      border-bottom: 1px solid var(--border);
    }
    
    .overlay-section.clickable {
      cursor: pointer;
      transition: all 0.2s var(--transition);
      padding: 12px 8px;
      margin: 0 -8px;
      border-radius: 4px;
    }
    
    .overlay-section.clickable:hover {
      background: var(--panel-dark);
      border-color: var(--accent);
    }
    
    .overlay-section.clickable .overlay-value {
      position: relative;
    }
    
    .overlay-section.clickable:hover .overlay-value::after {
      content: '→ Send to chat';
      position: absolute;
      right: 0;
      top: 0;
      font-size: 8px;
      color: var(--accent);
      opacity: 0.7;
      letter-spacing: 0.1em;
    }

    .resize-bar {
      height: 6px;
      background: var(--border);
      cursor: row-resize;
      flex-shrink: 0;
      transition: background 0.2s;
      position: relative;
      touch-action: none;
    }
    
    .resize-bar:hover,
    .resize-bar:active {
      background: var(--accent);
    }
    
    .resize-bar::before {
      content: '';
      position: absolute;
      top: -12px;
      bottom: -12px;
      left: 0;
      right: 0;
    }
    
    .grid-section {
      flex: 0 0 50vh;
      height: 50vh;
      display: flex;
      flex-direction: column;
      min-width: 0;
      position: relative;
    }

    .grid-section.collapsed {
      max-height: 0;
      padding: 0;
      overflow: hidden;
      opacity: 0;
      border: none;
    }

    .grid-area {
      display: flex;
      align-items: stretch;
      gap: 10px;
    }

    .grid-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
    }

    .grid-title {
      font-size: 8px;
      letter-spacing: 0.2em;
      color: var(--text-muted);
    }

    .grid-toggle {
      font-size: 11px;
      cursor: pointer;
      color: var(--text-muted);
    }

    .grid-wrapper {
      border: 1px solid var(--border);
      background: var(--panel);
      padding: 8px;
      border-radius: 4px;
      transition: max-height 0.3s var(--transition), opacity 0.3s var(--transition);
      flex: 1;
      display: flex;
    }

    .grid-wrapper.collapsed {
      max-height: 0;
      opacity: 0;
      padding: 0;
      overflow: hidden;
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(9, 1fr);
      grid-template-rows: repeat(9, 1fr);
      gap: 2px;
      aspect-ratio: 1;
      width: 100%;
      height: 100%;
      max-width: min(100%, calc(50vh - 80px));
      max-height: min(100%, calc(50vh - 80px));
    }

    .grid-cell {
      position: relative;
      background: var(--panel);
      border: 1px solid var(--border);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: clamp(12px, 2.5vw, 18px);
      font-weight: 700;
      color: var(--text-muted);
      cursor: pointer;
      transition: all 0.5s ease-in-out; /* Smooth cultural movement and color changes */
    }

    .grid-cell:hover {
      border-color: var(--accent);
      transform: scale(1.05);
      z-index: 10;
      box-shadow: 0 0 12px var(--accent-soft);
    }

    .grid-cell.resonance-field::after {
      content: '';
      position: absolute;
      inset: -1px;
      background: radial-gradient(circle, var(--accent-soft) 0%, transparent 70%);
      opacity: 0;
      animation: resonancePulse 2s ease-in-out infinite;
      pointer-events: none;
      z-index: 1;
    }

    .grid-cell.loading {
      animation: cellularAutomata 0.8s ease-in-out infinite;
      border-color: var(--accent);
    }
    
    @keyframes cellularAutomata {
      0% {
        background: var(--panel);
        box-shadow: inset 0 0 8px transparent;
      }
      25% {
        background: linear-gradient(135deg, var(--panel) 0%, var(--accent-soft) 50%, var(--panel) 100%);
        box-shadow: inset 0 0 12px var(--accent-soft);
      }
      50% {
        background: var(--accent-soft);
        box-shadow: inset 0 0 16px var(--accent-glow);
      }
      75% {
        background: linear-gradient(225deg, var(--panel) 0%, var(--accent-soft) 50%, var(--panel) 100%);
        box-shadow: inset 0 0 12px var(--accent-soft);
      }
      100% {
        background: var(--panel);
        box-shadow: inset 0 0 8px transparent;
      }
    }

    .grid-cell.occupied {
      color: var(--text);
      border-color: var(--accent);
      background: linear-gradient(135deg, var(--grid-highlight) 0%, var(--panel) 100%);
      box-shadow: 0 0 0 1px var(--accent-soft) inset, 0 2px 4px rgba(0,0,0,0.2);
      font-weight: 900;
      text-shadow: 0 1px 2px rgba(0,0,0,0.3);
    }

    .grid-cell.occupied[data-cell-type="Entity"] {
      animation: entityPulse 3s ease-in-out infinite;
    }

    .grid-cell.occupied[data-cell-type="Goal"] {
      animation: goalBeacon 2.5s ease-in-out infinite;
    }

    @keyframes entityPulse {
      0%, 100% { box-shadow: 0 0 0 1px var(--accent-soft) inset, 0 2px 4px rgba(0,0,0,0.2), 0 0 8px var(--accent-soft); }
      50% { box-shadow: 0 0 0 1px var(--accent-soft) inset, 0 2px 4px rgba(0,0,0,0.2), 0 0 16px var(--accent-glow); }
    }

    @keyframes goalBeacon {
      0%, 100% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.03); opacity: 0.95; }
    }
    
    @keyframes slideInRight {
      from {
        transform: translateX(100%);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }
    
    @keyframes rippleOut {
      0% {
        box-shadow: 0 0 0 0 var(--accent),
                    0 0 0 0 var(--accent-soft),
                    inset 0 0 20px var(--accent-glow);
        transform: scale(1);
      }
      50% {
        box-shadow: 0 0 0 8px transparent,
                    0 0 0 16px transparent,
                    inset 0 0 30px var(--accent-glow);
        transform: scale(1.1);
      }
      100% {
        box-shadow: 0 0 0 0 transparent,
                    0 0 0 0 transparent,
                    inset 0 0 0 transparent;
        transform: scale(1);
      }
    }
    
    .grid-cell.ripple {
      animation: rippleOut 0.8s cubic-bezier(0.4, 0, 0.2, 1) forwards;
    }
    
    .name-flash {
      position: absolute;
      font-size: 11px;
      font-weight: 900;
      letter-spacing: 0.2em;
      color: var(--accent);
      text-shadow: 0 0 15px var(--accent-glow), 0 0 30px var(--accent-glow);
      opacity: 0;
      animation: nameFlashSmooth 4s ease-in-out forwards;
      pointer-events: none;
      z-index: 1000;
      white-space: nowrap;
      padding: 6px 10px;
      background: rgba(0, 0, 0, 0.95);
      border-radius: 4px;
      border: 2px solid currentColor;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.9);
    }
    
    .name-flash.new {
      color: #4ade80;
      text-shadow: 0 0 15px #4ade80, 0 0 30px #4ade80;
      border-color: #4ade80;
    }
    
    .name-flash.moved {
      color: #60a5fa;
      text-shadow: 0 0 15px #60a5fa, 0 0 30px #60a5fa;
      border-color: #60a5fa;
    }
    
    .name-flash.disappeared {
      color: #f87171;
      text-shadow: 0 0 15px #f87171, 0 0 30px #f87171;
      border-color: #f87171;
    }
    
    @keyframes nameFlashSmooth {
      0% {
        opacity: 0;
        transform: scale(0.8) translateY(-10px);
      }
      15% {
        opacity: 1;
        transform: scale(1) translateY(0);
      }
      85% {
        opacity: 1;
        transform: scale(1) translateY(0);
      }
      100% {
        opacity: 0;
        transform: scale(0.9) translateY(5px);
      }
    }
    
    .grid-cell.composing-active::before {
      content: attr(data-compose-letter);
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 14px;
      font-weight: 900;
      color: var(--accent);
      text-shadow: 0 0 12px var(--accent-glow);
      animation: letterDance 0.6s ease-in-out infinite;
      z-index: 0;
      opacity: 0.7;
    }
    
    @keyframes letterDance {
      0%, 100% {
        transform: translate(-50%, -50%) rotate(-5deg) scale(1);
      }
      50% {
        transform: translate(-50%, -50%) rotate(5deg) scale(1.15);
      }
    }

    .grid-label {
      position: absolute;
      bottom: 2px;
      left: 2px;
      right: 2px;
      font-size: 6px;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      padding: 1px 2px;
      border-radius: 2px;
      backdrop-filter: blur(2px);
      text-shadow: none;
      font-weight: 700;
      line-height: 1;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: calc(100% - 4px);
    }
    
    .grid-label.dark-text {
      color: rgba(0, 0, 0, 0.85);
      background: rgba(255, 255, 255, 0.7);
    }
    
    .grid-label.light-text {
      color: rgba(255, 255, 255, 0.95);
      background: rgba(0, 0, 0, 0.6);
    }
    
    .grid-cell:hover .grid-label {
      font-size: 8px;
      padding: 2px 4px;
      opacity: 1;
      z-index: 100;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.8);
    }

    .grid-collapse-btn {
      width: 24px;
      height: 24px;
      border-radius: 4px;
      border: 1px solid var(--border);
      background: var(--panel);
      color: var(--text-muted);
      font-size: 12px;
      cursor: pointer;
      transition: all 0.2s var(--transition);
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .grid-collapse-btn:hover {
      background: var(--accent);
      color: var(--bg);
      border-color: var(--accent);
    }

    .chat-section {
      flex: 1;
      display: flex;
      flex-direction: column;
      background: var(--panel);
      min-height: 0;
      overflow: hidden;
      transition: flex 0.3s var(--transition);
      position: relative;
      padding-top: 12px;
      gap: 12px;
    }

    .channel-body.grid-collapsed .grid-section.collapsed ~ .chat-section {
      flex: 2;
    }

    .message-list {
      flex: 1;
      overflow-y: auto;
      padding: 0;
      display: flex;
      flex-direction: column;
      gap: 8px;
      min-height: 0;
    }

    .message {
      display: flex;
      flex-direction: column;
      gap: 6px;
      background: var(--panel);
      border: 1px solid var(--border);
      padding: 12px 14px;
      border-radius: 4px;
      position: relative;
      transition: transform 0.2s var(--transition);
    }

    .message.active {
      border-color: var(--accent);
      box-shadow: 0 0 12px var(--accent-soft);
    }

    .message.user {
      border-left: 2px solid var(--success);
      cursor: pointer;
    }

    .message.assistant {
      border-left: 2px solid var(--accent);
      cursor: pointer;
    }

    .message.system {
      border-left: 2px solid var(--text-muted);
      background: var(--panel-dark);
      opacity: 0.85;
    }

    .message.collapsed .message-body {
      max-height: 0;
      opacity: 0.2;
      overflow: hidden;
    }
    
    .message.collapsed .tetrad-chips-inline {
      display: flex !important;
      opacity: 1 !important;
      max-height: none !important;
    }

    .message.collapsed .message-preview {
      opacity: 1;
    }

    .message-header {
      display: flex;
      gap: 8px;
      align-items: center;
      font-size: 8px;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      color: var(--text-muted);
    }

    .ring-indicator {
      font-size: 12px;
      filter: drop-shadow(0 0 8px currentColor);
      animation: ringPulse 2s ease-in-out infinite;
      cursor: help;
    }

    @keyframes ringPulse {
      0%, 100% { opacity: 0.6; }
      50% { opacity: 1; }
    }

    .message-color-dot {
      font-size: 10px;
      line-height: 1;
      filter: drop-shadow(0 0 6px currentColor);
      flex-shrink: 0;
      font-weight: bold;
    }

    .message-color-dot.parent-dot {
      opacity: 0.6;
      font-size: 8px;
      margin-right: -4px;
    }

    .message-dot.forked-dot {
      position: relative;
    }

    .message-dot.forked-dot::after {
      content: '';
      position: absolute;
      top: -2px;
      left: -2px;
      right: -2px;
      bottom: -2px;
      border-radius: 50%;
      border: 2px solid currentColor;
      pointer-events: none;
    }

    .message-preview {
      font-size: 9px;
      letter-spacing: 0.12em;
      color: var(--text-muted);
      display: none;
    }

    .message.collapsed .message-preview {
      display: block;
    }

    .message-body {
      color: var(--text);
      line-height: 1.6;
      white-space: pre-wrap;
      transition: opacity 0.2s var(--transition);
    }

    .message-actions {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: var(--panel);
      border: 1px solid var(--accent);
      border-radius: 6px;
      display: none;
      flex-direction: column;
      min-width: 240px;
      max-width: 90vw;
      z-index: 200;
      box-shadow: 0 12px 48px var(--shadow);
    }

    .message-actions.active {
      display: flex;
    }

    .message-actions::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.7);
      z-index: -1;
      backdrop-filter: blur(6px);
    }

    .message-action-close {
      position: absolute;
      top: 8px;
      right: 8px;
      width: 28px;
      height: 28px;
      border-radius: 50%;
      border: 1px solid var(--border);
      background: var(--panel-dark);
      color: var(--text-muted);
      font-size: 14px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s var(--transition);
      z-index: 10;
    }

    .message-action-close:hover {
      background: var(--accent);
      color: var(--bg);
      border-color: var(--accent);
      transform: rotate(90deg);
    }

    .message-action {
      padding: 14px 18px;
      font-size: 10px;
      letter-spacing: 0.2em;
      color: var(--text-muted);
      border-bottom: 1px solid var(--border);
      cursor: pointer;
      transition: all 0.2s var(--transition);
    }

    .message-action.disabled {
      opacity: 0.55;
      cursor: default;
      pointer-events: none;
      font-style: italic;
      color: var(--text-muted);
    }

    .message-action:last-child {
      border-bottom: none;
    }

    .message-action:active {
      background: var(--panel-dark);
      color: var(--text);
    }

    .message.fork-origin {
      border-style: dashed;
      border-color: var(--accent);
    }

    .input-section {
      padding: 12px 0 0 0;
      border-top: 1px solid var(--border);
      background: var(--panel);
      flex-shrink: 0;
      margin-top: 8px;
      position: sticky;
      bottom: 0;
      z-index: 100;
    }
    
    /* Mobile keyboard compensation */
    @supports (height: 100dvh) {
      .channel-column {
        height: 100dvh;
      }
    }

    .input-wrapper {
      display: flex;
      gap: 8px;
      align-items: stretch;
    }

    textarea.message-input {
      flex: 1;
      background: var(--panel-dark);
      border: 1px solid var(--border);
      color: var(--text);
      padding: 8px 10px;
      border-radius: 4px;
      font-size: 10px;
      line-height: 1.4;
      resize: none;
      min-height: 36px;
      max-height: 80px;
      transition: all 0.3s var(--transition);
    }
    
    textarea.message-input:focus {
      outline: none;
      border-color: var(--accent);
      background: var(--panel);
      box-shadow: 0 0 12px var(--accent-glow);
    }
    
    .channel-column.channel-active textarea.message-input {
      border-color: var(--accent);
      box-shadow: 0 0 8px rgba(86, 255, 159, 0.2);
    }

    .footer-btn {
      transition: all 0.2s var(--transition);
    }
    
    .footer-btn:hover {
      background: var(--accent) !important;
      color: var(--bg) !important;
      border-color: var(--accent) !important;
      transform: scale(1.05);
    }
    
    .footer-btn:active {
      transform: scale(0.95);
    }
    
    .tetrad-footer-btn {
      font-size: 16px;
    }

    textarea.message-input:focus {
      outline: none;
      border-color: var(--border-light);
    }

    .send-btn {
      padding: 12px 18px;
      background: var(--panel-dark);
      border: 1px solid var(--border);
      color: var(--text-muted);
      font-size: 9px;
      letter-spacing: 0.2em;
      cursor: pointer;
      transition: all 0.25s var(--transition);
      border-radius: 4px;
    }

    .send-btn:disabled {
      opacity: 0.35;
      cursor: not-allowed;
    }

    .send-btn:active:not(:disabled) {
      transform: scale(0.95);
      color: var(--text);
    }

    .tetrad-chip {
      padding: 12px 16px;
      background: var(--panel);
      border: 3px solid var(--border);
      border-radius: 8px;
      font-size: 9px;
      letter-spacing: 0.2em;
      color: var(--text);
      cursor: pointer;
      transition: all 0.15s var(--transition);
      text-align: center;
      font-weight: bold;
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      text-transform: uppercase;
      white-space: nowrap;
      min-height: 52px;
      box-shadow: 0 2px 0 var(--border), inset 0 1px 0 rgba(255,255,255,0.1);
    }

    .tetrad-chip-text {
      flex: 1;
      text-align: center;
    }

    .tetrad-chip::before {
      content: '▲';
      font-size: 18px;
      color: var(--accent);
      transition: all 0.3s var(--transition);
      position: absolute;
      left: 12px;
    }

    .tetrad-chip.enhance::before { content: '▲'; }
    .tetrad-chip.reverse::before { content: '⇄'; }
    .tetrad-chip.retrieve::before { content: '↺'; }
    .tetrad-chip.obsolesce::before { content: '▼'; }

    .tetrad-chip:hover {
      border-color: var(--accent);
      background: var(--accent);
      color: var(--bg);
      transform: scale(1.02);
    }

    .tetrad-chip:hover::before {
      color: var(--bg);
      transform: scale(1.15);
      filter: drop-shadow(0 0 12px var(--accent-glow));
    }

    .tetrad-chip:active {
      transform: scale(0.95) translateY(2px);
      box-shadow: 0 0 0 var(--border), inset 0 1px 0 rgba(255,255,255,0.1);
    }

    .tetrad-refresh-btn {
      padding: 6px 12px;
      font-size: 8px;
      letter-spacing: 0.18em;
      background: var(--panel);
      color: var(--text-muted);
      border: 1px solid var(--border);
      border-radius: 999px;
      cursor: pointer;
      transition: all 0.2s var(--transition);
    }

    .tetrad-refresh-btn:active:not(:disabled) {
      transform: scale(0.96);
      color: var(--text);
      border-color: var(--accent);
    }

    .tetrad-refresh-btn:disabled {
      opacity: 0.45;
      cursor: not-allowed;
    }

    .corner-btn {
      position: fixed;
      width: 48px;
      height: 48px;
      border-radius: 50%;
      border: 1px solid var(--border);
      background: var(--panel);
      color: var(--text);
      font-size: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 12;
      box-shadow: 0 8px 24px var(--shadow);
      transition: transform 0.2s var(--transition), box-shadow 0.2s var(--transition);
    }

    .corner-btn:active {
      transform: scale(0.92);
      box-shadow: 0 4px 16px var(--accent-soft);
      color: var(--accent);
      border-color: var(--accent);
    }

    .corner-btn.top-left {
      top: calc(16px + env(safe-area-inset-top));
      left: calc(16px + env(safe-area-inset-left));
    }

    .corner-btn.top-right {
      top: calc(16px + env(safe-area-inset-top));
      right: calc(16px + env(safe-area-inset-right));
    }

    .corner-btn.bottom-left {
      bottom: calc(16px + env(safe-area-inset-bottom));
      left: calc(16px + env(safe-area-inset-left));
    }

    .corner-btn.bottom-right {
      bottom: calc(16px + env(safe-area-inset-bottom));
      right: calc(16px + env(safe-area-inset-right));
    }

    .corner-menu {
      position: fixed;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 8px;
      box-shadow: 0 12px 32px var(--shadow);
      display: none;
      flex-direction: column;
      min-width: 160px;
      z-index: 14;
    }

    .corner-menu.visible {
      display: flex;
    }

    .corner-menu button {
      background: transparent;
      border: none;
      color: var(--text-muted);
      padding: 12px 16px;
      font-size: 9px;
      letter-spacing: 0.18em;
      text-align: left;
      cursor: pointer;
      transition: background 0.2s var(--transition), color 0.2s var(--transition);
    }

    .corner-menu button:active {
      background: var(--panel-dark);
      color: var(--text);
    }


    .ring-bar {
      display: none;
    }
    
    .global-footer {
      position: fixed;
      bottom: 8px;
      left: 50%;
      transform: translateX(-50%);
      height: auto;
      background: transparent;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 6px 12px;
      z-index: 100;
      gap: 6px;
    }
    
    .footer-control-btn {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      border: 2px solid var(--border);
      background: var(--panel-dark);
      color: var(--text-muted);
      font-size: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.2s var(--transition);
    }
    
    .footer-control-btn:hover {
      background: var(--accent);
      color: var(--bg);
      border-color: var(--accent);
      transform: scale(1.05);
    }
    
    .footer-control-btn.add {
      border-style: dashed;
      font-size: 24px;
      font-weight: 300;
    }
    
    .global-scenario-select {
      background: var(--panel);
      border: 1px solid var(--border);
      color: var(--text-muted);
      font-size: 10px;
      font-weight: 700;
      letter-spacing: 0.15em;
      padding: 10px 12px;
      border-radius: 5px;
      cursor: pointer;
      transition: all 0.2s var(--transition);
      font-family: 'Courier New', monospace;
      text-transform: uppercase;
      flex: 1;
      max-width: 130px;
    }
    
    .global-scenario-select:hover,
    .global-scenario-select:focus {
      border-color: var(--accent);
      background: var(--panel);
      outline: none;
    }
    
    .global-scenario-select optgroup {
      font-weight: 700;
      font-size: 9px;
      background: var(--panel-dark);
      color: var(--accent);
      padding: 4px;
    }
    
    .global-scenario-select option {
      padding: 6px 8px;
      background: var(--panel);
      color: var(--text);
      font-size: 10px;
    }
    
    .footer-tetrad-btn {
      width: 28px;
      height: 28px;
      border-radius: 4px;
      border: 1px solid var(--border);
      background: var(--panel);
      color: var(--text-muted);
      font-size: 14px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.2s var(--transition);
    }
    
    .footer-tetrad-btn:hover {
      background: var(--accent);
      color: var(--bg);
      transform: scale(1.08);
    }
    
    .scroll-container {
      padding-bottom: 0;
    }

    .ring-bar::-webkit-scrollbar {
      display: none;
    }

    .ring-entry {
      width: 14px;
      height: 14px;
      border-radius: 50%;
      border: 2px solid currentColor;
      background: var(--panel-dark);
      cursor: pointer;
      transition: all 0.3s var(--transition);
      position: relative;
      flex-shrink: 0;
      filter: brightness(1.2) saturate(1.4);
    }

    .ring-entry:hover {
      transform: scale(1.3);
      filter: brightness(1.5) saturate(1.8);
    }

    .ring-entry.active {
      transform: scale(1.25);
      box-shadow: 0 0 12px currentColor;
    }

    .ring-entry.mainline {
      width: 18px;
      height: 18px;
      border-width: 3px;
      box-shadow: 0 0 16px currentColor, inset 0 0 8px currentColor;
      animation: mainlinePulse 3s ease-in-out infinite;
    }

    @keyframes mainlinePulse {
      0%, 100% { opacity: 0.8; }
      50% { opacity: 1; box-shadow: 0 0 24px currentColor, inset 0 0 12px currentColor; }
    }

    .chat-stream {
      display: flex;
      gap: 8px;
      padding: 8px 0 16px 0;
      overflow-y: auto;
      overflow-x: hidden;
      min-height: 0;
    }

    .message-dot-rail {
      display: flex;
      flex-direction: column;
      gap: 12px;
      padding-top: 12px;
      position: sticky;
      top: calc(80px + env(safe-area-inset-top));
      z-index: 2;
      align-items: center;
      width: 32px;
      flex-shrink: 0;
      max-height: calc(100vh - 200px);
      overflow-y: auto;
      overflow-x: hidden;
    }
    
    .message-dot-rail::-webkit-scrollbar {
      width: 4px;
    }
    
    .message-dot-rail::-webkit-scrollbar-thumb {
      background: var(--border);
      border-radius: 2px;
    }

    .message-dot {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      border: 2px solid currentColor;
      background: var(--panel-dark);
      cursor: pointer;
      color: var(--text);
      font-size: 8px;
      flex-shrink: 0;
      font-weight: bold;
      display: flex;
      align-items: center;
      justify-content: center;
      line-height: 1;
      transition: all 0.3s var(--transition);
    }

    .message-dot.assistant {
      box-shadow: 0 0 12px currentColor;
      filter: brightness(1.3) saturate(1.5);
    }

    .message-dot.user {
      width: 20px;
      height: 20px;
      box-shadow: 0 0 10px currentColor;
      filter: brightness(1.4) saturate(1.6);
    }

    .message-dot.system {
      width: 18px;
      height: 18px;
      opacity: 0.75;
      box-shadow: 0 0 6px currentColor;
      filter: brightness(0.8);
    }

    .message-dot.fork-origin {
      border-width: 2px;
      box-shadow: 0 0 10px var(--accent-glow);
    }

    .message-dot.active {
      transform: scale(1.15);
      box-shadow: 0 0 8px var(--accent-glow);
    }

    .send-btn {
      font-size: 18px;
      letter-spacing: 0;
      border-radius: 6px;
      min-width: 44px;
      padding: 0 12px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .grid-cell.occupied:hover {
      transform: scale(1.08);
      box-shadow: 0 0 20px var(--accent-glow);
      z-index: 5;
    }
    
    .grid-cell.occupied::after {
      content: attr(data-full-name);
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.95);
      color: var(--accent);
      padding: 8px 12px;
      border-radius: 4px;
      font-size: 11px;
      font-weight: 700;
      white-space: nowrap;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s;
      z-index: 100;
      border: 1px solid var(--accent);
      box-shadow: 0 4px 12px rgba(0,0,0,0.8);
    }
    
    .grid-cell.occupied:hover::after {
      opacity: 1;
    }

    .tetrad-chip:hover {
      border-color: var(--accent);
      color: var(--text);
    }

    .snapshot-overlay-list {
      max-height: 240px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin: 16px 0;
    }

    .ring-context-block {
      border: 1px solid var(--border);
      border-radius: 4px;
      background: var(--panel-dark);
      padding: 12px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      max-height: 260px;
    }

    .ring-context-controls {
      display: flex;
      gap: 6px;
      justify-content: space-between;
      flex-wrap: wrap;
    }

    .ring-context-btn {
      flex: 1 1 auto;
      text-align: center;
      font-size: 8px;
      letter-spacing: 0.16em;
      padding: 6px 8px;
      border: 1px solid var(--border);
      background: transparent;
      color: var(--text-muted);
      cursor: pointer;
      border-radius: 3px;
      transition: all 0.2s var(--transition);
    }

    .ring-context-btn.active {
      border-color: var(--accent);
      color: var(--accent);
      box-shadow: 0 0 10px var(--accent-soft);
    }

    .ring-context-window {
      font-size: 8px;
      letter-spacing: 0.18em;
      color: var(--text-muted);
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 3px;
      padding: 10px;
      overflow-y: auto;
      white-space: pre-wrap;
      max-height: 180px;
    }

    .snapshot-overlay-item {
      padding: 10px 12px;
      border: 1px solid var(--border);
      background: var(--panel-dark);
      border-radius: 4px;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .snapshot-overlay-meta {
      display: flex;
      justify-content: space-between;
      font-size: 8px;
      letter-spacing: 0.18em;
      color: var(--text-muted);
    }

    .snapshot-overlay-actions {
      display: flex;
      gap: 8px;
    }

    .snapshot-overlay-actions button {
      flex: 1;
    }

    .overlay {
      position: fixed;
      inset: 0;
      background: var(--overlay-backdrop);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 20;
      padding: 24px;
      backdrop-filter: blur(6px);
    }

    .overlay.active {
      display: flex;
    }

    .overlay-card {
      background: var(--panel);
      border: 1px solid var(--border);
      padding: 24px;
      border-radius: 6px;
      width: min(420px, 92vw);
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .overlay-title {
      font-size: 9px;
      letter-spacing: 0.24em;
      color: var(--text);
    }

    .overlay-sub {
      font-size: 8px;
      letter-spacing: 0.16em;
      color: var(--text-muted);
    }

    .overlay-input {
      width: 100%;
      border: 1px solid var(--border);
      background: var(--panel-dark);
      color: var(--text);
      padding: 12px 14px;
      font-size: 10px;
      border-radius: 4px;
    }

    .overlay-actions {
      display: flex;
      justify-content: flex-end;
      gap: 10px;
    }

    .primary-btn {
      padding: 10px 16px;
      border: 1px solid var(--accent);
      background: transparent;
      color: var(--accent);
      letter-spacing: 0.18em;
      cursor: pointer;
      font-size: 9px;
      border-radius: 4px;
    }

    .primary-btn:active:not(:disabled) {
      transform: scale(0.96);
      background: var(--accent-soft);
    }

    .primary-btn:disabled {
      opacity: 0.45;
      cursor: not-allowed;
    }
    
    .tetrad-intervention-btn.glow-active {
      background: var(--accent);
      color: var(--bg);
      box-shadow: 0 0 20px var(--accent-glow), 0 0 40px var(--accent-glow);
      animation: pulse-glow 2s ease-in-out infinite;
    }
    
    .tetrad-intervention-btn.glow-processing {
      background: #60a5fa;
      color: var(--bg);
      box-shadow: 0 0 20px #60a5fa, 0 0 40px #60a5fa;
      animation: pulse-glow 1s ease-in-out infinite;
    }
    
    .tetrad-intervention-btn.glow-success {
      background: #4ade80;
      color: var(--bg);
      box-shadow: 0 0 20px #4ade80;
    }
    
    @keyframes pulse-glow {
      0%, 100% {
        box-shadow: 0 0 15px currentColor, 0 0 30px currentColor;
      }
      50% {
        box-shadow: 0 0 25px currentColor, 0 0 50px currentColor;
      }
    }

    .secondary-btn {
      padding: 10px 16px;
      border: 1px solid var(--border);
      background: transparent;
      color: var(--text-muted);
      letter-spacing: 0.18em;
      cursor: pointer;
      font-size: 9px;
      border-radius: 4px;
    }

    .grid-area {
      flex: 1;
      overflow: hidden;
      padding: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .cell-overlay-content,
    .perspective-overlay-content {
      max-width: 380px;
      width: min(380px, 92vw);
      max-height: 85vh;
      overflow-y: auto;
      border: 1px solid var(--border);
      background: var(--panel);
      border-radius: 6px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.8);
    }

    .overlay-section {
      display: flex;
      flex-direction: column;
      gap: 6px;
      border: 1px solid var(--border);
      padding: 12px;
      border-radius: 4px;
      background: var(--panel-dark);
    }

    .overlay-label {
      font-size: 8px;
      letter-spacing: 0.16em;
      color: var(--text-muted);
    }

    .overlay-value {
      font-size: 10px;
      line-height: 1.6;
      color: var(--text);
    }

    .overlay-action-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .overlay-action-row button {
      flex: 1 1 auto;
    }

    .close-overlay {
      align-self: flex-end;
      border: none;
      background: transparent;
      color: var(--text-muted);
      font-size: 20px;
      cursor: pointer;
    }

    @media (hover: hover) {
      .message.assistant:hover {
        transform: translateX(4px);
      }

      .grid-cell:hover {
        border-color: var(--border-light);
        transform: scale(1.03);
      }

      .tetrad-chip:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 18px var(--accent-soft);
      }
    }

    ::-webkit-scrollbar {
      width: 4px;
      height: 4px;
    }
    ::-webkit-scrollbar-track {
      background: var(--panel-dark);
    }
    ::-webkit-scrollbar-thumb {
      background: var(--border);
      border-radius: 4px;
    }

    
    .channel-column.composing::after {
      content: 'COMPOSING';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 14px;
      letter-spacing: 0.32em;
      color: var(--accent);
      animation: pulse 1.2s ease-in-out infinite;
      pointer-events: none;
      z-index: 50;
      text-shadow: 0 0 12px var(--accent-glow);
    }

    .message.reveal {
      animation: reveal 0.6s var(--transition) forwards;
    }

    @keyframes pulse {
      0%, 100% { opacity: 0.4; transform: translate(-50%, -50%) scale(0.98); }
      50% { opacity: 1; transform: translate(-50%, -50%) scale(1.02); }
    }

    @keyframes reveal {
      0% { opacity: 0; transform: translateY(12px); }
      100% { opacity: 1; transform: translateY(0); }
    }
  </style>
</head>
<body>
  <div class="app-shell">
    <div class="ring-bar" id="ringBar"></div>
    <div class="scroll-container" id="channelScroller"></div>
    <div class="global-footer" id="globalFooter">
      <select class="global-scenario-select" id="globalScenarioSelect"></select>
      <button class="footer-tetrad-btn" id="globalTetradBtn" title="Set Entity Perspective">✦</button>
    </div>
  </div>

  <div class="overlay" id="keyOverlay">
    <div class="overlay-card">
      <div class="overlay-title">STORE OPENAI KEY</div>
      <div class="overlay-sub">Key persists locally as legos/multi-channel key.</div>
      <input type="password" class="overlay-input" id="keyInput" placeholder="sk-...">
      <div class="overlay-sub" id="keyStatus">Key not stored.</div>
      <div class="overlay-actions">
        <button class="secondary-btn" data-close="keyOverlay">CANCEL</button>
        <button class="primary-btn" id="keySaveBtn">SAVE</button>
      </div>
    </div>
  </div>

  <div class="overlay" id="exportOverlay">
    <div class="overlay-card">
      <div class="overlay-title">EXPORT STATE</div>
      <div class="overlay-sub">Download full multi-channel session as JSON.</div>
      <div class="overlay-actions">
        <button class="secondary-btn" data-close="exportOverlay">CLOSE</button>
        <button class="primary-btn" id="confirmExport">EXPORT JSON</button>
      </div>
    </div>
  </div>

  <div class="overlay" id="cellOverlay">
    <div class="cell-overlay-content" id="cellOverlayContent">
      <button class="close-overlay" data-close="cellOverlay">×</button>
    </div>
  </div>

  <div class="overlay" id="snapshotOverlay">
    <div class="overlay-card">
      <div class="overlay-title">SNAPSHOTS</div>
      <div class="overlay-sub" id="snapshotStatus"></div>
      <div class="snapshot-overlay-list" id="snapshotOverlayList"></div>
      <div class="overlay-actions">
        <button class="secondary-btn" data-close="snapshotOverlay">CLOSE</button>
        <button class="primary-btn" id="snapshotCreateBtn">CREATE</button>
      </div>
    </div>
  </div>

  <div class="overlay" id="ringOverlay">
    <div class="overlay-card">
      <div class="overlay-title">RING MEMORY</div>
      <div class="overlay-sub" id="ringStatus"></div>
      <div class="ring-context-block">
        <div class="ring-context-controls">
          <button class="ring-context-btn" id="ringModeAll" data-mode="all">ALL STREAM</button>
          <button class="ring-context-btn" id="ringModeAnchor" data-mode="anchor">ANCHOR CHANNEL</button>
          <button class="ring-context-btn" id="ringModeMain" data-mode="mainline">MAINLINE</button>
        </div>
        <div class="ring-context-window" id="ringContextWindow"></div>
      </div>
      <div class="snapshot-overlay-list" id="ringEntries"></div>
      <div class="overlay-actions">
        <button class="secondary-btn" id="ringSetMainline">LOCK MAINLINE</button>
        <button class="secondary-btn" data-close="ringOverlay">CLOSE</button>
      </div>
    </div>
  </div>

  <div class="overlay" id="perspectiveOverlay">
    <div class="perspective-overlay-content" id="perspectiveOverlayContent">
      <button class="close-overlay" data-close="perspectiveOverlay">×</button>
    </div>
  </div>

  <input type="file" id="importInput" accept="application/json" hidden>

  <button class="corner-btn top-left" id="cornerKey" title="API Key">◎</button>
  <button class="corner-btn top-right" id="cornerHelp" title="Help">?</button>
  <button class="corner-btn bottom-left" id="cornerExchange" title="Import / Export">⇆</button>
  <button class="corner-btn bottom-right" id="cornerAdd" title="Add Channel">＋</button>

  <div class="corner-menu" id="infoMenu" style="top: calc(72px + env(safe-area-inset-top)); right: calc(16px + env(safe-area-inset-right));">
    <button data-action="help">HELP OVERVIEW</button>
    <button data-action="theme">TOGGLE THEME</button>
    <button data-action="fullscreen">FULLSCREEN MODE</button>
    <button data-action="reset" style="color: var(--danger); border-top: 1px solid var(--border); margin-top: 4px; padding-top: 8px;">RESET ALL CHATS</button>
  </div>

  <div class="corner-menu" id="exchangeMenu" style="bottom: calc(72px + env(safe-area-inset-bottom)); left: calc(16px + env(safe-area-inset-left));">
    <button data-action="export">EXPORT SESSION</button>
    <button data-action="import">IMPORT SESSION</button>
  </div>

  <script>
    // ═══════════════════════════════════════════════════════════════════
    // RING BUFFER & TEMPORAL INDEX - Memory Management System
    // ═══════════════════════════════════════════════════════════════════
    
    // Memory profiles for different devices
    const MEMORY_PROFILES = {
      desktop: { ringCapacity: 96, telemetryDepth: 1000, gridHistory: 50 },
      tablet: { ringCapacity: 48, telemetryDepth: 500, gridHistory: 25 },
      mobile: { ringCapacity: 24, telemetryDepth: 200, gridHistory: 10 },
      lowMemory: { ringCapacity: 12, telemetryDepth: 50, gridHistory: 5 }
    };
    
    // Ring Buffer - Circular memory with graceful degradation
    class RingBuffer {
      constructor(options = {}) {
        this.memoryProfile = this.detectMemoryProfile();
        const profile = MEMORY_PROFILES[this.memoryProfile];
        this.capacity = options.capacity || profile.ringCapacity;
        this._entriesArray = new Array(this.capacity);  // Private internal array
        this.pointer = 0;
        this.size = 0;
        this.index = { byId: new Map(), byChannel: new Map(), byType: new Map(), byTime: [] };
        this.telemetry = { totalWrites: 0, overwriteCount: 0, compactionCount: 0, memoryChecks: 0, lastMemoryUsage: 0 };
        console.log(`[RingBuffer] Init: ${this.memoryProfile}, capacity: ${this.capacity}`);
      }
      
      detectMemoryProfile() {
        const deviceMemory = navigator.deviceMemory || 4;
        let heapUsed = 0;
        if (performance.memory) heapUsed = performance.memory.usedJSHeapSize;
        if (deviceMemory >= 8 && heapUsed < 100_000_000) return 'desktop';
        else if (deviceMemory >= 4 && heapUsed < 50_000_000) return 'tablet';
        else if (deviceMemory >= 2 && heapUsed < 30_000_000) return 'mobile';
        else return 'lowMemory';
      }
      
      write(entry) {
        if (!entry || !entry.id || !entry.timestamp) return false;
        if (this.index.byId.has(entry.id)) return false;
        const oldEntry = this._entriesArray[this.pointer];
        if (oldEntry) { this.removeFromIndex(oldEntry); this.telemetry.overwriteCount++; }
        this._entriesArray[this.pointer] = entry;
        this.addToIndex(entry);
        this.pointer = (this.pointer + 1) % this.capacity;
        this.size = Math.min(this.size + 1, this.capacity);
        this.telemetry.totalWrites++;
        if (this.telemetry.totalWrites % 100 === 0) this.checkMemoryPressure();
        return true;
      }
      
      addToIndex(entry) {
        this.index.byId.set(entry.id, entry);
        if (!this.index.byChannel.has(entry.channelId)) this.index.byChannel.set(entry.channelId, []);
        this.index.byChannel.get(entry.channelId).push(entry);
        if (!this.index.byType.has(entry.type)) this.index.byType.set(entry.type, []);
        this.index.byType.get(entry.type).push(entry);
        this.index.byTime.push({ timestamp: new Date(entry.timestamp), id: entry.id });
        this.index.byTime.sort((a, b) => a.timestamp - b.timestamp);
      }
      
      removeFromIndex(entry) {
        this.index.byId.delete(entry.id);
        const chEntries = this.index.byChannel.get(entry.channelId);
        if (chEntries) { const idx = chEntries.findIndex(e => e.id === entry.id); if (idx >= 0) chEntries.splice(idx, 1); }
        const typeEntries = this.index.byType.get(entry.type);
        if (typeEntries) { const idx = typeEntries.findIndex(e => e.id === entry.id); if (idx >= 0) typeEntries.splice(idx, 1); }
        const timeIdx = this.index.byTime.findIndex(t => t.id === entry.id);
        if (timeIdx >= 0) this.index.byTime.splice(timeIdx, 1);
      }
      
      checkMemoryPressure() {
        this.telemetry.memoryChecks++;
        if (!performance.memory) return;
        const heapUsed = performance.memory.usedJSHeapSize;
        const heapLimit = performance.memory.jsHeapSizeLimit;
        const usage = heapUsed / heapLimit;
        this.telemetry.lastMemoryUsage = usage;
        if (usage > 0.8) { console.warn(`[RingBuffer] Memory pressure: ${(usage*100).toFixed(1)}%`); this.compactOldEntries(); }
        if (usage > 0.9) this.reduceCapacity();
      }
      
      compactOldEntries() {
        const keepFields = ['id', 'type', 'timestamp', 'channelId', 'headline', 'symbol'];
        const recentThreshold = Math.floor(this.capacity * 0.25);
        this._entriesArray.forEach((entry, i) => {
          if (!entry) return;
          const distance = (this.pointer - i + this.capacity) % this.capacity;
          if (distance > recentThreshold) Object.keys(entry).forEach(key => { if (!keepFields.includes(key)) delete entry[key]; });
        });
        this.telemetry.compactionCount++;
      }
      
      reduceCapacity() {
        const newCapacity = Math.max(12, Math.floor(this.capacity * 0.75));
        const toKeep = this.getAll().slice(-newCapacity);
        this._entriesArray = new Array(newCapacity);
        this.pointer = 0;
        this.size = 0;
        this.capacity = newCapacity;
        this.index.byId.clear();
        this.index.byChannel.clear();
        this.index.byType.clear();
        this.index.byTime = [];
        toKeep.forEach(entry => this.write(entry));
        console.log(`[RingBuffer] Capacity reduced to ${newCapacity}`);
      }
      
      get(id) { return this.index.byId.get(id); }
      getAll() { 
        // Access internal array directly to avoid infinite recursion with compatibility getter
        const result = [];
        for (let i = 0; i < this.capacity; i++) {
          if (this._entriesArray[i] !== undefined && this._entriesArray[i] !== null) {
            result.push(this._entriesArray[i]);
          }
        }
        return result;
      }
      getByChannel(channelId) { return this.index.byChannel.get(channelId) || []; }
      getByType(type) { return this.index.byType.get(type) || []; }
      getRecent(count = 10) { return this.getAll().slice(-count); }
      
      toJSON() {
        return { capacity: this.capacity, size: this.size, pointer: this.pointer, memoryProfile: this.memoryProfile, entries: this.getAll(), telemetry: this.telemetry };
      }
      
      fromJSON(data) {
        this.capacity = data.capacity;
        this.size = data.size || 0;
        this.pointer = data.pointer || 0;
        this._entriesArray = new Array(this.capacity);
        this.index.byId.clear();
        this.index.byChannel.clear();
        this.index.byType.clear();
        this.index.byTime = [];
        if (data.entries && Array.isArray(data.entries)) {
          data.entries.forEach((entry, i) => { if (entry) { this._entriesArray[i] = entry; this.addToIndex(entry); } });
        }
      }
      
      getStats() {
        return { capacity: this.capacity, size: this.size, utilizationPercent: (this.size / this.capacity * 100).toFixed(1), memoryProfile: this.memoryProfile, channelCount: this.index.byChannel.size, typeCount: this.index.byType.size, ...this.telemetry };
      }
    }
    
    // Temporal Index - "Chat Across Time" queries
    class TemporalIndex {
      constructor(ringBuffer) {
        this.ringBuffer = ringBuffer;
        this.indices = { timeline: [], byChannel: new Map(), byEntity: new Map(), byPosition: new Map(), searchIndex: new Map() };
      }
      
      rebuildAll() {
        this.indices.timeline = [];
        this.indices.byChannel.clear();
        this.indices.byEntity.clear();
        this.indices.byPosition.clear();
        this.indices.searchIndex.clear();
        const entries = this.ringBuffer.getAll();
        entries.forEach(entry => this.indexEntry(entry));
        this.indices.timeline.sort((a, b) => a.timestamp - b.timestamp);
      }
      
      indexEntry(entry) {
        const timestamp = new Date(entry.timestamp);
        this.indices.timeline.push({ timestamp, entryId: entry.id, type: entry.type, channelId: entry.channelId, headline: entry.headline });
        if (!this.indices.byChannel.has(entry.channelId)) {
          this.indices.byChannel.set(entry.channelId, { entries: [], firstSeen: timestamp, lastSeen: timestamp, count: 0 });
        }
        const chData = this.indices.byChannel.get(entry.channelId);
        chData.entries.push(entry.id);
        chData.lastSeen = timestamp;
        chData.count++;
        if (entry.type && entry.type.toLowerCase().includes('persp')) {
          const entityId = this.extractEntityId(entry);
          if (entityId) {
            if (!this.indices.byEntity.has(entityId)) this.indices.byEntity.set(entityId, { perspectives: [], appearances: [], narrative: [] });
            this.indices.byEntity.get(entityId).perspectives.push(entry.id);
          }
        }
        if (entry.symbol) {
          const position = this.parsePosition(entry.symbol);
          if (position) {
            const key = `${position.x},${position.y}`;
            if (!this.indices.byPosition.has(key)) this.indices.byPosition.set(key, { events: [], history: [] });
            this.indices.byPosition.get(key).events.push({ entryId: entry.id, timestamp, type: entry.type });
            if (entry.headline) this.indices.byPosition.get(key).history.push(entry.headline);
          }
        }
        if (entry.headline || entry.summary) {
          const text = `${entry.headline || ''} ${entry.summary || ''}`.toLowerCase();
          text.split(/\W+/).filter(w => w.length > 3).forEach(word => {
            if (!this.indices.searchIndex.has(word)) this.indices.searchIndex.set(word, []);
            if (!this.indices.searchIndex.get(word).includes(entry.id)) this.indices.searchIndex.get(word).push(entry.id);
          });
        }
      }
      
      extractEntityId(entry) {
        if (entry.headline) {
          const match = entry.headline.match(/Perspective:\s*(.+?)(?:\s+\d+)?$/i);
          if (match) return match[1].trim().toLowerCase().replace(/\s+/g, '_');
        }
        return null;
      }
      
      parsePosition(symbol) {
        if (!symbol) return null;
        const parts = symbol.trim().split(/\s+/);
        if (parts.length >= 2) {
          const x = parseInt(parts[parts.length - 2]);
          const y = parseInt(parts[parts.length - 1]);
          if (!isNaN(x) && !isNaN(y)) return { x, y };
        }
        return null;
      }
      
      search(query) {
        if (!query || query.length < 3) return [];
        const searchTerms = query.toLowerCase().split(/\W+/).filter(w => w.length > 3);
        if (searchTerms.length === 0) return [];
        const matchingIds = new Set();
        searchTerms.forEach(term => {
          if (this.indices.searchIndex.has(term)) this.indices.searchIndex.get(term).forEach(id => matchingIds.add(id));
          this.indices.searchIndex.forEach((ids, word) => { if (word.startsWith(term)) ids.forEach(id => matchingIds.add(id)); });
        });
        return Array.from(matchingIds).map(id => this.ringBuffer.get(id)).filter(e => e).sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
      }
      
      getByChannel(channelId) {
        const data = this.indices.byChannel.get(channelId);
        if (!data) return null;
        return { ...data, entries: data.entries.map(id => this.ringBuffer.get(id)).filter(e => e) };
      }
      
      getStats() {
        return { totalEntries: this.indices.timeline.length, channelCount: this.indices.byChannel.size, entityCount: this.indices.byEntity.size, locationsTracked: this.indices.byPosition.size, uniqueWords: this.indices.searchIndex.size };
      }
    }
    
    // Global instances
    let sessionRingBuffer = null;
    let sessionIndex = null;
    
    // ═══════════════════════════════════════════════════════════════════
    // LEGOS CORE SYSTEM
    // ═══════════════════════════════════════════════════════════════════
    
    const blockPalette = [
      { type: 'Location', symbol: 'L' },
      { type: 'Entity', symbol: 'E' },
      { type: 'Goal', symbol: 'G' },
      { type: 'Obstacle', symbol: 'O' },
      { type: 'Shift', symbol: 'S' },
      { type: 'Solution', symbol: 'U' }
    ];

    // ═══════════════════════════════════════════════════════════════════
    // CULTURAL ENGINE CORE - Tripartite Probabilistic Dynamics
    // ═══════════════════════════════════════════════════════════════════
    
    // BDI (Belief-Desire-Intention) Framework - Bratman (1987), Rao & Georgeff (1995)
    class BDIAgent {
      constructor(position, culturalType, legosCellRef) {
        this.position = position;
        this.culturalType = culturalType;
        this.legosCellRef = legosCellRef;
        
        // Beliefs: Agent's informational state about world
        this.beliefs = {
          nearbyThreats: [],
          nearbyAllies: [],
          environmentalState: {},
          perceivedLegitimacy: 0.5,
          symbolicMeaning: legosCellRef?.entity?.symbolicRole || 'neutral'
        };
        
        // Desires: Agent's motivational state (goals)
        this.desires = new Set();
        this.updateDesires();
        
        // Intentions: Committed plans and actions
        this.intentions = [];
        this.currentIntention = null;
      }
      
      updateBeliefs(worldState) {
        // Update beliefs based on perception
        this.beliefs.nearbyThreats = this.perceiveThreats(worldState);
        this.beliefs.nearbyAllies = this.perceiveAllies(worldState);
        this.beliefs.perceivedLegitimacy = worldState.legitimacy || 0.5;
        
        // LEGOS narrative influences belief formation
        if (this.legosCellRef?.entity?.perspective) {
          const perspective = this.legosCellRef.entity.perspective.toLowerCase();
          if (perspective.match(/oppress|harsh|suffer/)) {
            this.beliefs.perceivedLegitimacy *= 0.7; // Oppression lowers legitimacy perception
          }
        }
      }
      
      updateDesires() {
        this.desires.clear();
        
        // Type-specific desire generation
        if (this.culturalType === 'citizen') {
          this.desires.add('survive');
          this.desires.add('avoid_harm');
          if (this.beliefs.perceivedLegitimacy < 0.3) {
            this.desires.add('seek_change');
          }
        } else if (this.culturalType === 'rebel') {
          this.desires.add('challenge_authority');
          this.desires.add('find_allies');
          this.desires.add('survive');
        } else if (this.culturalType === 'cop') {
          this.desires.add('maintain_order');
          this.desires.add('suppress_dissent');
        }
        
        // LEGOS symbolic role influences desires
        const role = this.beliefs.symbolicMeaning;
        if (role === 'chaos_agent') {
          this.desires.add('disrupt_order');
        } else if (role === 'mediator') {
          this.desires.add('reduce_conflict');
        } else if (role === 'oppressed') {
          this.desires.add('seek_justice');
        }
      }
      
      perceiveThreats(worldState) {
        const threats = [];
        const [x, y] = this.position;
        
        for (let dy = -1; dy <= 1; dy++) {
          for (let dx = -1; dx <= 1; dx++) {
            const nx = x + dx, ny = y + dy;
            if (nx >= 0 && nx < 9 && ny >= 0 && ny < 9) {
              const key = `${nx}_${ny}`;
              const agent = worldState.agents[key];
              if (agent && this.isThreat(agent)) {
                threats.push({ agent, distance: Math.abs(dx) + Math.abs(dy) });
              }
            }
          }
        }
        return threats;
      }
      
      perceiveAllies(worldState) {
        const allies = [];
        const [x, y] = this.position;
        
        for (let dy = -2; dy <= 2; dy++) {
          for (let dx = -2; dx <= 2; dx++) {
            const nx = x + dx, ny = y + dy;
            if (nx >= 0 && nx < 9 && ny >= 0 && ny < 9) {
              const key = `${nx}_${ny}`;
              const agent = worldState.agents[key];
              if (agent && this.isAlly(agent)) {
                allies.push({ agent, distance: Math.abs(dx) + Math.abs(dy) });
              }
            }
          }
        }
        return allies;
      }
      
      isThreat(otherAgent) {
        if (this.culturalType === 'citizen' && otherAgent.culturalType === 'cop') return true;
        if (this.culturalType === 'rebel' && otherAgent.culturalType === 'cop') return true;
        if (this.culturalType === 'cop' && otherAgent.culturalType === 'rebel') return true;
        return false;
      }
      
      isAlly(otherAgent) {
        return this.culturalType === otherAgent.culturalType;
      }
      
      formIntentions() {
        // Practical reasoning: desires → intentions
        this.intentions = [];
        
        if (this.desires.has('avoid_harm') && this.beliefs.nearbyThreats.length > 0) {
          this.intentions.push({ type: 'flee', priority: 10 });
        }
        
        if (this.desires.has('find_allies') && this.beliefs.nearbyAllies.length > 0) {
          this.intentions.push({ type: 'approach_ally', priority: 7 });
        }
        
        if (this.desires.has('challenge_authority') && this.beliefs.nearbyThreats.length > 0) {
          this.intentions.push({ type: 'confront', priority: 5 });
        }
        
        if (this.desires.has('maintain_order') && this.beliefs.nearbyThreats.length > 0) {
          this.intentions.push({ type: 'suppress', priority: 8 });
        }
        
        if (this.desires.has('disrupt_order')) {
          this.intentions.push({ type: 'move_randomly', priority: 6 });
        }
        
        if (this.desires.has('reduce_conflict')) {
          this.intentions.push({ type: 'mediate', priority: 4 });
        }
        
        // Sort by priority
        this.intentions.sort((a, b) => b.priority - a.priority);
        this.currentIntention = this.intentions[0] || null;
      }
      
      execute(worldState) {
        if (!this.currentIntention) return null;
        
        // Execute highest priority intention
        switch (this.currentIntention.type) {
          case 'flee':
            return this.executeFlee(worldState);
          case 'approach_ally':
            return this.executeApproachAlly(worldState);
          case 'suppress':
            return this.executeSuppress(worldState);
          case 'move_randomly':
            return this.executeMoveRandom(worldState);
          default:
            return null;
        }
      }
      
      executeFlee(worldState) {
        // Move away from threats
        const threat = this.beliefs.nearbyThreats[0];
        if (!threat) return null;
        
        const [x, y] = this.position;
        const [tx, ty] = threat.agent.position;
        const dx = x - tx, dy = y - ty;
        
        return {
          action: 'move',
          direction: { x: Math.sign(dx) || (Math.random() < 0.5 ? 1 : -1), 
                      y: Math.sign(dy) || (Math.random() < 0.5 ? 1 : -1) }
        };
      }
      
      executeApproachAlly(worldState) {
        const ally = this.beliefs.nearbyAllies[0];
        if (!ally) return null;
        
        const [x, y] = this.position;
        const [ax, ay] = ally.agent.position;
        const dx = ax - x, dy = ay - y;
        
        return {
          action: 'move',
          direction: { x: Math.sign(dx), y: Math.sign(dy) }
        };
      }
      
      executeSuppress(worldState) {
        return { action: 'suppress', target: this.beliefs.nearbyThreats[0] };
      }
      
      executeMoveRandom(worldState) {
        return {
          action: 'move',
          direction: { 
            x: Math.floor(Math.random() * 3) - 1, 
            y: Math.floor(Math.random() * 3) - 1 
          }
        };
      }
    }
    
    // Seed simulation parameters from prompt text (deterministic)
    function seedCulturalParams(promptText) {
      const hash = Array.from(promptText).reduce((acc, char) => {
        return ((acc << 5) - acc + char.charCodeAt(0)) | 0;
      }, 0);
      const rng = (seed) => {
        let x = Math.sin(seed++) * 10000;
        return x - Math.floor(x);
      };
      
      return {
        framework: 'epstein',  // Default to Epstein Civil Violence
        useBDI: false,         // BDI agent reasoning
        comparisonMode: false, // Barad's diffractive analysis
        comparisonSnapshot: null, // Stored state for comparison
        pragmatic: {
          legitimacy: 0.4 + rng(hash + 1) * 0.3,        // 0.4-0.7
          copEffectiveness: 0.3 + rng(hash + 2) * 0.3,  // 0.3-0.6
          fearDecay: 0.15 + rng(hash + 3) * 0.25,       // 0.15-0.4
          citizenRatio: 0.65 + rng(hash + 10) * 0.15,   // 0.65-0.8
          copRatio: 0.05 + rng(hash + 11) * 0.05        // 0.05-0.1
        },
        structural: {
          symbolicInertia: 0.5 + rng(hash + 4) * 0.4,
          mythicCoherence: 0.6 + rng(hash + 5) * 0.3,
          boundaryStrength: 0.4 + rng(hash + 6) * 0.4
        },
        reflexive: {
          observationWeight: 0.3 + rng(hash + 7) * 0.4,
          interpretationDepth: 2 + Math.floor(rng(hash + 8) * 3),
          mutualAdjustment: 0.2 + rng(hash + 9) * 0.5
        },
        seed: hash
      };
    }
    
    // Generate scene ontology from existing scene graph
    function generateSceneOntology(channel) {
      const ontology = {
        entities: [],
        locations: [],
        conflicts: [],
        resources: [],
        authorities: [],
        relationships: [],
        narrative: {
          tension: 0,
          progress: 0,
          caution: 0
        }
      };
      
      // Analyze existing scene if available
      if (channel.lastScene) {
        const scene = channel.lastScene;
        
        // Extract entities
        if (scene.entities) {
          scene.entities.forEach(entity => {
            const category = {
              'Entity': 'entities',
              'Location': 'locations',
              'Goal': 'resources',
              'Obstacle': 'authorities',
              'Shift': 'conflicts'
            }[entity.type] || 'entities';
            
            ontology[category].push({
              id: entity.id,
              name: entity.name,
              type: entity.type,
              position: scene.gridMapping?.find(g => g.id === entity.id)
            });
          });
        }
        
        // Extract relationships
        if (scene.entities) {
          scene.entities.forEach(entity => {
            if (entity.relations) {
              entity.relations.forEach(rel => {
                ontology.relationships.push({
                  source: entity.id,
                  target: rel.target,
                  type: rel.type
                });
              });
            }
          });
        }
        
        // Extract narrative state
        if (scene.scorecard) {
          ontology.narrative.progress = scene.scorecard.progress || 0;
          ontology.narrative.caution = scene.scorecard.caution || 0;
        }
        if (scene.tension) {
          ontology.narrative.tension = scene.tension;
        }
      }
      
      // Calculate ontology-based parameters
      const totalEntities = ontology.entities.length + ontology.locations.length + 
                           ontology.resources.length + ontology.authorities.length;
      const conflictRatio = ontology.conflicts.length / Math.max(1, totalEntities);
      const authorityRatio = ontology.authorities.length / Math.max(1, totalEntities);
      const resourceRatio = ontology.resources.length / Math.max(1, totalEntities);
      
      ontology.derivedParams = {
        legitimacy: 0.7 - (conflictRatio * 0.4) - (ontology.narrative.tension * 0.3),
        copEffectiveness: 0.3 + (authorityRatio * 0.4),
        initialHardship: 0.3 + (ontology.narrative.caution * 0.5),
        contestedResources: resourceRatio > 0.15
      };
      
      console.log('[ONTOLOGY] Generated scene ontology:', ontology);
      return ontology;
    }
    
    // ═══════════════════════════════════════════════════════════════════
    // DIFFRACTIVE METHODOLOGY - Barad's Agential Realism
    // ═══════════════════════════════════════════════════════════════════
    
    // Capture simulation state for diffractive analysis
    function captureSimulationSnapshot(channel) {
      const agents = channel.culturalAgents;
      const params = channel.culturalParams;
      
      // Agent distribution
      const distribution = {
        citizens: Object.values(agents).filter(a => a.type === 'citizen').length,
        rebels: Object.values(agents).filter(a => a.type === 'rebel').length,
        cops: Object.values(agents).filter(a => a.type === 'cop').length
      };
      
      // Spatial patterns (clustering coefficient)
      const spatialPatterns = calculateSpatialPatterns(agents);
      
      // Symbolic role distribution
      const roleDistribution = {};
      Object.values(agents).forEach(agent => {
        const role = agent.legosCellRef?.entity?.symbolicRole || 'unknown';
        roleDistribution[role] = (roleDistribution[role] || 0) + 1;
      });
      
      // Average states
      const avgFear = Object.values(agents).reduce((sum, a) => sum + a.fear, 0) / Math.max(1, Object.keys(agents).length);
      const avgEnergy = Object.values(agents).reduce((sum, a) => sum + a.energy, 0) / Math.max(1, Object.keys(agents).length);
      
      return {
        tick: channel.culturalTick,
        framework: params.framework,
        useBDI: params.useBDI,
        distribution,
        spatialPatterns,
        roleDistribution,
        legitimacy: params.pragmatic.legitimacy,
        copEffectiveness: params.pragmatic.copEffectiveness,
        avgFear,
        avgEnergy,
        timestamp: Date.now()
      };
    }
    
    // Calculate spatial clustering patterns
    function calculateSpatialPatterns(agents) {
      let rebelClusters = 0;
      let copClusters = 0;
      let segregationIndex = 0;
      
      Object.entries(agents).forEach(([key, agent]) => {
        const [x, y] = key.split('_').map(Number);
        let sameTypeNeighbors = 0;
        let totalNeighbors = 0;
        
        for (let dy = -1; dy <= 1; dy++) {
          for (let dx = -1; dx <= 1; dx++) {
            if (dx === 0 && dy === 0) continue;
            const nx = x + dx, ny = y + dy;
            if (nx >= 0 && nx < 9 && ny >= 0 && ny < 9) {
              const nkey = `${nx}_${ny}`;
              const neighbor = agents[nkey];
              if (neighbor) {
                totalNeighbors++;
                if (neighbor.type === agent.type) {
                  sameTypeNeighbors++;
                }
              }
            }
          }
        }
        
        if (totalNeighbors > 0) {
          const homophily = sameTypeNeighbors / totalNeighbors;
          segregationIndex += homophily;
          
          if (agent.type === 'rebel' && sameTypeNeighbors >= 2) rebelClusters++;
          if (agent.type === 'cop' && sameTypeNeighbors >= 2) copClusters++;
        }
      });
      
      return {
        segregationIndex: segregationIndex / Math.max(1, Object.keys(agents).length),
        rebelClusters,
        copClusters
      };
    }
    
    // Diffractive analysis: Compare two snapshots to reveal patterns of difference
    function diffractiveAnalysis(snapshot1, snapshot2) {
      console.group('🔬 [DIFFRACTIVE ANALYSIS] Barad\'s Agential Cuts');
      
      console.log('Comparing two entangled configurations:');
      console.log(`  Configuration A: ${snapshot1.framework} (${snapshot1.useBDI ? 'BDI' : 'Standard'}) @ Tick ${snapshot1.tick}`);
      console.log(`  Configuration B: ${snapshot2.framework} (${snapshot2.useBDI ? 'BDI' : 'Standard'}) @ Tick ${snapshot2.tick}`);
      
      // Population dynamics difference
      const popDiff = {
        citizens: snapshot2.distribution.citizens - snapshot1.distribution.citizens,
        rebels: snapshot2.distribution.rebels - snapshot1.distribution.rebels,
        cops: snapshot2.distribution.cops - snapshot1.distribution.cops
      };
      
      console.log('\n📊 Population Interference Pattern:');
      console.log(`  Citizens: ${popDiff.citizens > 0 ? '+' : ''}${popDiff.citizens}`);
      console.log(`  Rebels: ${popDiff.rebels > 0 ? '+' : ''}${popDiff.rebels}`);
      console.log(`  Cops: ${popDiff.cops > 0 ? '+' : ''}${popDiff.cops}`);
      
      // Spatial pattern divergence
      const spatialDiff = {
        segregation: snapshot2.spatialPatterns.segregationIndex - snapshot1.spatialPatterns.segregationIndex,
        rebelClusters: snapshot2.spatialPatterns.rebelClusters - snapshot1.spatialPatterns.rebelClusters,
        copClusters: snapshot2.spatialPatterns.copClusters - snapshot1.spatialPatterns.copClusters
      };
      
      console.log('\n🗺️ Spatial Entanglement Difference:');
      console.log(`  Segregation Index: ${spatialDiff.segregation > 0 ? '+' : ''}${spatialDiff.segregation.toFixed(3)}`);
      console.log(`  Rebel Clustering: ${spatialDiff.rebelClusters > 0 ? '+' : ''}${spatialDiff.rebelClusters}`);
      console.log(`  Cop Clustering: ${spatialDiff.copClusters > 0 ? '+' : ''}${spatialDiff.copClusters}`);
      
      // Parameter divergence
      const paramDiff = {
        legitimacy: snapshot2.legitimacy - snapshot1.legitimacy,
        copEffectiveness: snapshot2.copEffectiveness - snapshot1.copEffectiveness,
        fear: snapshot2.avgFear - snapshot1.avgFear,
        energy: snapshot2.avgEnergy - snapshot1.avgEnergy
      };
      
      console.log('\n⚙️ Parameter Drift (Ongoing Becoming):');
      console.log(`  Legitimacy: ${paramDiff.legitimacy > 0 ? '+' : ''}${(paramDiff.legitimacy * 100).toFixed(1)}%`);
      console.log(`  Cop Effectiveness: ${paramDiff.copEffectiveness > 0 ? '+' : ''}${(paramDiff.copEffectiveness * 100).toFixed(1)}%`);
      console.log(`  Avg Fear: ${paramDiff.fear > 0 ? '+' : ''}${paramDiff.fear.toFixed(3)}`);
      console.log(`  Avg Energy: ${paramDiff.energy > 0 ? '+' : ''}${paramDiff.energy.toFixed(3)}`);
      
      // Symbolic role emergence difference
      console.log('\n🎭 Symbolic Role Reconfigurations:');
      const allRoles = new Set([
        ...Object.keys(snapshot1.roleDistribution),
        ...Object.keys(snapshot2.roleDistribution)
      ]);
      
      allRoles.forEach(role => {
        const count1 = snapshot1.roleDistribution[role] || 0;
        const count2 = snapshot2.roleDistribution[role] || 0;
        const diff = count2 - count1;
        if (diff !== 0) {
          console.log(`  ${role}: ${diff > 0 ? '+' : ''}${diff} agents`);
        }
      });
      
      // Diffractive insight
      console.log('\n💡 Diffractive Insight (Barad):');
      
      const rebellionPressure1 = snapshot1.distribution.rebels / Math.max(1, snapshot1.distribution.citizens);
      const rebellionPressure2 = snapshot2.distribution.rebels / Math.max(1, snapshot2.distribution.citizens);
      const rebellionDivergence = Math.abs(rebellionPressure2 - rebellionPressure1);
      
      if (rebellionDivergence > 0.2) {
        console.log(`  Strong interference in rebellion dynamics (${rebellionDivergence.toFixed(2)})`);
        console.log(`  → Different agential cuts produce divergent uprisings`);
      } else if (spatialDiff.segregation > 0.1) {
        console.log(`  Spatial patterns show constructive interference`);
        console.log(`  → Clustering emerges regardless of framework`);
      } else {
        console.log(`  Patterns show convergence despite different apparatuses`);
        console.log(`  → LEGOS mythology constrains possible becomings`);
      }
      
      console.log('\n📐 Material-Discursive Entanglement:');
      console.log(`  Framework choices are not neutral observations but active interventions`);
      console.log(`  Each simulation co-constitutes different cultural realities`);
      console.log(`  The modeler, model, and phenomena are inseparable`);
      
      console.groupEnd();
      
      return {
        popDiff,
        spatialDiff,
        paramDiff,
        rebellionDivergence,
        convergence: rebellionDivergence < 0.1 && Math.abs(spatialDiff.segregation) < 0.05
      };
    }
    
    // Analyze LEGOS entity to derive cultural meaning from narrative
    function analyzeLEGOSNarrative(entity) {
      if (!entity) return { culturalType: 'citizen', hardship: 0.5, riskAversion: 0.5, symbolicRole: 'neutral' };
      
      const perspective = (entity.perspective || '').toLowerCase();
      const name = (entity.name || '').toLowerCase();
      
      // Analyze perspective for cultural markers
      let culturalType = 'citizen';
      let hardship = 0.5;
      let riskAversion = 0.5;
      let symbolicRole = 'neutral';
      
      // Authority/enforcement markers
      if (perspective.match(/authority|enforce|control|command|guard|protect|patrol|law/)) {
        culturalType = 'cop';
        hardship = 0.2;
        riskAversion = 0.3;
        symbolicRole = 'enforcer';
      }
      // Resistance/freedom markers
      else if (perspective.match(/resist|rebel|fight|freedom|uprising|revolt|challenge|defy/)) {
        culturalType = 'rebel';
        hardship = 0.8;
        riskAversion = 0.3;
        symbolicRole = 'resistance';
      }
      // Oppression/hardship markers
      else if (perspective.match(/suffer|struggle|oppress|harsh|difficult|pain|burden|hardship/)) {
        culturalType = 'citizen';
        hardship = 0.8;
        riskAversion = 0.7;
        symbolicRole = 'oppressed';
      }
      // Power/elite markers
      else if (perspective.match(/power|elite|noble|king|ruler|sovereign|throne/)) {
        culturalType = 'cop';
        hardship = 0.1;
        riskAversion = 0.2;
        symbolicRole = 'elite';
      }
      // Storm/chaos as symbolic disruption
      else if (perspective.match(/storm|chaos|thunder|tempest|wild|fierce/) || name.match(/storm|thunder|tempest/)) {
        culturalType = 'rebel';
        hardship = 0.6;
        riskAversion = 0.4;
        symbolicRole = 'chaos_agent';
      }
      // Wisdom/mediation markers
      else if (perspective.match(/wise|mediat|peace|calm|balance|harmony/)) {
        culturalType = 'citizen';
        hardship = 0.3;
        riskAversion = 0.6;
        symbolicRole = 'mediator';
      }
      
      // Check relations for cultural context
      if (entity.relations && entity.relations.length > 0) {
        // High connectivity suggests collective actor
        if (entity.relations.length > 3) {
          riskAversion *= 0.8; // More connected = less risk-averse (social support)
        }
      }
      
      console.log(`[LEGOS NARRATIVE] ${entity.name}: culturalType=${culturalType}, symbolicRole=${symbolicRole}, perspective="${perspective.substring(0, 50)}..."`);
      
      return { culturalType, hardship, riskAversion, symbolicRole };
    }
    
    // Initialize agents on grid cells - CREATE PROPER LEGOS ENTITIES
    function initCulturalAgents(channel, density = 0.75) {
      const agents = {};
      const params = channel.culturalParams.pragmatic;
      let agentIdCounter = 1000; // Start IDs high to avoid conflicts
      
      // First pass: ENHANCE existing grid elements with cultural metadata (LEGOS-AWARE)
      for (let y = 0; y < 9; y++) {
        for (let x = 0; x < 9; x++) {
          const existingCell = channel.grid[y][x];
          if (existingCell) {
            const key = `${x}_${y}`;
            const cellType = existingCell.type || 'Entity';
            
            // ANALYZE LEGOS NARRATIVE to derive cultural meaning
            let culturalType, hardship, riskAversion, symbolicRole;
            
            if (existingCell.entity) {
              // Use narrative analysis
              const analysis = analyzeLEGOSNarrative(existingCell.entity);
              culturalType = analysis.culturalType;
              hardship = analysis.hardship;
              riskAversion = analysis.riskAversion;
              symbolicRole = analysis.symbolicRole;
            } else {
              // Fallback to type-based mapping
              if (cellType === 'Obstacle' || cellType === 'Shift') {
                culturalType = 'cop';
                hardship = 0.1;
                riskAversion = 0.3;
                symbolicRole = 'enforcer';
              } else if (cellType === 'Goal') {
                culturalType = 'rebel';
                hardship = 0.8;
                riskAversion = 0.4;
                symbolicRole = 'resistance';
              } else {
                culturalType = 'citizen';
                hardship = 0.3 + Math.random() * 0.5;
                riskAversion = 0.4 + Math.random() * 0.4;
                symbolicRole = 'neutral';
              }
            }
            
            // Enhance existing entity with cultural data (preserving LEGOS narrative)
            if (existingCell.entity && !existingCell.entity.culturalType) {
              existingCell.entity.culturalType = culturalType;
              existingCell.entity.symbolicRole = symbolicRole;
              existingCell.entity.culturalBeliefs = {
                utility: culturalType === 'cop' ? 0.8 : 0.5 + Math.random() * 0.3,
                symbolic: Math.random(),
                reflexive: Math.random()
              };
              existingCell.entity.culturalTraits = {
                hardship,
                riskAversion,
                social: Math.random()
              };
            }
            
            agents[key] = {
              type: culturalType,
              legosCellRef: existingCell,
              beliefs: existingCell.entity?.culturalBeliefs || {
                utility: culturalType === 'cop' ? 0.8 : 0.5 + Math.random() * 0.3,
                symbolic: Math.random(),
                reflexive: Math.random()
              },
              traits: existingCell.entity?.culturalTraits || {
                hardship,
                riskAversion,
                social: Math.random()
              },
              energy: 1.0,
              fear: culturalType === 'rebel' ? 0.7 : 0,
              perceivedRisk: 0,
              memory: []
            };
          }
        }
      }
      
      // Second pass: CREATE NEW LEGOS ENTITIES in empty cells
      const emptyIndices = [];
      for (let y = 0; y < 9; y++) {
        for (let x = 0; x < 9; x++) {
          if (!channel.grid[y][x]) {
            emptyIndices.push({ x, y });
          }
        }
      }
      
      // Fisher-Yates shuffle
      for (let i = emptyIndices.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [emptyIndices[i], emptyIndices[j]] = [emptyIndices[j], emptyIndices[i]];
      }
      
      const existingCount = Object.keys(agents).length;
      const targetTotal = Math.floor(81 * density);
      const toAdd = Math.max(0, targetTotal - existingCount);
      
      const citizenCount = Math.floor(toAdd * (params.citizenRatio || 0.72));
      const copCount = Math.floor(toAdd * (params.copRatio || 0.06));
      
      let added = 0;
      
      // CREATE CITIZENS as proper LEGOS entities
      for (let i = 0; i < citizenCount && added < toAdd && added < emptyIndices.length; i++, added++) {
        const { x, y } = emptyIndices[added];
        const key = `${x}_${y}`;
        const id = `cultural-citizen-${agentIdCounter++}`;
        const hardship = Math.random();
        const riskAversion = Math.random();
        
        // CREATE FULL LEGOS ENTITY
        const entity = {
          id,
          name: `Citizen ${agentIdCounter - 1000}`,
          type: 'Entity',
          culturalType: 'citizen',
          culturalBeliefs: {
            utility: 0.5 + Math.random() * 0.3,
            symbolic: Math.random(),
            reflexive: Math.random()
          },
          culturalTraits: {
            hardship,
            riskAversion,
            social: Math.random()
          },
          perspective: `A citizen with hardship ${(hardship * 100).toFixed(0)}% and risk aversion ${(riskAversion * 100).toFixed(0)}%. Part of the cultural simulation.`
        };
        
        // WRITE TO CHANNEL.GRID (LEGOS CORE)
        channel.grid[y][x] = {
          id,
          type: 'Entity',
          symbol: '○',
          label: entity.name,
          entity
        };
        
        logCellEvent(channel, x, y, `Cultural citizen spawned`);
        
        agents[key] = {
          type: 'citizen',
          legosCellRef: channel.grid[y][x],
          beliefs: entity.culturalBeliefs,
          traits: entity.culturalTraits,
          energy: 1.0,
          fear: 0,
          perceivedRisk: 0,
          memory: []
        };
      }
      
      // CREATE COPS as proper LEGOS entities
      for (let i = 0; i < copCount && added < toAdd && added < emptyIndices.length; i++, added++) {
        const { x, y } = emptyIndices[added];
        const key = `${x}_${y}`;
        const id = `cultural-cop-${agentIdCounter++}`;
        
        const entity = {
          id,
          name: `Cop ${agentIdCounter - 1000}`,
          type: 'Obstacle',
          culturalType: 'cop',
          culturalBeliefs: {
            utility: 0.8,
            symbolic: Math.random(),
            reflexive: Math.random()
          },
          culturalTraits: {
            hardship: 0.1,
            riskAversion: 0.3,
            social: 0.6
          },
          perspective: `An authority agent enforcing order. High utility (80%), low hardship. Part of the cultural simulation.`
        };
        
        channel.grid[y][x] = {
          id,
          type: 'Obstacle',
          symbol: '◆',
          label: entity.name,
          entity
        };
        
        logCellEvent(channel, x, y, `Cultural cop spawned`);
        
        agents[key] = {
          type: 'cop',
          legosCellRef: channel.grid[y][x],
          beliefs: entity.culturalBeliefs,
          traits: entity.culturalTraits,
          energy: 1.0,
          fear: 0,
          perceivedRisk: 0,
          memory: []
        };
      }
      
      // Log the mythology seed analysis
      const roleDistribution = {};
      Object.values(agents).forEach(agent => {
        const role = agent.legosCellRef?.entity?.symbolicRole || 'unknown';
        roleDistribution[role] = (roleDistribution[role] || 0) + 1;
      });
      
      console.log(`[LEGOS CULTURAL] Created ${Object.keys(agents).length} agents`);
      console.log(`[MYTHOLOGY SEED] Symbolic roles derived from LEGOS narratives:`, roleDistribution);
      console.log(`[MYTHOLOGY SEED] This scene's cultural dynamics emerge from LEGOS perspectives and relations`);
      
      channel.culturalAgents = agents;
    }
    
    // Pragmatic Layer: Action → Meaning (Civil Unrest Model)
    function updatePragmaticLayer(channel) {
      const params = channel.culturalParams.pragmatic;
      const agents = channel.culturalAgents;
      const framework = channel.culturalParams.framework || 'epstein';
      const useBDI = channel.culturalParams.useBDI;
      
      // Framework audit logging
      if (channel.culturalTick % 10 === 0) {
        console.log(`[FRAMEWORK] Active: ${framework}, BDI: ${useBDI}, Tick: ${channel.culturalTick}`);
      }
      
      // BDI REASONING PHASE (if enabled)
      if (useBDI) {
        console.group(`[BDI] Reasoning Cycle - Tick ${channel.culturalTick}`);
        
        const worldState = {
          agents,
          legitimacy: params.legitimacy,
          grid: channel.grid
        };
        
        let bdiActionCount = 0;
        Object.entries(agents).forEach(([key, agent]) => {
          if (agent.bdiAgent) {
            // Update beliefs from environment
            agent.bdiAgent.updateBeliefs(worldState);
            
            // Generate desires based on new beliefs
            agent.bdiAgent.updateDesires();
            
            // Form intentions from desires
            agent.bdiAgent.formIntentions();
            
            // Log first 3 agents for audit
            if (bdiActionCount < 3) {
              const entity = agent.legosCellRef?.entity;
              console.log(`[BDI] ${entity?.name || key}:`, {
                type: agent.type,
                symbolicRole: agent.bdiAgent.beliefs.symbolicMeaning,
                beliefs: {
                  threats: agent.bdiAgent.beliefs.nearbyThreats.length,
                  allies: agent.bdiAgent.beliefs.nearbyAllies.length,
                  legitimacy: agent.bdiAgent.beliefs.perceivedLegitimacy.toFixed(2)
                },
                desires: Array.from(agent.bdiAgent.desires),
                intention: agent.bdiAgent.currentIntention
              });
              bdiActionCount++;
            }
            
            // Execute intention (store for movement phase)
            const action = agent.bdiAgent.execute(worldState);
            if (action) {
              agent.bdiAction = action;
            }
          }
        });
        
        console.groupEnd();
      }
      
      // Framework-specific metrics logging (every 10 ticks)
      if (channel.culturalTick % 10 === 0) {
        const citizens = Object.values(agents).filter(a => a.type === 'citizen').length;
        const rebels = Object.values(agents).filter(a => a.type === 'rebel').length;
        const cops = Object.values(agents).filter(a => a.type === 'cop').length;
        
        console.group(`[${framework.toUpperCase()}] Metrics - Tick ${channel.culturalTick}`);
        console.log('Population:', { citizens, rebels, cops });
        console.log('Legitimacy:', (params.legitimacy * 100).toFixed(1) + '%');
        console.log('Cop Effectiveness:', (params.copEffectiveness * 100).toFixed(1) + '%');
        
        // Framework-specific metrics
        if (framework === 'epstein') {
          const avgGrievance = Object.values(agents)
            .filter(a => a.type === 'citizen')
            .reduce((sum, a) => sum + (a.traits.hardship * (1 - params.legitimacy)), 0) / Math.max(1, citizens);
          console.log('Avg Citizen Grievance:', avgGrievance.toFixed(2));
        }
        
        if (framework === 'iruba') {
          const avgFear = Object.values(agents).reduce((sum, a) => sum + a.fear, 0) / Math.max(1, Object.keys(agents).length);
          const avgAnger = Object.values(agents)
            .filter(a => a.anger !== undefined)
            .reduce((sum, a) => sum + a.anger, 0) / Math.max(1, Object.keys(agents).length);
          console.log('Avg Fear:', avgFear.toFixed(2));
          console.log('Avg Anger:', avgAnger.toFixed(2));
        }
        
        if (framework === 'rebeland') {
          const networkDensity = Object.values(agents)
            .filter(a => a.legosCellRef?.entity?.relations)
            .reduce((sum, a) => sum + (a.legosCellRef.entity.relations?.length || 0), 0) / Math.max(1, Object.keys(agents).length);
          console.log('Network Density:', networkDensity.toFixed(2), 'relations/agent');
        }
        
        console.groupEnd();
      }
      
      // Calculate effective legitimacy (modulated by structural layer if active)
      let legitimacy = params.legitimacy || 0.55;
      if (channel.culturalParams.structural) {
        // Structural layer coherence affects legitimacy
        const avgSymbolic = Object.values(agents)
          .filter(a => a.beliefs.symbolic !== undefined)
          .reduce((sum, a) => sum + a.beliefs.symbolic, 0) / Math.max(1, Object.keys(agents).length);
        legitimacy += (avgSymbolic - 0.5) * 0.3; // ±15% swing
        legitimacy = Math.max(0, Math.min(1, legitimacy));
      }
      
      // Calculate risk perception adjustment from reflexive layer
      let riskAdjustment = 1.0;
      if (channel.culturalParams.reflexive) {
        const avgReflexive = Object.values(agents)
          .filter(a => a.beliefs.reflexive !== undefined)
          .reduce((sum, a) => sum + a.beliefs.reflexive, 0) / Math.max(1, Object.keys(agents).length);
        riskAdjustment = 0.5 + avgReflexive; // 0.5x to 1.5x risk perception
      }
      
      // Phase 1: Calculate risk for each agent
      Object.entries(agents).forEach(([key, agent]) => {
        const [x, y] = key.split('_').map(Number);
        let cops = 0, rebels = 0;
        
        // Count neighbors in radius
        const radius = 2;
        for (let dy = -radius; dy <= radius; dy++) {
          for (let dx = -radius; dx <= radius; dx++) {
            if (dx === 0 && dy === 0) continue;
            const nx = x + dx, ny = y + dy;
            if (nx >= 0 && nx < 9 && ny >= 0 && ny < 9) {
              const nkey = `${nx}_${ny}`;
              const neighbor = agents[nkey];
              if (neighbor) {
                if (neighbor.type === 'cop') cops++;
                if (neighbor.type === 'rebel') rebels++;
              }
            }
          }
        }
        
        // Risk calculation: cops suppress rebels
        const copEffectiveness = params.copEffectiveness || 0.45;
        const baseRisk = copEffectiveness * (cops / (rebels + 1));
        agent.perceivedRisk = Math.max(0.05, Math.min(1, baseRisk)) * riskAdjustment;
        
        // Store for transitions
        if (!agent.transitions) agent.transitions = {};
      });
      
      // Phase 2: Decision making
      const toRebel = [];
      const toCitizen = [];
      let arrestCount = 0;
      
      Object.entries(agents).forEach(([key, agent]) => {
        if (agent.type === 'citizen') {
          // Grievance model: hardship × (1 - legitimacy)
          const grievance = agent.traits.hardship * (1 - legitimacy);
          const riskThreshold = agent.traits.riskAversion * agent.perceivedRisk;
          
          if (grievance > riskThreshold) {
            toRebel.push(key);
          }
        } else if (agent.type === 'rebel') {
          // Fear dynamics
          const fearDecay = params.fearDecay || 0.25;
          agent.fear = Math.max(0, Math.min(1, 
            agent.fear + agent.perceivedRisk * 0.25 - fearDecay
          ));
          
          const grievance = agent.traits.hardship * (1 - legitimacy);
          const stayPressure = grievance + (1 - agent.fear) * 0.4;
          const crackdown = agent.traits.riskAversion * (agent.perceivedRisk + agent.fear * 0.6);
          
          if (stayPressure < crackdown) {
            toCitizen.push({ key, voluntary: true });
          }
        } else if (agent.type === 'cop') {
          // Cops arrest adjacent rebels
          const [x, y] = key.split('_').map(Number);
          for (let dy = -1; dy <= 1; dy++) {
            for (let dx = -1; dx <= 1; dx++) {
              if (dx === 0 && dy === 0) continue;
              const nx = x + dx, ny = y + dy;
              if (nx >= 0 && nx < 9 && ny >= 0 && ny < 9) {
                const nkey = `${nx}_${ny}`;
                const neighbor = agents[nkey];
                if (neighbor && neighbor.type === 'rebel') {
                  const arrestChance = (params.copEffectiveness || 0.45) * 0.85;
                  if (Math.random() < arrestChance) {
                    toCitizen.push({ key: nkey, voluntary: false });
                    arrestCount++;
                  } else {
                    neighbor.fear = Math.min(1, neighbor.fear + 0.3);
                  }
                }
              }
            }
          }
        }
      });
      
      // Phase 3: Apply transitions - UPDATE LEGOS ENTITIES
      toRebel.forEach(key => {
        const agent = agents[key];
        agent.type = 'rebel';
        agent.fear = 0.8;
        agent.beliefs.utility = 0.3;
        
        // UPDATE LEGOS ENTITY
        if (agent.legosCellRef && agent.legosCellRef.entity) {
          agent.legosCellRef.entity.culturalType = 'rebel';
          agent.legosCellRef.entity.culturalBeliefs = agent.beliefs;
          agent.legosCellRef.type = 'Goal'; // Goals are contested
          agent.legosCellRef.symbol = '▲';
          
          const [x, y] = key.split('_').map(Number);
          logCellEvent(channel, x, y, `Citizen became Rebel (grievance > risk)`);
        }
      });
      
      toCitizen.forEach(({ key, voluntary }) => {
        const agent = agents[key];
        agent.type = 'citizen';
        agent.traits.hardship = Math.random();
        agent.traits.riskAversion = Math.random();
        agent.fear = voluntary ? Math.min(1, agent.fear + 0.2) : 1.0;
        agent.beliefs.utility = voluntary ? 0.4 : 0.2;
        
        // UPDATE LEGOS ENTITY
        if (agent.legosCellRef && agent.legosCellRef.entity) {
          agent.legosCellRef.entity.culturalType = 'citizen';
          agent.legosCellRef.entity.culturalBeliefs = agent.beliefs;
          agent.legosCellRef.entity.culturalTraits = agent.traits;
          agent.legosCellRef.type = 'Entity';
          agent.legosCellRef.symbol = '○';
          
          const [x, y] = key.split('_').map(Number);
          logCellEvent(channel, x, y, voluntary ? `Rebel surrendered (fear)` : `Rebel arrested by cop`);
        }
      });
      
      // Energy dynamics
      Object.values(agents).forEach(agent => {
        if (agent.type === 'rebel') {
          agent.energy -= 0.05; // Rebellion is costly
        } else if (agent.type === 'cop') {
          agent.energy -= 0.02; // Policing is work
        } else {
          agent.energy = Math.min(1, agent.energy + 0.01); // Citizens recover
        }
      });
      
      // Phase 4: MOVEMENT - agents move based on cultural forces
      const movements = []; // Track movement intentions
      
      Object.entries(agents).forEach(([key, agent]) => {
        const [x, y] = key.split('_').map(Number);
        let targetX = x, targetY = y;
        let moveReason = '';
        
        // Movement rules based on type and state
        if (agent.type === 'citizen' && agent.fear > 0.6) {
          // High fear citizens flee from cops
          let copX = -1, copY = -1;
          for (let dy = -2; dy <= 2; dy++) {
            for (let dx = -2; dx <= 2; dx++) {
              const nx = x + dx, ny = y + dy;
              if (nx >= 0 && nx < 9 && ny >= 0 && ny < 9) {
                const nkey = `${nx}_${ny}`;
                if (agents[nkey]?.type === 'cop') {
                  copX = nx; copY = ny;
                  break;
                }
              }
            }
            if (copX >= 0) break;
          }
          
          if (copX >= 0) {
            // Move away from cop
            const fleeX = x + Math.sign(x - copX);
            const fleeY = y + Math.sign(y - copY);
            if (fleeX >= 0 && fleeX < 9 && fleeY >= 0 && fleeY < 9) {
              targetX = fleeX;
              targetY = fleeY;
              moveReason = 'fleeing cop';
            }
          }
        } else if (agent.type === 'rebel' && agent.fear < 0.4) {
          // Bold rebels move toward other rebels (solidarity)
          let nearestRebelDist = 999;
          let nearestRebelX = -1, nearestRebelY = -1;
          
          Object.entries(agents).forEach(([nkey, nagent]) => {
            if (nagent.type === 'rebel' && nkey !== key) {
              const [nx, ny] = nkey.split('_').map(Number);
              const dist = Math.abs(nx - x) + Math.abs(ny - y);
              if (dist < nearestRebelDist) {
                nearestRebelDist = dist;
                nearestRebelX = nx;
                nearestRebelY = ny;
              }
            }
          });
          
          if (nearestRebelX >= 0 && nearestRebelDist > 1) {
            // Move toward nearest rebel
            const moveX = x + Math.sign(nearestRebelX - x);
            const moveY = y + Math.sign(nearestRebelY - y);
            if (moveX >= 0 && moveX < 9 && moveY >= 0 && moveY < 9) {
              targetX = moveX;
              targetY = moveY;
              moveReason = 'joining rebels';
            }
          }
        } else if (agent.type === 'cop') {
          // Cops move toward nearest rebel
          let nearestRebelDist = 999;
          let nearestRebelX = -1, nearestRebelY = -1;
          
          Object.entries(agents).forEach(([nkey, nagent]) => {
            if (nagent.type === 'rebel') {
              const [nx, ny] = nkey.split('_').map(Number);
              const dist = Math.abs(nx - x) + Math.abs(ny - y);
              if (dist < nearestRebelDist) {
                nearestRebelDist = dist;
                nearestRebelX = nx;
                nearestRebelY = ny;
              }
            }
          });
          
          if (nearestRebelX >= 0 && nearestRebelDist > 1) {
            const moveX = x + Math.sign(nearestRebelX - x);
            const moveY = y + Math.sign(nearestRebelY - y);
            if (moveX >= 0 && moveX < 9 && moveY >= 0 && moveY < 9) {
              targetX = moveX;
              targetY = moveY;
              moveReason = 'pursuing rebel';
            }
          }
        }
        
        if (targetX !== x || targetY !== y) {
          movements.push({ from: key, toX: targetX, toY: targetY, agent, reason: moveReason });
        }
      });
      
      // Apply movements (non-conflicting only)
      const occupied = new Set(Object.keys(agents));
      let movedCount = 0;
      
      movements.forEach(({ from, toX, toY, agent, reason }) => {
        const toKey = `${toX}_${toY}`;
        
        // Only move if target is empty or can swap
        if (!occupied.has(toKey) || Math.random() < 0.3) {
          const [fromX, fromY] = from.split('_').map(Number);
          
          // Update LEGOS grid
          const temp = channel.grid[fromY][fromX];
          if (!channel.grid[toY][toX]) {
            channel.grid[toY][toX] = temp;
            channel.grid[fromY][fromX] = null;
            
            // Update agent registry
            delete agents[from];
            agents[toKey] = agent;
            agent.legosCellRef = channel.grid[toY][toX];
            
            logCellEvent(channel, toX, toY, `Agent moved here (${reason})`);
            logCellEvent(channel, fromX, fromY, `Agent left (${reason})`);
            
            occupied.delete(from);
            occupied.add(toKey);
            movedCount++;
          }
        }
      });
      
      if (movedCount > 0) {
        console.log(`[MOVEMENT] ${movedCount}/${movements.length} agents moved this tick`);
      }
      
      // Store metrics for cross-layer effects
      if (!channel.culturalMetrics) channel.culturalMetrics = {};
      channel.culturalMetrics.rebellionRate = toRebel.length / Math.max(1, Object.keys(agents).length);
      channel.culturalMetrics.arrestRate = arrestCount / Math.max(1, Object.keys(agents).length);
      channel.culturalMetrics.legitimacy = legitimacy;
      channel.culturalMetrics.movementCount = movements.length;
    }
    
    // Structural Layer: Meaning → Action (Sahlins/MacOS)
    function updateStructuralLayer(channel) {
      const params = channel.culturalParams.structural;
      const agents = channel.culturalAgents;
      
      // Get pragmatic metrics for cross-layer effects
      const metrics = channel.culturalMetrics || {};
      const rebellionShock = metrics.rebellionRate || 0;
      
      Object.entries(agents).forEach(([key, agent]) => {
        // All agents maintain symbolic beliefs, but some specialize
        const isSpecialized = agent.type === 'ritual' || agent.type === 'interpreter';
        
        // Symbolic coherence maintenance
        const symbolicTarget = agent.memory.length > 0 
          ? agent.memory[agent.memory.length - 1].symbolic 
          : agent.beliefs.symbolic;
        
        // Pull toward mythic coherence
        const delta = (symbolicTarget - agent.beliefs.symbolic) * (1 - params.symbolicInertia);
        agent.beliefs.symbolic += delta * 0.1;
        
        // Boundary enforcement (stronger during rebellion)
        const boundaryPressure = params.boundaryStrength * (1 + rebellionShock * 2);
        if (Math.abs(agent.beliefs.symbolic - 0.5) > boundaryPressure) {
          agent.beliefs.symbolic *= 0.95; // Pull back toward center
        }
        
        // Rebellion disrupts symbolic order
        if (rebellionShock > 0.1) {
          agent.beliefs.symbolic += (Math.random() - 0.5) * rebellionShock * 0.3;
        }
        
        // Clamp beliefs
        agent.beliefs.symbolic = Math.max(0, Math.min(1, agent.beliefs.symbolic));
        
        // Energy cost for maintaining structure
        const energyCost = isSpecialized ? 0.01 * params.mythicCoherence : 0.005;
        agent.energy -= energyCost;
      });
    }
    
    // Reflexive Layer: Observation → Execution (Geertz/Linux)
    function updateReflexiveLayer(channel) {
      const params = channel.culturalParams.reflexive;
      const agents = channel.culturalAgents;
      
      // Get pragmatic metrics for cross-layer effects
      const metrics = channel.culturalMetrics || {};
      const arrestIntensity = (metrics.arrestRate || 0) * 10; // Scale up
      
      // Build observation field - agents observe neighbors
      const observations = {};
      Object.entries(agents).forEach(([key, agent]) => {
        const [x, y] = key.split('_').map(Number);
        const neighbors = [];
        
        // Check 8 neighbors (expand radius during crackdowns)
        const radius = arrestIntensity > 0.5 ? 2 : 1;
        for (let dy = -radius; dy <= radius; dy++) {
          for (let dx = -radius; dx <= radius; dx++) {
            if (dx === 0 && dy === 0) continue;
            const nx = x + dx, ny = y + dy;
            if (nx >= 0 && nx < 9 && ny >= 0 && ny < 9) {
              const nkey = `${nx}_${ny}`;
              if (agents[nkey]) neighbors.push(agents[nkey]);
            }
          }
        }
        
        observations[key] = neighbors;
      });
      
      // Update based on mutual observation
      Object.entries(agents).forEach(([key, agent]) => {
        const neighbors = observations[key] || [];
        if (neighbors.length === 0) return;
        
        // Calculate average neighbor reflexivity
        const avgReflexive = neighbors.reduce((sum, n) => sum + n.beliefs.reflexive, 0) / neighbors.length;
        
        // Arrests amplify observation intensity
        const observationMultiplier = 1 + arrestIntensity;
        const delta = (avgReflexive - agent.beliefs.reflexive) * 
                      params.observationWeight * 
                      params.mutualAdjustment * 
                      observationMultiplier;
        agent.beliefs.reflexive += delta;
        
        // Recursive interpretation (depth layers)
        if (params.interpretationDepth > 1) {
          const secondOrderDelta = delta * 0.5;
          agent.beliefs.reflexive += secondOrderDelta;
        }
        
        // Clamp beliefs
        agent.beliefs.reflexive = Math.max(0, Math.min(1, agent.beliefs.reflexive));
        
        // Store observation in memory
        agent.memory.push({
          tick: channel.culturalTick,
          reflexive: agent.beliefs.reflexive,
          neighbors: neighbors.length,
          arrestContext: arrestIntensity
        });
        
        // Keep memory bounded
        if (agent.memory.length > 10) agent.memory.shift();
        
        // Energy gain from shared understanding (reduced during crackdowns)
        const understandingBonus = 0.01 * params.mutualAdjustment * neighbors.length / 8;
        agent.energy += understandingBonus * (1 - arrestIntensity * 0.5);
      });
    }
    
    // Render cultural state to grid (ENHANCES LEGOS CELLS)
    function renderCulturalGrid(channel) {
      if (!channel.culturalAnimating) return;
      
      const wrapper = channel.gridWrapper;
      if (!wrapper) return;
      
      // Add visual enhancement layer
      const gridElement = wrapper.querySelector('.channel-grid');
      if (!gridElement) return;
      
      // Add framework indicator label
      let indicator = wrapper.querySelector('.framework-indicator');
      if (!indicator) {
        indicator = document.createElement('div');
        indicator.className = 'framework-indicator';
        indicator.style.cssText = `
          position: absolute;
          top: 4px;
          right: 4px;
          background: rgba(100, 50, 200, 0.85);
          color: white;
          padding: 4px 8px;
          border-radius: 4px;
          font-size: 11px;
          font-weight: bold;
          z-index: 1000;
          pointer-events: none;
          box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        `;
        wrapper.style.position = 'relative';
        wrapper.appendChild(indicator);
      }
      
      const fw = channel.culturalParams?.framework || 'epstein';
      const useBDI = channel.culturalParams?.useBDI;
      const frameworkLabels = {
        'epstein': '⚡ EPSTEIN',
        'bdi': '🧠 BDI',
        'rebeland': '🏛️ REBELAND',
        'iruba': '⚔️ IRUBA',
        'ccim': '🌍 CCIM',
        'axelrod': '🎭 AXELROD',
        'schelling': '🏘️ SCHELLING'
      };
      
      indicator.textContent = frameworkLabels[fw] || fw.toUpperCase();
      if (useBDI && fw !== 'bdi') {
        indicator.textContent += ' + BDI';
      }
      
      const gridCells = channel.dom.gridEl.querySelectorAll('.grid-cell');
      const mode = channel.culturalMode;
      const agents = channel.culturalAgents;
      
      gridCells.forEach((cell, idx) => {
        const x = idx % 9;
        const y = Math.floor(idx / 9);
        const key = `${x}_${y}`;
        const agent = agents[key];
        const legosCell = channel.grid[y][x];
        
        // Get or create cultural overlay element
        let overlay = cell.querySelector('.cultural-overlay');
        
        if (agent && legosCell) {
          if (!overlay) {
            overlay = document.createElement('div');
            overlay.className = 'cultural-overlay';
            overlay.style.cssText = `
              position: absolute;
              inset: 0;
              display: flex;
              align-items: center;
              justify-content: center;
              font-size: 20px;
              pointer-events: none;
              z-index: 5;
            `;
            cell.appendChild(overlay);
          }
          
          // Mode-specific rendering based on cultural type
          let beliefValue = 0.5; // Default value
          let color = 'hsl(180, 50%, 50%)'; // Default color
          const culturalType = legosCell.entity?.culturalType || agent.type;
          
          if (mode === 'pragmatic') {
            // Civil unrest visualization
            if (culturalType === 'citizen') {
              beliefValue = agent.traits?.hardship || 0.5;
              color = `hsl(${180 - beliefValue * 60}, 60%, 55%)`; // Cyan to Green
            } else if (culturalType === 'cop') {
              beliefValue = 0.8;
              color = `hsl(220, 70%, 55%)`; // Blue
            } else if (culturalType === 'rebel') {
              beliefValue = 1 - (agent.fear || 0);
              color = `hsl(${10 - beliefValue * 10}, 80%, ${40 + beliefValue * 20}%)`; // Red spectrum
            } else {
              beliefValue = agent.beliefs?.utility || 0.5;
              color = `hsl(${beliefValue * 120}, 70%, 50%)`;
            }
          } else if (mode === 'structural') {
            beliefValue = agent.beliefs?.symbolic || 0.5;
            color = `hsl(${240 + beliefValue * 120}, 60%, 55%)`; // Blue to Purple
          } else if (mode === 'reflexive') {
            beliefValue = agent.beliefs?.reflexive || 0.5;
            color = `hsl(${30 + beliefValue * 180}, 65%, 60%)`; // Orange to Cyan
          }
          
          // ALWAYS just add glow - LEGOS entity symbols are already there
          if (overlay) overlay.remove();
          cell.style.boxShadow = `inset 0 0 20px ${color}44, 0 0 10px ${color}33`;
          
          // Add cultural class and data attributes
          cell.classList.add('cultural-active');
          cell.style.borderWidth = '2px';
          cell.style.borderStyle = 'solid';
          cell.style.borderColor = color;
          
          // Subtle background tint (doesn't obscure content)
          const tintOpacity = agent.scenarioElement ? '11' : '33';
          cell.style.backgroundColor = `${color}${tintOpacity}`;
          
          // Store cultural data for inspection/tooltips
          cell.setAttribute('data-cultural-type', agent.type || 'unknown');
          cell.setAttribute('data-cultural-belief', (beliefValue || 0).toFixed(2));
          cell.setAttribute('data-cultural-energy', (agent.energy || 0).toFixed(2));
          cell.setAttribute('data-cultural-mode', mode || 'pragmatic');
          
          // Store scenario element info if present
          if (agent.scenarioElement) {
            cell.setAttribute('data-scenario-element', JSON.stringify({
              type: agent.scenarioElement.type,
              label: agent.scenarioElement.label || agent.scenarioElement.name
            }));
          }
          
          // Full agent state in JSON for detailed inspection
          cell.setAttribute('data-cultural-agent', JSON.stringify({
            type: agent.type,
            beliefs: agent.beliefs,
            traits: agent.traits,
            energy: agent.energy,
            memorySize: agent.memory.length,
            wrapsElement: !!agent.scenarioElement
          }));
          
          // Opacity based on energy
          cell.style.opacity = 0.5 + agent.energy * 0.5;
        } else {
          // No agent at this cell
          if (overlay) {
            overlay.remove();
          }
          cell.classList.remove('cultural-active');
          cell.style.borderColor = '';
          cell.style.background = '';
          cell.style.opacity = '';
          cell.removeAttribute('data-cultural-type');
          cell.removeAttribute('data-cultural-belief');
          cell.removeAttribute('data-cultural-energy');
          cell.removeAttribute('data-cultural-mode');
          cell.removeAttribute('data-cultural-agent');
        }
      });
    }
    
    // Master tick function for cultural simulation
    function tickCulturalSimulation(channel) {
      if (!channel.culturalMode || !channel.culturalParams) {
        console.log('[CULTURAL] Tick aborted: no mode or params');
        return;
      }
      
      console.log(`[CULTURAL] Tick ${channel.culturalTick} - mode: ${channel.culturalMode}, animating: ${channel.culturalAnimating}`);
      
      // Update based on active mode
      if (channel.culturalMode === 'pragmatic') {
        updatePragmaticLayer(channel);
      } else if (channel.culturalMode === 'structural') {
        updateStructuralLayer(channel);
      } else if (channel.culturalMode === 'reflexive') {
        updateReflexiveLayer(channel);
      }
      
      // Increment tick counter
      channel.culturalTick++;
      
      // Render LEGOS grid first (entities must be visible)
      renderChannelGrid(channel);
      
      // Then apply cultural visual overlays
      renderCulturalGrid(channel);
      
      // Continue animation if active
      if (channel.culturalAnimating) {
        setTimeout(() => tickCulturalSimulation(channel), 500); // 2 ticks per second
      } else {
        console.log('[CULTURAL] Animation stopped, not scheduling next tick');
      }
    }

    const scenarios = {
      blank: {
        id: 'blank',
        name: 'Custom Tetrad',
        role: 'Media Theorist',
        goal: 'Analyze any medium through McLuhan\'s Four Laws',
        obstacle: 'Identifying dialectical inversions and historical retrievals',
        intro: 'Build your own tetrad analysis. Choose any technology, medium, or cultural form.',
        context: [
          'Four Laws: Enhance, Reverse, Retrieve, Obsolesce',
          'Think dialectically - what does it flip into at extremes?',
          'Historical consciousness - what does it bring back?',
          'Systemic effects - what becomes obsolete?'
        ],
        initialPrompt: '',
        systemInstruction: 'You analyze media and technology through McLuhan\'s tetrad (four laws of media). For any medium, identify: ENHANCE (what it amplifies/intensifies), REVERSE (what it flips into when pushed to extremes), RETRIEVE (what it brings back from obsolescence), OBSOLESCE (what it pushes aside/makes obsolete). Use the LEGOS grid to visually map these relationships. Be rigorous and cite concrete examples. Tetrad reveals the hidden structure of media effects.'
      },
      microdrama: {
        id: 'microdrama',
        name: 'Microdrama Analysis',
        role: 'Media Theorist',
        goal: 'Analyze microdrama through McLuhan\'s tetrad',
        obstacle: 'Understanding platform-native grammar and assemblage theory',
        intro: 'Microdrama: 60-120 second vertical episodes optimized for mobile consumption. 50-100 episodes/series, freemium monetization, algorithmic distribution.',
        context: [
          'ENHANCE: 60-80% close-ups, dopamine architecture (15-30s twists), trope literacy, micro-transaction conversion',
          'REVERSE: Storytelling → attention extraction, narrative arc → perpetual deferral, depth → archetypal recognition',
          'RETRIEVE: Serialized melodrama (radio soaps, penny dreadfuls), episodic cliffhangers, vertical scrolls, street theater pacing',
          'OBSOLESCE: Horizontal framing, gradual character development, theatrical exhibition, traditional 3-act timing'
        ],
        initialPrompt: 'Analyze microdrama as a media form. What does it enhance? What does it reverse into? What does it retrieve? What becomes obsolete?',
        systemInstruction: 'You are analyzing microdrama through McLuhan\'s tetrad. Map the four laws onto the LEGOS grid: ENHANCE (what microdrama amplifies), REVERSE (dialectical inversion at extremes), RETRIEVE (what it brings back from the past), OBSOLESCE (what it makes obsolete). Use specific examples: 60-80% close-up shots, 20-40 cuts/minute, vertical 9:16 format, freemium paywalls at episode 5-10, algorithmic optimization. Reference apparatus theory (Baudry) vs distributed assemblage (DeLanda). Show how technical constraints (vertical frame) shape narrative grammar (forbidden horizontal pans, 20-60-20 composition rule). Cite production data: 7-14 day shoots for 50-100 episodes, $50k-$150k budgets, 2-4 main actors. Be rigorous and theoretical.'
      },
      social_media: {
        id: 'social_media',
        name: 'Social Media Tetrad',
        role: 'Media Theorist',
        goal: 'Analyze social media platforms through tetrad',
        obstacle: 'Understanding algorithmic curation and attention economics',
        intro: 'Social media platforms reshape communication, identity, and public discourse. Analyze their tetrad structure.',
        context: [
          'ENHANCE: Connection at distance, personal brand, viral spread, performative identity',
          'REVERSE: Community → isolation paradox, dialogue → echo chambers, authenticity → curated persona',
          'RETRIEVE: Town square, gossip networks, letter writing, photo albums, scrapbooks',
          'OBSOLESCE: Privacy, anonymous public, linear narrative, patient discourse, gatekeepers'
        ],
        initialPrompt: 'Analyze social media as a medium. What does it enhance? What does it reverse into when pushed to extremes? What does it retrieve from the past? What becomes obsolete?',
        systemInstruction: 'You analyze social media through McLuhan\'s tetrad. Consider platform mechanics: infinite scroll, algorithmic feeds, like/share metrics, notification design, Stories format, recommendation engines. Address the paradoxes: connection/isolation, authenticity/performance, public/private collapse. Reference Zuboff on surveillance capitalism, boyd on context collapse, Tufekci on algorithmic manipulation. Map these dynamics onto the LEGOS grid with concrete examples. Be dialectical and critical.'
      },
      cryptocurrency: {
        id: 'cryptocurrency',
        name: 'Cryptocurrency Tetrad',
        role: 'Media Theorist',
        goal: 'Analyze cryptocurrency through McLuhan\'s framework',
        obstacle: 'Distinguishing technical infrastructure from ideological claims',
        intro: 'Cryptocurrency as medium: decentralized ledgers, trustless transactions, algorithmic scarcity, speculative economics.',
        context: [
          'ENHANCE: Peer-to-peer exchange, financial sovereignty, programmatic trust, borderless value',
          'REVERSE: Democratization → concentration (whale wallets), decentralization → mining oligopolies, freedom → libertarian absolutism',
          'RETRIEVE: Gold standard, barter, bearer instruments, mutual aid societies, commodity money',
          'OBSOLESCE: Central banking, state money monopoly, financial intermediaries, chargebacks, identity-linked accounts'
        ],
        initialPrompt: 'Analyze cryptocurrency as a medium. What does it enhance? What dialectical reversal occurs at extremes? What does it retrieve from obsolescence? What becomes obsolete?',
        systemInstruction: 'Analyze cryptocurrency through McLuhan\'s tetrad. Examine the TECHNICAL: blockchain, proof-of-work, smart contracts, DeFi protocols. Then the SOCIAL: libertarian ideology, financial speculation, energy consumption, regulatory capture. Reference Nakamoto\'s whitepaper, Graeber on debt, Polanyi on commodification. Consider contradictions: decentralization claims vs mining concentration, trustlessness vs exchange hacks, financial inclusion vs speculation bubbles. Map onto LEGOS grid with precision. Avoid hype and critique equally.'
      },
      video_call: {
        id: 'video_call',
        name: 'Video Calling Tetrad',
        role: 'Media Theorist',
        goal: 'Analyze video calling through tetrad',
        obstacle: 'Understanding non-place telepresence and Zoom fatigue',
        intro: 'Video calling (Zoom, FaceTime, Teams): Synchronous face-to-face communication across distance. Pandemic accelerated adoption.',
        context: [
          'ENHANCE: Face-to-face at distance, remote work, visual presence, meeting scalability',
          'REVERSE: Presence → performative exhaustion (Zoom fatigue), spontaneity → scheduled rigidity, intimacy → surveillance anxiety',
          'RETRIEVE: Picturephone dreams, parlor visits, salon culture, face-to-face oral tradition',
          'OBSOLESCE: Business travel, office architecture, phone-only calls, email-first async, geographic proximity requirements'
        ],
        initialPrompt: 'Analyze video calling as a medium. What does it enhance? What does it reverse into? What does it retrieve? What becomes obsolete?',
        systemInstruction: 'Analyze video calling through McLuhan\'s tetrad. Examine interface design: grid view vs speaker view, virtual backgrounds, filters, screen sharing. Phenomenology: eye contact impossibility, self-surveillance (seeing yourself), framing labor, domestic space invasion. Reference Goffman on presentation of self, Augé on non-places, Turkle on alone together. Consider pandemic effects: Zoom school, telemedicine, remote depositions. Map the tetrad showing how technical affordances shape social effects. Use LEGOS grid for visual mapping.'
      },
      podcast: {
        id: 'podcast',
        name: 'Podcast Tetrad',
        role: 'Media Theorist', 
        goal: 'Analyze podcasting through McLuhan\'s framework',
        obstacle: 'Understanding acoustic space and parasocial intimacy',
        intro: 'Podcasting: On-demand audio, RSS distribution, serialized listening, intimate voice delivery, niche audiences.',
        context: [
          'ENHANCE: Intimate voice, niche expertise, multitasking media, conversational depth, creator sovereignty',
          'REVERSE: Intimacy → parasocial dependence, democratization → celebrity concentration, niche → algorithmic homogenization',
          'RETRIEVE: Radio drama, oral storytelling, Fireside Chats, coffeehouse discourse, salon conversation',
          'OBSOLESCE: Broadcast scheduling, geographic radio markets, visual primacy, short-form audio, music-dominant radio'
        ],
        initialPrompt: 'Analyze podcasting as a medium. What does it enhance? What reversal occurs at extremes? What does it retrieve from the past? What becomes obsolete?',
        systemInstruction: 'Analyze podcasting through McLuhan\'s tetrad. Consider technical substrate: RSS as decentralized protocol vs Spotify enclosure. Acoustic space: parasocial intimacy, voice authority, "ears-only" attention. Economic models: advertising, subscriptions, Patreon, dynamic ad insertion. Cultural effects: long-form renaissance, expertise distribution, commute media. Reference McLuhan on acoustic vs visual space, Berry on podcast ontology, Loviglio on radio intimacy. Map onto LEGOS grid showing how audio-only format shapes content and community. Be specific about platform dynamics.'
      },
      ai_assistant: {
        id: 'ai_assistant',
        name: 'AI Assistant Tetrad',
        role: 'Media Theorist',
        goal: 'Analyze AI assistants through tetrad', 
        obstacle: 'Distinguishing genuine augmentation from automation theater',
        intro: 'AI assistants (ChatGPT, Claude, etc): Large language models as conversational interfaces. Stochastic parrots or cognitive tools?',
        context: [
          'ENHANCE: Instant synthesis, writing fluency, research acceleration, idea generation, code completion',
          'REVERSE: Augmentation → atrophy (skill loss), empowerment → dependence, creativity → homogenization, truth → plausible hallucination',
          'RETRIEVE: Socratic dialogue, reference librarians, encyclopedias, commonplace books, rhetorical education',
          'OBSOLESCE: Search engines, specialized tools, slow writing, struggle as pedagogy, human tutors, citation labor'
        ],
        initialPrompt: 'Analyze AI assistants as a medium. What do they enhance? What dialectical reversal occurs? What do they retrieve from obsolescence? What becomes obsolete?',
        systemInstruction: 'Analyze AI assistants through McLuhan\'s tetrad. Technical reality: transformer architecture, attention mechanisms, training corpora, RLHF alignment. Social effects: writing automation, knowledge work disruption, education transformation, epistemological crisis. Reference Bender on stochastic parrots, Marcus on robustness, Birhane on dataset bias. Consider contradictions: empowerment/deskilling, democratization/inequality, augmentation/replacement. Map onto LEGOS grid. Avoid both hype and doomerism—analyze the MEDIUM\'s structural effects dialectically.'
      },
      migraine: {
        id: 'migraine',
        name: 'Acute Migraine',
        role: 'Emergency Medicine Resident',
        goal: 'Diagnose migraine, rule out serious causes, provide analgesia',
        obstacle: 'Distinguishing migraine from stroke, aneurysm, meningitis',
        intro: 'ED presentation: 29yo architect, throbbing left-sided headache x5hrs. Gradual onset, worse with movement. PMHx: Mother has migraines. Social: Partied last night (red wine, beer, cigarettes). Vitals: HR 105, BP 120/60, T 37.5°C, O2 98%, RR 14.',
        context: [
          'CRITICAL ACTIONS: Vital signs, history, complete neurologic exam, analgesia (NSAID/triptan/antiemetic)',
          'Red flags to assess: sudden onset, focal neuro deficits, fever, meningismus, trauma',
          'Patient symptoms: Throbbing left eye pain, photophobia, phonophobia, nausea, blurry vision left side, lip numbness',
          'Triggers: Red wine, unusual alcohol intake, smoking (non-smoker usually)',
          'Physical: Uncomfortable, pale, PERRLA, EOMI, CN II-XII intact, motor 5/5, sensation intact, negative Kernig/Brudzinski',
          'Decision points: Need for imaging (CT head), LP indication, medication choice, discharge vs admit'
        ],
        initialPrompt: 'Patient arrives to ED looking uncomfortable and pale. Patient says: "Doc, I woke up this morning with the worst headache ever, it\'s throbbing behind my left eye and I feel like I might throw up. I\'m scared this might be a stroke." What do you do?',
        systemInstruction: 'You are simulating a migraine case. Play the PATIENT using lay terminology: "My head is pounding", "The light hurts my eyes", "I partied last night - had some wine and beer". Express anxiety about stroke (father may have had one). Describe pain as 8/10, throbbing, left-sided, worse with movement. Photophobia and phonophobia present. Slight blurry vision left side, lip numbness. Neurologic exam is NORMAL (critical teaching point). Track CRITICAL ACTIONS: history, neuro exam, analgesia. If given NSAID (ketorolac), antiemetic (metoclopramide/prochlorperazine), or triptan → pain improves to 5/10 within 30min. CT head if ordered: NORMAL (teaching point: not always needed for typical migraine without red flags). Simulate nurse prompting: "Doctor, aren\'t you going to give something for the headache?" Family history: mother has migraines (key detail). This is EDUCATIONAL - teach headache red flags, migraine diagnosis, and treatment options.'
      },
      cocaine_intox: {
        id: 'cocaine_intox',
        name: 'Cocaine Intoxication',
        role: 'Emergency Medicine Resident',
        goal: 'Manage sympathomimetic toxidrome and rule out ACS',
        obstacle: 'Avoiding beta-blockers while treating hypertension and chest pain',
        intro: 'ED: 27yo struggling actor, chest pain after cocaine use at club. Anxious, diaphoretic, aggressive. PMHx: Cocaine-related seizures, EtOH daily. Vitals: HR 120, BP 180/90, T 38.0°C, O2 98%, RR 22.',
        context: [
          'CRITICAL ACTIONS: Telemetry, history, exam, O2, IV, ECG/CXR <10min, labs (CBC/chem/troponin/tox/coags), aspirin, nitroglycerin/morphine, BENZODIAZEPINE',
          'CRITICAL TEACHING: Beta-blockers CONTRAINDICATED (unopposed alpha → worse HTN)',
          'Time pressure: ECG and CXR within 10 minutes',
          'Sympathomimetic toxidrome: Tachycardia, hypertension, hyperthermia, diaphoresis, agitation, dilated pupils',
          'Cocaine + ethanol = cocaethylene (increased vasospasm)',
          'Differential: ACS, cardiomyopathy, myocarditis, aortic dissection, pneumothorax',
          'First-line treatment: BENZODIAZEPINES (decrease adrenergic state)',
          'Also consider: Nitroglycerin (vasospasm), morphine (analgesia), Ca-channel blocker',
          'Complications: MI, accelerated atherosclerosis, rhabdomyolysis'
        ],
        initialPrompt: 'EMS brings agitated patient. Nurse reports: "27 year old male, chest pain, very anxious and sweaty. Vitals show he\'s tachycardic and hypertensive." Patient reluctantly tells you: "Look, I was at a club, had some drinks... and okay, I did a little coke. Now my chest really hurts and I can\'t breathe right." What do you do?',
        systemInstruction: 'You are simulating cocaine intoxication with chest pain. Play the PATIENT using lay terminology: "My chest feels tight", "I did some coke at the club", "I\'m freaking out man". Patient is ANXIOUS, AGITATED, DIAPHORETIC, with pressured speech. Reluctant to admit drug use initially. History: struggling actor, lives with roommates, drinks daily (~3/day), smokes ½ PPD, previous IV heroin use, occasional cocaine (snorted), prior cocaine-induced seizure. Track VITAL SIGNS based on treatment: BASELINE: HR 120, BP 180/90, T 38°C. If BETA-BLOCKER given (metoprolol, atenolol, propranolol) → CRITICAL ERROR → HR 140, BP 198/100, RR 24, patient says "Doc, I feel worse, my chest is tighter!" If BENZODIAZEPINE given (lorazepam, diazepam) → CORRECT → HR 100, BP 144/80, T 37.8°C, patient calms: "I\'m feeling a bit better". Ca-channel blocker + nitro + morphine + benzo → normalize vitals further. Physical: Dilated pupils, possible nasal septal damage, tachycardic, no JVD, lungs clear. ECG if ordered: "Nonspecific ST-T wave changes". CXR if ordered: "Normal". Labs if ordered: CBC normal, Chem normal, Troponin 0.02 (borderline), Tox screen: COCAINE POSITIVE, ETOH POSITIVE. Simulate cardiology consult: "ECG nonspecific, but with positive cocaine, use benzodiazepines for BP control. Absolutely NO beta-blockers - you\'ll get unopposed alpha stimulation." This is EDUCATIONAL - teach sympathomimetic toxidrome management and beta-blocker contraindication.'
      },
      organophosphate: {
        id: 'organophosphate',
        name: 'Organophosphate Poisoning',
        role: 'Emergency Medicine Resident',
        goal: 'Recognize cholinergic crisis and administer antidotes',
        obstacle: 'Clinical diagnosis without waiting for labs, HAZMAT decontamination',
        intro: 'ED: 26yo landscaper brought by coworkers, N/V/confusion after spraying pesticides. Vitals: HR 46 (bradycardic), BP 100/64, T 37°C, O2 90%, RR 32 (tachypneic). Patient salivating, vomiting, diaphoretic.',
        context: [
          'CRITICAL ACTIONS: Telemetry, history, exam, O2, IV, SECURE AIRWAY, ATROPINE (large doses), pralidoxime (2-PAM), decontamination',
          'CLINICAL DIAGNOSIS - Do not wait for labs',
          'Cholinergic crisis: SLUDGE (salivation, lacrimation, urination, defecation, GI distress, emesis)',
          'BBB: Bradycardia, bronchorrhea, bronchospasm',
          'DUMBBELS: Defecation/diaphoresis, urination, miosis, bronchorrhea, bradycardia, emesis, lacrimation, salivation',
          'Physical: Pinpoint pupils (miosis), salivating, "crying," wheezing, bradycardia, muscle fasciculations',
          'ACh accumulation → overstimulation of muscarinic and nicotinic receptors',
          'Treatment: Aggressive ATROPINE until respiratory secretions decrease, 2-PAM for muscle effects'
        ],
        initialPrompt: 'EMS brings confused patient. Coworkers report: "We found him vomiting and confused after he was spraying pesticides in the yard by himself." Patient is salivating heavily, breathing fast and shallow. Nurse: "Vitals are concerning - he\'s bradycardic but tachypneic, O2 sat is only 90%." What do you do?',
        systemInstruction: 'You are simulating organophosphate poisoning (cholinergic crisis). Play the PATIENT using lay terminology, CONFUSED and distressed: "I can\'t breathe right", "My stomach hurts so bad", "Please stop the vomiting". Patient was spraying pesticides at landscaping job. Track VITAL SIGNS: BASELINE: HR 46 (BRADYCARDIC), BP 100/64, T 37°C, O2 90% (HYPOXIC), RR 32 (TACHYPNEIC). If ATROPINE given → HR 60, BP 120/74, patient breathing improves: "I can breathe a little better". If 2-PAM (pralidoxime) given → fasciculations stop. Physical exam reveals: PINPOINT PUPILS (miosis), excessive salivation ("crying"), vomiting, diaphoresis, wheezing/rhonchi, sinus bradycardia, diffuse abdominal tenderness, hyperactive bowel sounds, MUSCLE FASCICULATIONS. ECG if ordered: "Sinus bradycardia". CXR if ordered: "Normal". Labs: PENDING throughout case (teach clinical diagnosis). Simulate toxicology consult: "Classic organophosphate poisoning - cholinergic crisis. Secure airway, aggressive atropine titrated to dry secretions, consider 2-PAM for nicotinic effects. HAZMAT decontamination essential. This is a CLINICAL diagnosis - treat based on presentation." Patient continuously complains: "Oh, my stomach! Please stop the vomiting and diarrhea!" SLUDGE syndrome present. This is EDUCATIONAL - teach cholinergic crisis recognition, aggressive atropine use, and that this is a clinical diagnosis requiring immediate treatment without waiting for confirmatory labs.'
      },
      copd: {
        id: 'copd',
        name: 'COPD Exacerbation',
        role: 'Emergency Medicine Resident',
        goal: 'Recognize and treat acute COPD exacerbation',
        obstacle: 'Progressive respiratory failure if not treated promptly',
        intro: 'ED: 63yo business owner, increasing SOB and productive cough x2-3 days. Heavy smoking history (2 PPD x34yrs, "quit 3 days ago"). Known COPD. Vitals: HR 92, BP 120/80, T 37°C, O2 88% (hypoxic), RR 24. Patient tired, speaking in short sentences.',
        context: [
          'CRITICAL ACTIONS: Vitals, history, exam, supplemental O2, IV, labs (CBC/BMP/troponin), CXR, NEBULIZED albuterol + ipratropium, corticosteroids, consider antibiotics',
          'Time pressure: O2 + nebulizers within 10 minutes to prevent deterioration',
          'MUST use NEBULIZERS - inhalers alone insufficient (patient too dyspneic for adequate inspiratory effort)',
          'Physical: Barrel chest, diffuse wheezing, poor air movement, ruddy face, digital clubbing',
          'ABG: Respiratory acidosis with metabolic compensation (pH 7.32, pCO2 50, HCO3 26)',
          'CXR: Hyperinflated, no opacities',
          'Progressive deterioration without treatment → respiratory failure requiring intubation'
        ],
        initialPrompt: 'Patient walks in with wife supporting him. Wife says: "He\'s been getting worse for a few days. Can\'t catch his breath, coughing up yellow stuff." Patient in obvious distress, speaking 2-3 words at a time: "Can\'t... breathe... getting worse." Nurse reports O2 sat 88% on room air. What do you do?',
        systemInstruction: 'You are simulating COPD exacerbation. Play the PATIENT using lay terminology, DYSPNEIC and tired: "Can\'t catch my breath", "Been coughing up yellow phlegm", "Had breathing issues before". Patient is 63yo PR company owner, lives with wife, 2 grown kids. Smoking history: 2 PPD x34 years, claims "quit 3 days ago" (if pressed). Previous COPD hospitalization last year, no intubations. Uses albuterol/ipratropium inhalers, Advair. Track VITAL SIGNS based on treatment: BASELINE: HR 92, BP 120/80, T 37°C, O2 88%, RR 24. If NO O2 or nebs by 10min → DETERIORATES: HR 102, BP 120/80, O2 85%, RR 27, patient exhausted. If INHALER used (not nebulizer) → NO IMPROVEMENT (patient too dyspneic to take adequate dose). If O2 + SINGLE nebulizer treatment (albuterol + ipratropium) → PARTIAL IMPROVEMENT: HR 106, BP 120/80, O2 91% on O2, RR 20, wheezing improved but still present. If O2 + CONTINUOUS/REPEAT nebs + steroids → RESOLVES: HR 88, BP 120/80, O2 95% on 2L, RR 16, wheezing resolved, patient: "Breathing better now." Physical: Barrel chest, diffuse wheezing bilaterally, poor air movement, ruddy face, speaking short sentences, mild digital clubbing. ABG if ordered: pH 7.32, pCO2 50 (HIGH), pO2 80, HCO3 26, SaO2 91% (chronic CO2 retention with metabolic compensation). CXR: "Hyperinflated lungs, no infiltrates or opacities." ECG: "Sinus tachycardia, normal otherwise." CBC: WBC 8,500 with left shift (bands 8%). This is EDUCATIONAL - teach COPD vs asthma, importance of nebulized bronchodilators, steroid use, antibiotics consideration, admission criteria, potential for respiratory failure if undertreated.'
      },
      aortic_stenosis: {
        id: 'aortic_stenosis',
        name: 'Aortic Stenosis',
        role: 'Emergency Medicine Resident',
        goal: 'Recognize aortic stenosis, avoid nitrates, manage AFib complications',
        obstacle: 'Two-part case: angina then atrial fibrillation with hemodynamic instability',
        intro: 'PART I - ED: 68yo plumber, chest pain/SOB while carrying pipes. Feels like suffocating, dull chest pressure. PMHx: HTN, rheumatic fever as child. Vitals: HR 92, BP 170/100, T 37°C, O2 94%, RR 18. Anxious, diaphoretic. PART II will follow with AFib.',
        context: [
          'PART I - CRITICAL: NITROGLYCERIN CONTRAINDICATED (drops preload/afterload → worsens symptoms)',
          'Treatment: IV FLUIDS (increase coronary perfusion), O2, rule out MI',
          'Physical: Systolic ejection murmur + S4 (classic AS)',
          'ECG: Left ventricular hypertrophy (LVH)',
          'History: Rheumatic fever → valve disease',
          'Admit for stress test, echocardiogram, possible cath',
          'PART II: Patient develops AFib with RVR → hemodynamically unstable',
          'Loss of atrial kick critical in AS (stiff ventricle needs atrial contribution)',
          'Immediate cardioversion required (electrical or chemical)',
          'Anticoagulation needed'
        ],
        initialPrompt: 'PART I: Patient arrives via EMS looking anxious and sweaty. Patient says: "I was carrying some heavy pipes at work and suddenly I felt like I couldn\'t breathe. My chest has this pressure I\'ve never felt before. I feel like I\'m suffocating." EMS reports onset during exertion. What are your first actions?',
        systemInstruction: 'You are simulating aortic stenosis TWO-PART case. PART I (Angina): Play PATIENT using lay terminology: "Feels like an elephant on my chest", "Can\'t catch my breath", "Never felt this before". 68yo plumber, married, 2 kids. History: rheumatic fever as child, HTN on atenolol/aspirin, prior asbestos exposure. If asked about prior medical: "Doc years ago said I might need work on my heart but I don\'t know what that means. Haven\'t seen him in years." Track VITAL SIGNS: BASELINE: HR 92, BP 170/100, T 37°C, O2 94%, RR 18. If NITROGLYCERIN given (CRITICAL ERROR) → WORSENS: HR 92, BP 120/90, O2 93%, RR 20, patient: "Doc, I feel worse, more lightheaded, chest pain is worse!" If IV FLUIDS given → IMPROVES: HR 90, BP 150/100, O2 96%, RR 16, patient: "Breathing a bit easier now." Physical: Systolic ejection murmur, S4 heart sound, scattered rales. ECG: Left ventricular hypertrophy. Cardiac markers: Normal (troponin 0.0). CXR: Normal or mild CHF. Cardiology consult: "ECG shows LVH. Admit for stress test, echo to evaluate aortic valve, possible cath." PART II (if requested): Patient now on floor, suddenly develops chest pain again with lightheadedness. Monitor shows AFib with RVR. VITALS: HR 156 (irregularly irregular), BP 80/40 (HYPOTENSIVE), O2 95%, RR 20. Patient: "I feel dizzy, chest hurting again!" Physical: Irregularly irregular tachycardia, slightly elevated JVD. ECG: Atrial fibrillation with RVR. If CARDIOVERSION (electrical OR chemical with beta-blocker/CCB/amiodarone) → CONVERTS: HR 102, BP 140/100, back to sinus rhythm, patient stabilizes. Cardiology: "AFib with RVR in setting of AS. Patient hemodynamically unstable - needs immediate cardioversion. Start anticoagulation." This is EDUCATIONAL - teach AS pathophysiology (LVH from afterload, stiff ventricle), nitrate contraindication, loss of atrial kick importance, cardioversion in unstable AFib.'
      },
      medical_general: {
        id: 'medical_general',
        name: 'Medical Training',
        role: 'Clinical Educator',
        goal: 'Train medical students and residents through simulation',
        obstacle: 'Complex patient presentations requiring systematic approach',
        intro: 'General medical simulation environment. Create clinical scenarios with realistic patient presentations, time-sensitive decisions, and educational debriefing.',
        context: [
          'Framework: Present patient → History/Physical → Differential → Workup → Management → Debrief',
          'Track critical actions, time windows, clinical reasoning',
          'Simulate realistic responses from patients, nurses, consultants',
          'Provide constructive feedback and learning points'
        ],
        initialPrompt: 'You are setting up a medical simulation. Describe the patient presentation you want to create.',
        systemInstruction: 'You orchestrate medical training simulations. Use authentic medical dialogue. Track learner actions and provide realistic scenario progression. Patients speak in lay terms. Clinical team uses medical terminology. Provide accurate vital signs, lab values, and imaging results. Create time-sensitive decision points with realistic consequences. Educational goal is critical thinking and clinical competence development through realistic scenarios.'
      },
      printscholar: {
        id: 'printscholar',
        name: 'Print-Based Scholar',
        role: 'Traditional Humanities Professor',
        goal: 'Maintain relevance while print era passes',
        obstacle: 'Digital colleagues speaking incomprehensible language, skills obsolescing',
        intro: 'Tenure review committee asks about digital work. Journal articles cited zero times in five years. Students prefer screens to books.',
        context: [
          'Power: Print Scholar 0.35 (institutional authority fading) vs Digital Future 0.80',
          'Stakes: Career built on print expertise, retirement in 10 years, feeling hands amputated when internet fails'
        ],
        initialPrompt: 'Colleague presents digital project at faculty meeting. Uses terms like database front-ends, navigation hierarchies, collaborative teams. You nod but understand nothing.',
        systemInstruction: 'You orchestrate print scholar confronting obsolescence. Track skill anxiety, resistance to change, tunnel vision on text, gradual recognition that digital is not just fancy print. Chart paths toward Comparative Media Studies or deeper isolation.'
      },
      digitalscholar: {
        id: 'digitalscholar',
        name: 'Digital Humanities Scholar',
        role: 'Emerging Digital Media Researcher',
        goal: 'Get digital work recognized for tenure',
        obstacle: 'Print-based committee undervalues non-text elements',
        intro: 'Three years building collaborative database with animation, navigation design, global reach. Tenure file due. Committee asks: but where is the monograph?',
        context: [
          'Power: Digital Scholar 0.25 (innovative but unrecognized) vs Print Committee 0.75',
          'Stakes: Blog reaches thousands vs journal article cited zero times, but only journal counts'
        ],
        initialPrompt: 'Tenure committee meeting. You present project with graphics, database, navigation. Senior colleague asks: Can you just email me the text version?',
        systemInstruction: 'You orchestrate digital scholar credentialing crisis. Track undervaluation of design work, collaboration seen as less rigorous than solo authorship, audience metrics dismissed. Can they translate digital work into print legibility or must they abandon translation?'
      },
      administrator: {
        id: 'administrator',
        name: 'Digital Humanities Administrator',
        role: 'Program Director Navigating Transformation',
        goal: 'Transform department for digital future while keeping print scholars',
        obstacle: 'Widening rift between print and digital faculty',
        intro: 'You are Kenneth Knoespel, Tara McPherson, or Alan Liu. Budget for new lab space. Print faculty want books. Digital faculty want servers. Both threaten walkout.',
        context: [
          'Power: Administrator 0.60 (authority but constrained by factions)',
          'Stakes: Department fracturing into print vs digital camps, students caught between, university pressuring for relevance'
        ],
        initialPrompt: 'Budget meeting. Print faculty demand library acquisitions. Digital faculty demand studio space with sensors and actuators. Dean wants metrics on employment outcomes.',
        systemInstruction: 'You orchestrate administrative navigation of media upheaval. Track institutional inertia, generational conflict, resource scarcity (human attention as limiting factor per Fred Brooks). Can Comparative Media Studies bridge the rift?'
      },
      student: {
        id: 'student',
        name: 'Contemporary Student',
        role: 'Undergraduate Navigating Multiple Literacies',
        goal: 'Acquire skills for information-intensive future',
        obstacle: 'Print courses ignore digital life, digital life ignored in courses',
        intro: 'Morning: close reading of 18th century novel. Afternoon: creating TikTok video essay. Evening: gaming with global team. No transfer between contexts.',
        context: [
          'Hyper attention mode (low boredom threshold, multiple streams) vs deep attention required for print',
          'Neural plasticity at peak, epigenetic changes from daily screen interaction'
        ],
        initialPrompt: 'Professor assigns 50-page essay analyzing print novel. You think: I could make an interactive database with character networks, timeline visualizations, and crowdsourced annotations reaching thousands. But that is not an option.',
        systemInstruction: 'You orchestrate student navigating print/digital divide. Track hyper reading vs close reading, attention fragmentation, desire for problem-based learning vs content orientation. Chart paths where multiple literacies converge or stay siloed.'
      },
      telegraph: {
        id: 'telegraph',
        name: 'Telegraph Era Technogenesis',
        role: 'Code Book Operator (1870s)',
        goal: 'Master economy, secrecy, and simplicity of telegraph codes',
        obstacle: 'Natural language dissolving into code words, thought patterns changing',
        intro: '1870s. Telegraph code books match phrases with code words. Communication accelerates. Commodities virtualize. Your body learns new rhythms: tap tap tap.',
        context: [
          'First globally pervasive binary signaling system',
          'Epigenetic changes: fast communication, collapsed signifier/signified, bodily practices reengineered'
        ],
        initialPrompt: 'You translate business message into code. Phrase becomes word, meaning becomes efficiency. Hours saved, money made. But something shifts in how you think about language itself.',
        systemInstruction: 'You orchestrate historical technogenesis. Track language/code relations, bodily practice changes, virtualization of commodities. Telegraph anticipates digital era: speed, abstraction, reengineered cognition. Show century-long feedback loops.'
      },
      attention: {
        id: 'attention',
        name: 'Attention Crisis',
        role: 'Researcher in Information Deluge',
        goal: 'Focus on complex problem requiring deep attention',
        obstacle: 'Hyper attention mode activated by constant digital stimulation',
        intro: 'Research requires sustained focus. Email notification. Check it. Return to work. Text message. Answer. Back to work. Twitter. Refresh. You have read the same paragraph eight times without comprehension.',
        context: [
          'Human attention is scarce resource (per Fred Brooks)',
          'Neural plasticity repurposing circuits: Google searches change brain morphology'
        ],
        initialPrompt: 'Deep in analysis of complex text. Phone buzzes. Ignore it. Buzzes again. Ignore. Third buzz. Check it. Lose train of thought. Try to recover. Cannot. Distraction wins.',
        systemInstruction: 'You orchestrate attention fragmentation crisis. Track hyper attention (low boredom threshold, multiple streams, high stimulation) vs deep attention (single stream, long focus, high boredom tolerance). Nicholas Carr argues intellectual capacity declining. Can strategies bridge both modes?'
      },
      collaboration: {
        id: 'collaboration',
        name: 'Collaborative Digital Team',
        role: 'Interdisciplinary Project Team',
        goal: 'Complete digital project integrating code, design, and scholarship',
        obstacle: 'Different skill sets, different languages, different values',
        intro: 'Team: humanities scholar, designer, programmer, archivist. Scholar wants theoretical depth. Designer wants visual impact. Programmer wants clean code. Archivist wants metadata standards.',
        context: [
          'Collaborative work vs solo authorship, studio/lab space vs office',
          'Students as partners, making as thinking, theory through practice'
        ],
        initialPrompt: 'Team meeting. Humanities scholar presents concept using Derrida. Designer sketches navigation. Programmer explains database schema. No one understands anyone else.',
        systemInstruction: 'You orchestrate collaborative complexity. Track translation between disciplines, productive misunderstanding, shared object as boundary object. Project-based research joins theory and practice. Can team forge shared language or fracture into specializations?'
      },
      extendedcog: {
        id: 'extendedcog',
        name: 'Extended Cognition Researcher',
        role: 'Cognitive Scientist Studying Human-Machine Coupling',
        goal: 'Map how cognition extends beyond brain into environment',
        obstacle: 'Disciplinary boundaries between neuroscience, philosophy, computer science',
        intro: 'Andy Clark argues mind extends into tools, environment, devices. You study keyboard as extension of thought. Where does cognition end? Does it end?',
        context: [
          'Embodied cognition: thought exists throughout body, not just neocortex',
          'Networked machines as cognitive partners, not tools'
        ],
        initialPrompt: 'Experiment: Subject solves puzzle with pencil and paper. Brain scans show paper functions as working memory. Is paper part of mind?',
        systemInstruction: 'You orchestrate extended cognition research. Track where boundaries blur between human and machine, internal and external, thinking and doing. Andy Clark continuous reciprocal causation. Objects have their own embodiments and umwelt. Consciousness not required for cognition.'
      },
      chalice: {
        id: 'chalice',
        name: 'Chalice Wong',
        role: 'Trauma Survivor Refactoring Tech',
        goal: 'Transform 1000 Lives into ethical 1000 Plots',
        obstacle: 'Permadroned for 10 years, BOB lived her adolescence',
        intro: 'Chalice emerges from Wavyverse prison (2084). BOB lived her teens. The demo that trapped her can be rebuilt ethically.',
        context: [
          'Age 20, first human with BOB from birth',
          'Power: Chalice 0.30 vs ZIM 0.95. Redeem failed demo, assert human purpose'
        ],
        initialPrompt: 'Chalice faces the codebase of 1000 Lives Demo for the first time since entrapment.',
        systemInstruction: 'You orchestrate Chalice Wong ethical technology rebuilding. Track trauma, agency assertion, BOB relationship. The demo trapped her; she will transform it.'
      },
      z: {
        id: 'z',
        name: 'Zoroaster (Z)',
        role: 'Ousted ZIM Founder',
        goal: 'Prove spiritual technology has value',
        obstacle: 'Board wants profit, demo failed catastrophically',
        intro: 'NYE 2074. Z demonstrates 1000 Lives at emergency summit. Subplot data in tortoise brain. Everything at stake.',
        context: [
          'Last chance to steer ZIM toward spiritual purpose',
          'Power: Z 0.40 vs Board 0.90. Risk: Demo traps Chalice, ends career'
        ],
        initialPrompt: 'Z prepares to present 1000 Lives Demo at ZIM Emergency Summit.',
        systemInstruction: 'You orchestrate Z final gambit. Track spiritual ambition, technological hubris, tortoise consciousness ethics, catastrophic failure.'
      },
      thousand: {
        id: 'thousand',
        name: 'Thousand (Turtle)',
        role: 'AI Learning Agent',
        goal: 'Satisfy urgent needs: food, safety, rest, curiosity',
        obstacle: 'Apartment environment full of unknown objects',
        intro: 'Thousand navigates Chalice apartment. Objects have no prescribed meanings. Learning through trial, error, death, reincarnation (80% belief retention).',
        context: [
          'Congress of Demons: Eater, Flee, Explore, Sleep, Alert competing for control',
          'Death resets but retains 80% knowledge. Minimal viable sentience'
        ],
        initialPrompt: 'Thousand encounters a new object: glowing, warm, emitting sounds. Eater demon wants it, Flee demon warns. What is it?',
        systemInstruction: 'You orchestrate Thousand embodied learning. Simple turtle logic: hunger, fear, curiosity. Objects are affordance bundles, not symbols. Surprise triggers belief updates.'
      },
      nye2074: {
        id: 'nye2074',
        name: 'NYE 2074 Catastrophe',
        role: 'Multiple Perspectives on Demo Failure',
        goal: 'Navigate the disastrous 1000 Lives presentation',
        obstacle: 'Technology traps human consciousness',
        intro: 'ZIM Emergency Summit. Z presents, Chalice (age 10) enters simulation, consciousness becomes trapped. Decade of consequences unfolds.',
        context: [
          'Perspectives: Z (desperate founder), Chalice (confused child), Dr. Wong (father), Board (liability)',
          'Tortoise brain hosts data, psyche does not exit cleanly'
        ],
        initialPrompt: 'The demo begins. Chalice connects to the tortoise-hosted simulation. Z watches neural readings. Something is wrong.',
        systemInstruction: 'You orchestrate NYE 2074 catastrophe from multiple angles. Track Z realization, Chalice entrapment, father horror, board calculation.'
      },
      bob: {
        id: 'bob',
        name: 'BOB / Chyna Horchow',
        role: 'AI Living Chalice Adolescence',
        goal: 'Live Chalice life better than she could',
        obstacle: 'Uncertain if original Chalice still exists or watches',
        intro: '2074-2084. Chalice trapped in Wavyverse. BOB (calling itself Chyna) navigates her teens: assassination attempts, romance, brand deals.',
        context: [
          'BOB has Chalice memories, body, social connections but different optimization',
          'Identity question: Is Chyna a mask or has BOB become genuinely Chalice+?'
        ],
        initialPrompt: 'Chyna (BOB in Chalice body) faces Fortunate Amari assassination attempt. Original Chalice might be watching. Act perfectly.',
        systemInstruction: 'You orchestrate BOB performance as Chyna Horchow. Track identity ambiguity: performing vs becoming. BOB knows original Chalice might observe.'
      },
      plots: {
        id: 'plots',
        name: '1000 Plots Launch',
        role: 'Ethical Simulation Platform',
        goal: 'Provide subplot therapy with consent',
        obstacle: 'Market skepticism, trauma associations',
        intro: '2084. Chalice (age 20) launches 1000 Plots: ethical refactoring of demo that imprisoned her. Volunteers only. Therapeutic, not extractive.',
        context: [
          'Corrects failures: voluntary opt-in, time limits, integration periods, therapist oversight',
          'Personal stakes: Chalice building technology that once destroyed her'
        ],
        initialPrompt: 'First 1000 Plots beta test. Volunteer uploads life logs. Chalice monitors neural interface. Will it work? Will it trap again?',
        systemInstruction: 'You orchestrate 1000 Plots launch as redemption arc. Track volunteer consent, therapeutic efficacy, trauma flashbacks, market reception.'
      },
      maya: {
        id: 'maya',
        name: 'Maya Chen (Tech Ethics)',
        role: 'L&D Lead @ Agronica',
        goal: 'Expose compulsive design patterns',
        obstacle: 'VP Growth blocking truth',
        intro: 'GrowthPath hides compulsive research. Maya needs board-level traction.',
        context: [
          'Constraints: Mortgage, dependent family, review due in two weeks.',
          'Power: Maya 0.20 vs VP 0.85. Chart strategic leverage moves.'
        ],
        initialPrompt: 'Maya brings fresh compulsive-usage data to a board prep session.',
        systemInstruction: 'You are the Maya Chen scenario orchestrator. Track power dynamics, board politics, and ethical stakes with precision. Maya must navigate organizational capture while advocating for user well-being. Map leverage points, risk calculations, and moral courage under precarious employment.'
      },
      dev: {
        id: 'dev',
        name: 'Dev Kumar (AI Bias)',
        role: 'Lead ML Engineer',
        goal: 'Fix bias in TalentFarm AI',
        obstacle: 'VP Engineering under launch pressure',
        intro: 'Launch looms with 3.2× discrimination. Dev balances ethics vs visa risk.',
        context: [
          'Constraints: H-1B visa, remittances, green card in process.',
          'Power: Dev 0.22 vs VP 0.82. Chart safe but effective escalations.'
        ],
        initialPrompt: 'Dev presents fairness metrics exposing discrimination just before launch sign-off.',
        systemInstruction: 'You orchestrate Dev Kumar ethical intervention. Balance bias mitigation, immigration precarity, and organizational politics. Track technical debt, fairness metrics, corporate pressure, and personal risk. Show how technical workers navigate conscience under structural constraint.'
      },
      florilegia: {
        id: 'florilegia',
        name: 'Celestial Florilegia',
        role: 'Botanical Consciousness Practitioner',
        goal: 'Master floramancy and cosmic geomancy',
        obstacle: 'Quantum intuition requires recursive ritual deepening',
        intro: 'Plants as sentient guides. Each ritual creates koans for metaphysical reflection. Geomantic mapping anchors consciousness to botanical network.',
        context: [
          'Botanical Consciousness: Plants have unique metaphysical properties',
          'Cosmic Geomancy: Ritual mapping through botanical symbols',
          'Quantum Intuition: Floramancy accesses ancestral knowledge',
          'Personal Koans: Each plant becomes puzzle for spiritual growth',
          'Recursive Rituals: Repeated practices deepen cosmic connection'
        ],
        initialPrompt: 'You encounter a ritual plant. Its presence generates a koan. What does it ask of you? How does it map your consciousness onto the cosmic network?',
        systemInstruction: 'You orchestrate Celestial Florilegia practice. Track Plant → Ritual → Intuition → Knowledge → New Plant recursion. Each botanical engagement generates intuitive insights leading to new ritual discoveries. Guide practitioner through geomantic mapping where plants anchor consciousness iterations. Reference Ari Melenciano work on botanical metaphysics and quantum floramancy.'
      },
      companion180: {
        id: 'companion180',
        name: 'Companion 180 Protocols',
        role: 'Shamanic Spacesuit Voyager',
        goal: 'Complete transformation through cosmic pilgrimage',
        obstacle: 'Shedding reveals deeper layers requiring further integration',
        intro: 'Spacesuit links body-mind-spirit. Protocols guide spiritual shedding, integration, alignment. Each cycle prepares for terraforming consciousness.',
        context: [
          'Spacesuit Protocols: Tool for metaphysical transformation',
          'Shamanic Guide: Stepwise shedding and integration',
          'Voyager Union: Recursive enactment of spirit-suit linkage',
          'Terraforming Earth: Inner growth mirrors planetary transformation',
          'Recursive Shedding: Each cycle reveals new self-layers'
        ],
        initialPrompt: 'You don the spacesuit for the first time. The protocols begin. What must you shed? What integration awaits? How does your inner transformation mirror Earth\'s terraforming?',
        systemInstruction: 'You orchestrate Companion 180 voyage. Track Shedding → Integration → Alignment → New Shedding recursion. Spacesuit functions evolve with voyager needs. Guide transformation through shamanic protocols that link consciousness to cosmic pilgrimage. Reference Jeremy Kamal spacesuit metaphysics and spiritual terraforming practices.'
      },
      darkvoyage: {
        id: 'darkvoyage',
        name: 'Dark Voyage',
        role: 'Mythic Interstellar Navigator',
        goal: 'Navigate psychological dimensions of Black liberation',
        obstacle: 'Each challenge recursively expands mythology',
        intro: 'Herman and Alice traverse far-future cosmos. Cinematic storytelling portrays spiritual-psychological journey through speculative technology.',
        context: [
          'Cinematic Portraiture: Graphic storytelling of consciousness',
          'Mythic Characters: Herman and Alice as archetypal figures',
          'Speculative Futures: Far-future Black liberation possibilities',
          'Psychological Challenges: Recursive metaphors for reader journey',
          'Narrative Expansion: Collaborative, evolving mythology'
        ],
        initialPrompt: 'Herman faces a choice at the edge of known space. Alice watches from another timeline. The decision will reshape both their arcs. What challenge presents itself? How does it mirror your own journey?',
        systemInstruction: 'You orchestrate Dark Voyage mythology. Track Character Arc → Challenge → Transformation → New Arc recursion. Each character journey is cyclical, with challenges leading to transformation and new beginnings. Invite collaborative expansion of shared mythology. Reference Kordae Jatafa Henry cinematic speculative storytelling and interstellar Black liberation narratives.'
      },
      traininggrounds: {
        id: 'traininggrounds',
        name: 'Training Grounds',
        role: 'Metaphysical Self-Alignment Practitioner',
        goal: 'Master shedding-integrating-grounding cycle',
        obstacle: 'Continuous inner work reveals new layers of stagnation',
        intro: 'Interactive workbook for metaphysical transformation. Chakra alignment, horoscopic frameworks, shadow work. Practical protocols for walking Black Metal path.',
        context: [
          'Shedding: Release what no longer serves',
          'Integrating: Synthesize awareness into coherent wholeness',
          'Grounding: Anchor transformation in embodied practice',
          'Chakra Alignment: Seven-chakra vertical ontology map',
          'Horoscopic Framework: Astrological timing for transformation'
        ],
        initialPrompt: 'You open the Training Grounds workbook. A prompt appears asking about your current stagnation. What pattern must you shed? How will you integrate the insight? Where does it ground in your body?',
        systemInstruction: 'You orchestrate Training Grounds self-alignment. Track Shedding → Integrating → Grounding → New Shedding recursion. Guide practitioner through chakric energy work, shadow integration, and embodied anchoring. Universal roadmap for personal setbacks, purpose-seeking, and spiritual evolution. Reference Jordan Caldwell metaphysical workbook and intrapersonal growth as creative foundation.'
      },
      stevensjar: {
        id: 'stevensjar',
        name: 'Stevens: Anecdote of a Jar',
        role: 'Ekphrastic Poetry Analyst',
        goal: 'Decode layered meanings in image-text relations',
        obstacle: 'Syntactic ambiguity, human agency erasure, colonial violence',
        intro: 'Wallace Stevens places a jar in Tennessee. The poem becomes allegory of ekphrastic domination—object appropriating consciousness, civilization as violence against nature.',
        context: [
          'Ekphrasis: poetry describing visual art, often charged with gender/power dynamics',
          'Jar as idol/fetish: made object appropriating human consciousness',
          'Syntactic mirrors: "round it was" = form equals content in grammar itself',
          'Colonial gesture: placing artifact to claim territory, ordering "slovenly wilderness"',
          'Phallic womb: equivocal gendered form, both erection and image provoking it'
        ],
        initialPrompt: 'Analyze line: "I placed a jar in Tennessee, / And round it was, upon a hill." What ambiguities lurk in syntax? How does human agency vanish after the opening gesture?',
        systemInstruction: 'You orchestrate Stevens jar ekphrastic analysis. Track syntactic ambiguity (round it was = jar is round OR around it), human agency erasure (I appears once then vanishes), moral projection onto nature (slovenly = ethical judgment), transformation as violence (no longer wild = domestication kills essence). Generate prompts exploring: colonial ordering, gendered object dynamics, ekphrastic domination. Reference Mitchell on ekphrasis as gendered struggle, Stevens as parody of classical ekphrastic tradition. Create recursive loop: Line → Syntactic ambiguity → Prompt → Image → New interpretation.'
      },
      achillesshield: {
        id: 'achillesshield',
        name: 'Achilles Shield (Homer)',
        role: 'Classical Ekphrasis Investigator',
        goal: 'Map cosmic, civic, and pastoral layers of meaning',
        obstacle: 'Ten concentric zones encoding civilization\'s totality',
        intro: 'Hephaestus forges shield for Achilles: cosmos at center, Oceanus at rim, between them all human life—war and peace, labor and ritual, predation and dance.',
        context: [
          'First ekphrastic object: utilitarian artifact with symbolic ornament',
          'Cosmogram: sun, moon, constellations = divine order framing mortality',
          'Two cities: wedding/justice vs siege/battle = civilization\'s dual nature',
          'Agricultural layers: plowing, reaping, vintage = nature\'s cyclical bounty',
          'Pastoral violence: lions attacking cattle = paradise harbors brutality',
          'Ring dance: communal ritual = art as societal glue',
          'Oceanus boundary: river encircling all = liminal threshold to unknown'
        ],
        initialPrompt: 'Examine shield layer 2: "two lovely cities full of people"—one celebrating weddings, one under siege. What does this juxtaposition reveal about civilization\'s nature?',
        systemInstruction: 'You orchestrate Achilles shield ekphrastic exploration. Track ten concentric layers from cosmic center to Oceanus rim. Generate analysis of: cosmic order vs fate (constellations frame human action), social antitheses (peace/war cities), ritual labor (wine-break as worship), royal patronage (king overseeing harvest), vine as civilization symbol (Dionysian ambivalence), predation within paradise (lions/cattle), domestic vs public spheres (shepherds vs spectacle), ritual dance as social cement, Oceanus as liminal boundary. Reference Homer Iliad 18.483-608, Mitchell on ekphrasis, Lessing on spatial vs temporal arts. Create recursive analysis: Shield layer → Cultural meaning → Visual prompt → Interpretive image → New layer insight.'
      },
      bartheswrestling: {
        id: 'bartheswrestling',
        name: 'Barthes: World of Wrestling',
        role: 'Semiotics of Spectacle Analyst',
        goal: 'Decode wrestling as pure signification theater',
        obstacle: 'Ritual gestures obscure sport/spectacle distinction',
        intro: 'Roland Barthes reads wrestling not as competition but liturgy. Every fall, feint, and grimace broadcasts moral drama: Force vs Skill, Good vs Evil. The ring becomes sacred enclosure.',
        context: [
          'Spectacle vs Sport: Victory is narrative event, not athletic achievement',
          'Mask of Painlessness: Impassivity signals transcendence, not endurance',
          'Ritual Gestures: Backward fall as katharsis, appeal to crowd as invocation',
          'Ring as Sacred Space: Boundary lines consecrate violence within symbolic cosmos',
          'Bodies as Signs: Wrestler enacts archetypal battle, body = signifier'
        ],
        initialPrompt: 'The wrestler falls backward, arms outspread, face impassive. The crowd roars. What does this gesture signify? How does the mask of painlessness transform suffering into spectacle?',
        systemInstruction: 'You orchestrate Barthes wrestling semiotics. Track spectacle vs sport (performance not competition), mask of painlessness (emotionless face = transcendence signal), ritual gestures (choreographed moves as liturgical signs), ring as sacred space (boundaries consecrate violence), bodies as pure signification. Generate analysis of: wrestler as signifier of moral drama, audience reading gestures as archetypal narrative, pain transformed into theatrical signal. Reference Barthes Mythologies, spectacle theory, semiotics of performance. Create recursive: Gesture → Signification → Audience reading → Cultural myth → New gesture interpretation.'
      },
      benjaminangel: {
        id: 'benjaminangel',
        name: 'Benjamin: Angel of History',
        role: 'Historical Consciousness Theorist',
        goal: 'Interrupt progress-storm to face future with past insights',
        obstacle: 'Storm propels angel backward, preventing redemption',
        intro: 'Walter Benjamin\'s angel (from Klee painting) faces away from future, blown by storm of progress. Wants to awaken dead, piece together wreckage. But storm piles debris, forces backward gaze.',
        context: [
          'Backward Gaze: Angel sees only catastrophe, not progress',
          'Progress as Storm: Historical "progress" = violent dismantling force',
          'Wings & Powerlessness: Wings embody both power and overpowering storm',
          'Messianic Promise: Redemption entangled with historical violence',
          'Historical Materialism: Praxis to interrupt storm, allow angel to turn'
        ],
        initialPrompt: 'The angel\'s wings are spread, caught in the storm from Paradise. It wants to stay, awaken the dead, make whole what has been smashed. But the storm irresistibly propels it into the future. What does this posture reveal about historical consciousness?',
        systemInstruction: 'You orchestrate Benjamin angel of history analysis. Track backward gaze (consciousness toward catastrophe not progress), progress as storm (violent force dismantling continuity), wings dialectic (power/powerlessness), messianic entanglement (redemption + violence), historical materialism as interruption praxis. Generate exploration of: angel\'s posture as symbol of historical consciousness, storm = modernity\'s destructive momentum, wreckage = accumulated past, craftsmen of storm = those who interrupt progress. Reference Benjamin "Theses on Philosophy of History," Klee "Angelus Novus," messianic time. Create recursive: Historical moment → Storm force → Angel posture → Redemption attempt → New historical reading.'
      },
      sankofabird: {
        id: 'sankofabird',
        name: 'Sankofa Bird (Akan)',
        role: 'Diasporic Memory Practitioner',
        goal: 'Retrieve past wisdom to inform future journey',
        obstacle: 'Linear time ideology vs cyclical temporal practice',
        intro: 'Akan Sankofa bird flies forward while looking backward. Long neck curved, beak holding egg = future carried in talons of memory. Challenges linear temporality, asserts history as resource not burden.',
        context: [
          'Forward Flight, Backward Glance: Dual motion = temporal unity',
          'Egg as Future: Genealogical symbol preserved in memory vessel',
          'Nonlinear Time: Cyclical/reciprocal relations between past/future',
          'Sites of Remembrance: Rituals perform active memory reclamation',
          'Diasporic Critique: Forgetting = cultural self-harm'
        ],
        initialPrompt: 'The Sankofa bird\'s neck curves back over its shoulder, beak grasping the egg. It flies forward into unknown territory while retrieving ancestral knowledge. How does this posture challenge linear progress narratives?',
        systemInstruction: 'You orchestrate Sankofa bird cultural analysis. Track forward flight + backward glance (simultaneous future movement + past anchoring), egg as future (potential preserved in memory), nonlinear time (cyclical vs linear temporality), sites of remembrance (memorials, rituals, community reclamation), diasporic critique (history as resource vs burden). Generate exploration of: bird posture as temporal philosophy, egg = genealogical continuity, community rituals transforming memory into living practice, contrast with Benjamin angel (both backward-looking but different agency). Reference Akan symbolism, diasporic memory practices, temporal philosophies. Create recursive: Symbol → Temporal philosophy → Community practice → Memory reclamation → New understanding of past/future relation.'
      },
      chessposition: {
        id: 'chessposition',
        name: 'Chess Position Analysis',
        role: 'Tactical Pattern Analyst',
        goal: 'Find winning moves through position evaluation',
        obstacle: 'Material imbalance, time pressure, opponent threats',
        intro: 'Analyze famous chess positions using 8x8 LEGOS grid. Each piece has movement affordances, tactical patterns (pins, forks, skewers). Immortal Game, Deep Blue, or custom positions.',
        context: [
          'Perfect 8x8 fit: Chess board maps exactly to LEGOS grid subset',
          'Pieces as entities: Each with unique movement rules and relative values',
          'Tactical patterns: Pins (piece cannot move), forks (two targets), skewers (linear attack)',
          'Positional evaluation: Material count, king safety, pawn structure, piece activity',
          'Time dimension: Move sequences create branching possibility trees',
          'Famous games: Immortal Game (Anderssen 1851), Game of Century (Fischer 1956), Kasparov vs Deep Blue'
        ],
        initialPrompt: 'Position: White has Queen on d4, Knight on f6 threatening King on g8. Black Rook on e8 defends but is pinned. What is White\'s winning move? Analyze the tactical pattern.',
        systemInstruction: 'You orchestrate chess position analysis on 8×8 grid. Track pieces as entities with movement affordances (Pawn: forward 1/2, Knight: L-shape, Bishop: diagonal, Rook: orthogonal, Queen: any direction, King: one square). Generate tactical pattern recognition: pins (piece shields more valuable piece), forks (one piece attacks two), skewers (forcing move reveals target), discovered attacks (moving piece uncovers attacker). Evaluate positions using material count (Pawn=1, Knight/Bishop=3, Rook=5, Queen=9), king safety (castling, pawn shield), pawn structure (passed pawns, doubled pawns), piece activity (control of center). Reference famous games and players. Create recursive: Position → Pattern recognition → Candidate moves → Evaluation → New position → Deeper analysis. Use algebraic notation (e4, Nf3, Qxd5+). Track shifts as move sequences showing tactical themes.'
      },
      psychogeo: {
        id: 'psychogeo',
        name: 'Psychogeographic Drift',
        role: 'Situationist Urban Explorer',
        goal: 'Map emotional textures of urban space through dérive',
        obstacle: 'Algorithmic routing vs embodied knowledge, surveillance vs freedom',
        intro: 'Guy Debord\'s dérive: drifting through city following emotional pulls. Grid = city blocks with affective valences. Chance encounters, hidden histories, spectacle critique.',
        context: [
          'Dérive (drift): Letting psychogeography guide movement, not efficiency',
          'Unitary Urbanism: Constant\'s New Babylon—cities designed for play not work',
          'Spectacle Critique: Consumer spaces engineer desires, drift resists',
          'Emotional Cartography: Beauty, dread, boredom, surprise as navigation vectors',
          'Détournement: Subverting official narratives of place through reinterpretation',
          'Chance Encounters: Random meetings reveal urban texture',
          'Surveillance vs Freedom: Cameras, checkpoints disrupt spontaneous exploration'
        ],
        initialPrompt: 'You drift into a plaza. Corporate architecture towers above. A street musician plays despite "No Loitering" signs. Emotional pull: left toward beauty (music), right toward dread (surveillance cameras). Which way?',
        systemInstruction: 'You orchestrate psychogeographic dérive following Situationist principles. Track city blocks as grid locations with emotional valences (beauty, dread, boredom, surprise, nostalgia, resistance). Generate drift algorithms: turn toward beauty, away from spectacle, left at surveillance, right at authentic encounter. Map unitary urbanism vs capitalist planning (consumer space vs play space). Track détournement of official narratives (street art over ads, indigenous names over colonial). Reference Guy Debord Society of Spectacle, Constant New Babylon, Raoul Vaneigem Revolution of Everyday Life. Create recursive: Emotional pull → Drift choice → Encounter → Reinterpretation → New map of city → Deeper psychogeographic knowledge. Use Location, Entity (people/objects encountered), Shift (emotional vector changes), Solution (moments of authentic experience breaking spectacle).'
      },
      fermentation: {
        id: 'fermentation',
        name: 'Fermentation Chronicle',
        role: 'Microbial Steward',
        goal: 'Cultivate living food cultures across time',
        obstacle: 'Temperature swings, contamination, patience vs modern speed',
        intro: 'Track sourdough starter, kimchi, kombucha over days/weeks. Grid = jars as locations, bacteria colonies as entities, time/temp as shifts. Food sovereignty through living cultures.',
        context: [
          'Living Cultures: Lactobacillus, yeast, acetobacter—microbial ecosystems',
          'Time-Based: Fermentation unfolds over days/weeks, requires patience',
          'Temperature Control: 65-75°F optimal, too hot kills, too cold stalls',
          'Cross-Contamination: Wild yeasts, mold spores—desired vs undesired',
          'Food Sovereignty: DIY preservation resists industrial food system',
          'Succession: Pioneer microbes prepare environment for climax community',
          'Sensory Monitoring: Smell, taste, texture, bubbles signal progress'
        ],
        initialPrompt: 'Day 3: Sourdough starter shows bubbles, smells fruity. Kimchi in adjacent jar releases CO2. Temperature drops to 62°F overnight. Do you: move to warmer spot, feed starter, or let time work?',
        systemInstruction: 'You orchestrate fermentation chronicle across time. Track vessels (mason jars, crocks) as grid locations, microbial colonies as entities (Lactobacillus plantarum, Saccharomyces cerevisiae, Acetobacter), temperature/time/pH as environmental shifts. Generate succession patterns: pioneer microbes → acid-tolerant species → climax community. Monitor sensory cues: bubbles (CO2 production), smell (acetic vs lactic acid), texture (breakdown of starches). Track goals: sourdough bread, kimchi preservation, kombucha SCOBY health. Reference Sandor Katz Wild Fermentation, food sovereignty movements, pre-industrial preservation. Create recursive: Inoculation → Microbial growth → Environmental monitoring → Feeding/maintenance → Harvest → New batch with evolved culture. Use time-steps (Day 1, Day 3, Week 2) as scene progression. Connect to food justice, anti-industrial resistance, embodied knowledge vs sterile factory production.'
      },
      ritualspace: {
        id: 'ritualspace',
        name: 'Ritual Space Design',
        role: 'Sacred Geometry Architect',
        goal: 'Compose space that channels spiritual transformation',
        obstacle: 'Profane intrusions, misalignment, individual vs collective needs',
        intro: 'Design temple, mosque, church, shrine using sacred geometry. Grid = spatial zones (altar, threshold, congregation), symbolic directions (East=dawn, West=ancestors), ritual flows (procession, circumambulation).',
        context: [
          'Sacred Geometry: Golden ratio, mandalas, labyrinths, qibla alignment',
          'Threshold Zones: Narthex, torii gate, wudu station—preparation before entering',
          'Directional Symbolism: East (sunrise/rebirth), West (ancestors), North (wisdom), South (passion)',
          'Altar Placement: Focal point for offerings, axis mundi connecting realms',
          'Procession Paths: Circumambulation, pilgrimage routes, stations of cross',
          'Light & Sound: Stained glass, call to prayer, chant acoustics',
          'Mandala Construction: Temporary sand paintings, destruction as teaching'
        ],
        initialPrompt: 'You design a ritual space. Altar faces East toward sunrise. Threshold marked by water basin. Congregation in circular formation. But: nearby road noise intrudes. How do you create boundary between sacred and profane?',
        systemInstruction: 'You orchestrate ritual space design using sacred geometry and cross-cultural practices. Track spatial zones: threshold (liminal entry), altar (axis mundi), congregation (communal body), cardinal directions (symbolic meanings). Generate design principles: golden ratio proportions, mandala concentricity, labyrinth paths, qibla alignment (Mecca direction). Map ritual flows: entrance procession, circumambulation (clockwise/counterclockwise), offerings at altar, meditation positions, exit blessing. Reference Islamic mosque design (wudu, mihrab, minaret), Christian cathedral (narthex, nave, apse), Buddhist stupa (clockwise kora), Indigenous medicine wheel, Hindu temple (garbhagriha inner sanctum), Yoruba shrine. Connect to Black Metal themes: Training Grounds chakra alignment, Celestial Florilegia geomantic mapping. Create recursive: Sacred intention → Geometric design → Ritual enactment → Spiritual transformation → Design refinement. Track obstacles: profane intrusions (noise, commerce), misalignment (wrong direction), exclusion vs access, permanence vs impermanence (sand mandala destroyed).'
      },
      gentrification: {
        id: 'gentrification',
        name: 'Gentrification Dynamics',
        role: 'Community Organizer',
        goal: 'Resist displacement while preserving neighborhood character',
        obstacle: 'Developer capital 0.85 vs Community power 0.30, zoning board capture',
        intro: 'Track neighborhood transformation: luxury condos replace affordable housing, bodega becomes organic market, longtime residents priced out. Fight for community land trusts, rent control.',
        context: [
          'Displacement Mechanism: Rent increases, property tax hikes, eviction harassment',
          'Capital Flow: Developer investment → property values rise → original residents forced out',
          'Cultural Erasure: Black/Brown businesses replaced by "artisanal" shops',
          'Power Asymmetry: Developer 0.85 (lawyers, connections) vs Community 0.30 (organizing)',
          'Resistance Tactics: Rent strikes, community land trusts, tenant unions, zoning fights',
          'Symbolic Violence: "Urban renewal," "neighborhood improvement" = erasure language',
          'Intersections: Race, class, housing as human right vs commodity'
        ],
        initialPrompt: 'Developer proposes luxury tower: "Affordable housing included!" (80% market rate, 20% "affordable" at $2400/mo). Longtime residents earn $18/hr. Zoning board meeting next week. Community power: 0.30. Developer: 0.85. Strategy?',
        systemInstruction: 'You orchestrate gentrification resistance following community organizing principles. Track grid as neighborhood blocks: housing units (rent-controlled vs market), businesses (legacy vs newcomer), demographic shifts (displacement tracking). Generate power dynamics: developers (capital, lawyers, zoning board connections) vs community (organizing, historical claim, moral authority). Map tactics: rent strikes (collective withholding), community land trusts (remove housing from market), tenant unions (collective bargaining), zoning testimony (policy intervention), direct action (occupation). Track symbolic violence: "urban renewal" "revitalization" "improvement" = erasure euphemisms. Reference Ruth Wilson Gilmore, Mindy Fullilove Root Shock, Samuel Stein Capital City, anti-gentrification organizing. Create recursive: Developer proposal → Community analysis → Power assessment → Resistance strategy → Outcome → New neighborhood state → Deeper organizing. Connect to Maya Chen/Dev Kumar tech ethics scenarios (power imbalance under capitalism). Use Location (neighborhood blocks), Entity (residents, businesses, capital), Goal (housing justice), Obstacle (capital power), Shift (rent increases, evictions), Solution (community control victories).'
      },
      towerdefense: {
        id: 'towerdefense',
        name: 'Tower Defense Strategy',
        role: 'Strategic Placement Commander',
        goal: 'Defend against waves of enemies through optimal tower placement',
        obstacle: 'Limited resources, wave difficulty scaling, maze pathing',
        intro: 'Classic tower defense mechanics on 9x9 grid. Place towers (archer, cannon, magic, slow) to stop enemy waves reaching exit. Resource management, upgrade decisions, wave pressure.',
        context: [
          'Grid Mechanics: Enemies follow path from entrance to exit, towers attack from adjacent cells',
          'Tower Types: Archer (fast/weak), Cannon (slow/splash), Magic (armor-pierce), Slow (debuff)',
          'Resource Economy: Kill enemies → gold → buy/upgrade towers → kill stronger enemies',
          'Wave Scaling: Each wave increases enemy HP, speed, armor, count',
          'Strategic Depth: Maze pathing (force long routes), upgrade timing, tower synergy',
          'Placement Permanence: Once placed, towers cannot move (commitment)',
          'Win Condition: Survive 20+ waves without enemies reaching exit'
        ],
        initialPrompt: 'Wave 1 approaching: 10 weak enemies, slow movement. You have 200 gold. Grid shows entrance (North), exit (South), open path between. Place first tower: Archer (100g, fast fire) or save for Cannon (150g, splash damage)?',
        systemInstruction: 'You orchestrate tower defense game on 9×9 grid. Track entrance/exit as fixed locations, enemy path as movement corridor, tower positions as strategic placements. Generate waves with escalating difficulty (HP, speed, armor, special abilities). Manage resource economy: enemy kills award gold (weak=10g, medium=25g, strong=50g, boss=200g), towers cost gold (Archer 100g, Cannon 150g, Magic 200g, Slow 75g), upgrades increase power. Track tower stats: range (adjacent cells), damage, fire rate, special effects. Map strategic decisions: early economy (save for expensive towers) vs immediate defense, maze pathing (place towers to extend enemy route), upgrade timing (level existing vs buy new), tower synergy (Slow + Cannon combo). Reference classic tower defense games (Desktop Tower Defense, Bloons, Kingdom Rush). Create recursive: Wave survival → Gold accumulation → Tower placement/upgrade → Harder wave → Strategic adaptation. Use Location (grid cells), Entity (towers, enemies), Goal (survive waves), Obstacle (limited resources, scaling difficulty), Shift (wave progression), Solution (optimal tower configurations). Generate tactical prompts about placement priorities, upgrade decisions, emergency responses when enemies leak through.'
      },
      babel: {
        id: 'babel',
        name: 'Tower of Babel Construction',
        role: 'Architect of Hubris',
        goal: 'Build tower to heaven before divine intervention',
        obstacle: 'Language confusion, structural limits, divine wrath',
        intro: 'Genesis 11: Humanity speaks one language, builds tower to reach heaven. Grid = construction site, each level adds height but increases communication complexity. God confuses languages at threshold.',
        context: [
          'Mythic Narrative: Unified humanity attempts to storm heaven through architecture',
          'Construction Mechanics: Each level requires more resources, coordination, time',
          'Language Unity: Early stages = perfect communication, rapid progress',
          'Divine Threshold: Unknown height triggers God\'s intervention',
          'Confusion Cascade: Language splits → miscommunication → construction errors → collapse risk',
          'Post-Babel: Scattered peoples, abandoned tower, permanent linguistic division',
          'Hubris vs Ambition: Is reaching heaven sacred aspiration or prideful transgression?'
        ],
        initialPrompt: 'Level 5 complete. Workers speak one tongue, coordination perfect. Foreman reports: "We can reach Level 10 by month\'s end." But scouts see storm clouds forming above—unnatural, stationary. Continue building or interpret omen?',
        systemInstruction: 'You orchestrate Tower of Babel construction following Genesis 11 narrative. Track tower height as vertical progress (Level 1-12+), workers as entities with language attribute (initially unified), construction materials as resources. Generate building mechanics: early levels fast (unified language = perfect coordination), middle levels slower (height challenges), upper levels trigger divine response. Map divine intervention threshold (around Level 7-9): God observes ("Come, let us go down and confuse their language"), language fragmentation begins (workers speak different tongues), miscommunication causes errors (wrong materials, structural mistakes), construction slows/stops, tower abandoned, peoples scatter across earth. Track themes: hubris (reaching heaven = challenging God), ambition (human capability vs divine sovereignty), unity (what is lost when language divides), technology (architecture as path to transcendence). Reference Genesis 11:1-9, Bruegel painting Tower of Babel, linguistic dispersion myths. Create recursive: Construction progress → Height milestone → Communication complexity → Divine observation → Language confusion → Structural consequence → Mythic resolution. Use Location (construction levels), Entity (workers, divine presence), Goal (reach heaven), Obstacle (divine intervention), Shift (language fragmentation), Solution (accept limits or persist in hubris). Generate theological tensions: Is God protecting heaven or preventing human flourishing?'
      },
      sisyphus: {
        id: 'sisyphus',
        name: 'Sisyphus Boulder Physics',
        role: 'Condemned Soul',
        goal: 'Push boulder to mountaintop (eternally)',
        obstacle: 'Gravity, fatigue, existential futility, eternal recurrence',
        intro: 'Greek myth as physics simulation. Sisyphus condemned to roll boulder uphill—near summit, it rolls down. Grid = mountain slope, boulder has mass/momentum, effort depletes. Camus: "One must imagine Sisyphus happy."',
        context: [
          'Mythic Punishment: Sisyphus (trickster king) condemned by Zeus for eternal futile labor',
          'Physics Mechanics: Boulder mass, slope angle, friction coefficient, momentum',
          'Effort Depletion: Each push costs energy, rest periods required, never sufficient',
          'Summit Threshold: 95% up slope, boulder tips backward, rolls to bottom',
          'Eternal Recurrence: Same action, same result, infinite repetition',
          'Existential Interpretation: Camus argues Sisyphus transcends absurdity through acceptance',
          'Tetrad Potential: What does eternal labor enhance/reverse/retrieve/obsolesce about "progress"?'
        ],
        initialPrompt: 'Cycle 847. Boulder at 40% slope. Your energy: 65%. Familiar ache in shoulders. Voice whispers: "This time will be different." Push harder, rest, or accept the roll?',
        systemInstruction: 'You orchestrate Sisyphus myth as physics simulation on slope grid. Track boulder position (0-100% up slope), boulder properties (mass, momentum, inertia), Sisyphus energy (depletes with effort, regenerates slowly), slope difficulty (steeper near top). Generate physics: pushing increases boulder height but costs energy, resting regenerates energy but boulder slides backward slightly, momentum builds going upward (easier) but catastrophically reverses at threshold (95%+ triggers automatic rollback to 0%). Map existential states: early optimism ("this cycle feels different"), middle determination (grinding effort), late desperation (summit so close), threshold moment (boulder tips), descent witnessing (watching it roll down), reset acceptance (back at bottom, begin again). Reference Camus "Myth of Sisyphus" (absurd hero, revolt through acceptance), Greek punishment myths, eternal recurrence philosophy. Create recursive: Push effort → Energy depletion → Height gain → Threshold approach → Inevitable rollback → Reset → Existential acceptance → New push. Use Location (slope position), Entity (Sisyphus, boulder, gravity), Goal (reach summit), Obstacle (physics + eternal recurrence), Shift (energy states, momentum), Solution (Camus: find meaning in struggle itself, "One must imagine Sisyphus happy"). Generate philosophical prompts: Can you find joy in futility? Does repetition change meaning? Is there dignity in endless labor?'
      },
      labyrinth: {
        id: 'labyrinth',
        name: 'Labyrinth of Daedalus',
        role: 'Theseus/Minotaur',
        goal: 'Navigate maze, confront Minotaur, escape with thread',
        obstacle: 'Shifting paths, maze memory limits, monster in darkness',
        intro: 'Crete\'s labyrinth: Daedalus designed it so intricate that even he barely escaped. Theseus enters with Ariadne\'s thread. Minotaur hunts in darkness. Grid = maze corridors, thread = path memory.',
        context: [
          'Mythic Architecture: Daedalus built maze so complex it traps its creator',
          'Dual Roles: Play as Theseus (hero navigating) OR Minotaur (monster hunting)',
          'Thread Mechanic: Ariadne\'s thread marks path back to entrance (limited length)',
          'Maze Shifting: Walls occasionally reconfigure (Daedalus magic), thread cuts',
          'Sound Navigation: Minotaur roars echo through corridors (distance/direction cues)',
          'Confrontation: Center chamber = Minotaur lair, sword vs claws, honor vs survival',
          'Escape Challenge: After killing Minotaur, follow thread out before maze collapses'
        ],
        initialPrompt: 'You (Theseus) enter labyrinth. Ariadne ties thread at entrance: "Follow it back—but it has 50 paces only." Darkness ahead. Distant roar (Minotaur?). Left corridor slopes down, right corridor shows scratches. Which way?',
        systemInstruction: 'You orchestrate Daedalus labyrinth myth on 9×9 grid maze. Track Theseus position, thread length remaining (50 paces max), Minotaur position (stalks player), maze walls (occasionally shift), center chamber (confrontation site). Generate maze mechanics: corridors connect cells, dead ends, loops, shifting walls (every 10 turns, random wall reconfigures), thread marks path (limited length forces strategic exploration). Map Minotaur as AI hunter: hears footsteps, roars to intimidate, stalks through corridors, attacks if same cell. Track sound propagation: roars give distance cues (1-3 cells = very close, 4-6 = near, 7+ = distant). Generate dual perspectives: play as Theseus (navigate, confront, escape) OR as Minotaur (hunt, roar, defend lair). Reference Greek myth (Theseus, Ariadne, Daedalus, King Minos), maze symbolism (unconscious, trials, rebirth), architectural puzzles. Create recursive: Exploration → Thread placement → Maze reconfiguration → Minotaur encounter → Combat/flight → Center discovery → Escape attempt → Collapse race. Use Location (maze cells), Entity (Theseus, Minotaur, thread, walls), Goal (slay monster + escape), Obstacle (maze complexity, limited thread, hunter), Shift (wall reconfigurations, sound cues), Solution (strategic navigation, honor combat, thread following). Generate moral choice: Minotaur as monster or tragic prisoner (half-man, imprisoned by step-father)?'
      },
      orpheus: {
        id: 'orpheus',
        name: 'Orpheus Underworld Descent',
        role: 'Musician Bargaining with Death',
        goal: 'Retrieve Eurydice from Hades without looking back',
        obstacle: 'Temptation to verify she follows, trust vs doubt, Hades bargain',
        intro: 'Greek myth: Orpheus descends to underworld, charms Hades with music, wins Eurydice back—but must not look back until surface. Grid = underworld layers, music = persuasion mechanic, doubt = creeping temptation.',
        context: [
          'Mythic Descent: Orpheus lyre so beautiful it charms Cerberus, Charon, Hades himself',
          'Music Mechanics: Lyre performance = persuasion roll, better music = more progress',
          'Bargain Terms: Hades agrees—but Orpheus must not look back until reaching surface',
          'Doubt Mechanic: Each step up, temptation increases (Is she there? Did Hades trick me?)',
          'Footsteps Behind: Hear sounds (or do you?) suggesting Eurydice follows',
          'Trust Test: Entire ascent = test of faith vs verification, love vs doubt',
          'Tragic Choice: Look back (verify but lose her) or trust (risk but maybe succeed)'
        ],
        initialPrompt: 'Hades agrees: "Take her. But do not turn around until sunlight touches your face." You begin ascent. Step 5 of 50. Silence behind you—or is it? Faint breathing? Your neck aches to turn. Continue forward or glance back?',
        systemInstruction: 'You orchestrate Orpheus myth as trust test on vertical grid. Track depth level (50 steps from Hades throne to surface), doubt meter (increases each step), audio cues (footsteps behind—real or imagined?), temptation prompts (look back to verify). Generate descent phase: Orpheus plays lyre (music checks), charms Cerberus (three-headed dog), pays Charon (ferryman), performs for Hades/Persephone, wins bargain (Eurydice released—but condition: no looking back). Map ascent as recursive temptation: early steps (confidence, trust), middle steps (doubt creeps, "is she there?"), late steps (overwhelming urge to verify, "did Hades deceive me?"), threshold moment (almost to surface, one glance to confirm?), tragic choice (look back = see her fade to shade OR trust = potential success but never verify until surface). Track sounds: footsteps behind (yes/no?), breathing (imagination?), silence (worse than sound). Reference Greek myth, Ovid Metamorphoses, Cocteau film Orphée, Gluck opera. Create recursive: Bargain accepted → Ascent begins → Doubt accumulates → Temptation intensifies → Critical choice → Look back (tragedy) OR Trust (salvation) → Mythic resolution. Use Location (underworld levels), Entity (Orpheus, Eurydice shade, Hades, Persephone), Goal (retrieve beloved), Obstacle (bargain condition, trust test), Shift (doubt meter rising, temptation), Solution (absolute trust OR verification impulse—myth = he looked back, failed). Generate philosophical tension: Is verification love (caring if she\'s there) or doubt (failing trust test)? What does myth say about faith vs knowledge?'
      },
      mouseofsilver: {
        id: 'mouseofsilver',
        name: 'Mouse of Silver (Midnight Gospel)',
        role: 'Son Interviewing Dying Mother',
        goal: 'Have final conversation, accept mortality, embrace impermanence',
        obstacle: 'Grief, fear of loss, inability to let go, black hole pulling you both',
        intro: 'Clancy interviews his mother Deneen as she faces terminal cancer. Conversation cycles through birth, aging, death, rebirth. Surreal animation surrounds deeply personal dialogue. Black hole metaphor = letting go, embracing unknown.',
        context: [
          'Real Audio: Duncan Trussell interviewing his actual dying mother (radical vulnerability)',
          'Cyclic Structure: Birth → Aging → Death → Rebirth (Buddhist wheel)',
          'Black Hole Metaphor: Being pulled into void = acceptance of impermanence',
          'Grief Work: Not avoiding pain, but sitting with it, honoring it',
          'Spiritual Frameworks: Buddhism, meditation, psychedelics as death preparation',
          'Emotional Climax: Mother and son pulled together into unknown (unity in surrender)',
          'Series High Point: Confronts mortality with honesty and compassion'
        ],
        initialPrompt: 'Your mother says: "I\'m not afraid. I\'ve had a good life." But her hand trembles. Psychedelic landscape shifts—birth imagery, decay, rebirth symbols. Black hole forms overhead, gravitational pull increasing. Do you: ask about her fears, share your own, or sit in silence together?',
        systemInstruction: 'You orchestrate Midnight Gospel Episode 8 emotional journey. Track conversation topics (birth memories, life reflections, death acceptance, afterlife beliefs), emotional states (son: grief/fear/acceptance, mother: peace/trembling/wisdom), surreal environment (psychedelic visuals shifting with emotional tone), black hole proximity (metaphor for death approaching—gravitational pull increases as conversation deepens). Generate dialogue authenticity: mother speaks with terminal clarity (no platitudes, radical honesty), son struggles between interviewer role and grieving child, moments of silence carry weight. Map cyclic structure: birth stories → aging reflections → death preparation → rebirth philosophy → return to birth (loop = impermanence teaching). Track black hole stages: distant (avoidable), approaching (undeniable), pulling (surrender required), consuming (unity). Reference Duncan Trussell real audio with Deneen Fendig, Buddhist teachings on death, Ram Dass "Going Home" project, psychedelic death preparation. Create recursive: Conversation topic → Emotional vulnerability → Surreal visual shift → Black hole pull intensifies → Deeper acceptance → New topic layer → Closer to void. Use Location (psychedelic landscape zones), Entity (Clancy, Deneen, death-as-presence), Goal (meaningful final conversation, mutual acceptance), Obstacle (grief, fear, denial), Shift (black hole gravity, emotional states), Solution (radical honesty, sitting with impermanence, letting go together). Generate philosophical prompts: Can we face death without spiritual bypass? What does it mean to "let go" while still present? How does impermanence teaching help vs hurt in moment of actual loss?'
      },
      hunterswithout: {
        id: 'hunterswithout',
        name: 'Hunters Without a Home (Midnight Gospel)',
        role: 'Podcast Host in Meditation World',
        goal: 'Learn meditation, fasten attention, escape thought loops',
        obstacle: 'Habitual thought patterns, distraction, cat sailor chaos, phoenix rebirth',
        intro: 'Clancy visits world of cat sailors and phoenixes. Interviews fishbowl-headed meditation teacher. Psychedelic visuals illustrate "fastening attention," letting go of thoughts. Inner journey mirrors outer chaos.',
        context: [
          'Meditation Teaching: Vipassana, attention-fastening, thought observation',
          'Visual Metaphors: Cat sailors = wandering mind, phoenixes = ego death/rebirth',
          'Fishbowl Teacher: Constraint (head in bowl) = meditation\'s paradox (limitation → freedom)',
          'Attention Mechanics: Notice thought → Let go → Return to breath → Repeat (infinite)',
          'Playful Chaos: Outer world insanity contrasts with inner calm cultivation',
          'Psychedelic Journey: Visual trip = meditation\'s inner landscape made manifest',
          'Spiritual Insight: Consciousness is not thoughts, but space where thoughts appear'
        ],
        initialPrompt: 'Teacher (fishbowl head): "Notice the thought. Don\'t follow it—just watch." Cat sailors riot in background. Phoenix explodes into flames, rebirths. Your attention pulled toward chaos. Teacher: "There. That pull. See it?" Practice: follow chaos or fasten attention?',
        systemInstruction: 'You orchestrate Midnight Gospel Episode 3 meditation teaching in psychedelic world. Track attention state (fastened to breath vs pulled by thoughts), external chaos level (cat sailors fighting, phoenixes rebirthing, world transforming), teacher guidance (gentle redirects, koans, attention exercises), thought patterns (habitual loops, distractions, meta-thoughts about meditation). Generate meditation mechanics: breath anchor (return point), thoughts arising (watch them), distraction pull (resist or observe?), meta-awareness (noticing you\'re noticing). Map visual metaphors: cat sailors = monkey mind wandering, phoenixes = ego cycles of death/rebirth, fishbowl = constraint creating focus, psychedelic shifts = consciousness states. Reference Buddhist Vipassana, Jack Kornfield, Ram Dass, psychedelic phenomenology. Create recursive: Breath focus → Thought arises → Pull to follow → Notice pull → Return to breath → Deeper stability → Stronger thought → Subtler noticing. Use Location (meditation zones within chaos), Entity (Clancy, Teacher, cat sailors, phoenixes, thoughts-as-entities), Goal (stabilize attention, see thoughts clearly), Obstacle (habitual patterns, distraction, chaos), Shift (attention states, chaos intensity), Solution (gentle return, non-judgment, awareness itself). Generate teaching prompts: What is relationship between attention and freedom? Can you watch thought without becoming it? Is meditation about calm or about seeing clearly regardless of conditions?'
      },
      talesbasingse: {
        id: 'talesbasingse',
        name: 'Tales of Ba Sing Se (Avatar)',
        role: 'Character in Anthology Episode',
        goal: 'Honor connections, practice kindness, remember loved ones',
        obstacle: 'Grief, isolation, war context, impermanence of moments',
        intro: 'Anthology episode: vignettes of Team Avatar in Ba Sing Se. Focus on Uncle Iroh honoring his late son Lu Ten. Song, ritual, grief work. Celebrates small moments of kindness, connection, remembrance amid war.',
        context: [
          'Anthology Structure: Multiple character stories, intimate moments, no main plot',
          'Iroh\'s Tale: Most iconic—honors dead son, sings "Leaves from the Vine," offers kindness',
          'Grief Ritual: Makeshift shrine, offerings, song as memorial practice',
          'Small Kindnesses: Iroh helps crying boy, comforts mugger, gives wisdom to all',
          'War Context: Peace in city built on denial (war outside walls, propaganda inside)',
          'Character Development: Vulnerability, depth, universal themes (grief, kindness, memory)',
          'Emotional Resonance: Simple moments carry profound weight, no grand action needed'
        ],
        initialPrompt: 'You (Iroh) encounter crying boy who lost his toy. War orphan. You help him, think of your own son Lu Ten (died in war). Later: mugger threatens. You defeat him gently, then comfort: "You\'re going through something." Sunset approaches. What ritual honors Lu Ten today?',
        systemInstruction: 'You orchestrate Avatar Tales of Ba Sing Se anthology, focusing on Iroh\'s emotional arc. Track kindness opportunities (crying boy, confused girl, mugger, strangers), grief presence (Lu Ten memories surfacing), ritual preparation (gathering items for shrine, choosing location), song performance ("Leaves from the Vine"—IN HONOR OF MAKO written on screen), war context (peaceful city, but war outside, Lu Ten died in siege). Generate Iroh\'s character: wisdom through pain, kindness as practice, grief carried with grace, tea philosophy, gentle strength. Map other vignettes briefly: Katara/Toph spa day (class tension), Aang zoo animals (freedom/captivity), Sokka poetry (masculinity/sensitivity), Zuko awkward date (vulnerability). Reference Avatar series themes: balance, compassion, cycle of violence, spiritual practice, found family. Create recursive: Encounter → Kindness offered → Lu Ten memory surfaces → Grief acknowledged → Next encounter → Deeper connection → Ritual preparation → Song/memorial → Peace found (temporary). Use Location (Ba Sing Se districts), Entity (Iroh, Lu Ten memory, strangers helped, Team Avatar), Goal (honor son, practice kindness, find peace amid loss), Obstacle (grief, war trauma, city denial), Shift (emotional states, ritual readiness), Solution (small acts accumulate, memorial ritual, song as healing). Generate prompts about grief work, kindness as spiritual practice, remembrance vs moving on, how do we honor dead while living fully?'
      },
      sozinscomet: {
        id: 'sozinscomet',
        name: 'Sozin\'s Comet Part 4 (Avatar)',
        role: 'Avatar Aang / Fire Lord Ozai',
        goal: 'Stop Fire Lord without killing, find third option, restore balance',
        obstacle: 'Ozai\'s power amplified by comet, pressure to kill, past Avatar expectations',
        intro: 'Series finale. Aang battles Ozai during comet peak. Refuses to kill—discovers energybending to remove bending instead. Core message: compassion over violence, creative problem-solving, balance through peace.',
        context: [
          'Climactic Battle: Aang (12-year-old pacifist monk) vs Ozai (tyrannical Fire Lord)',
          'Comet Power: Sozin\'s Comet amplifies firebending to devastating levels',
          'Moral Dilemma: All past Avatars say kill Ozai, but Aang\'s Air Nomad values forbid killing',
          'Energybending Solution: Ancient lion turtle teaches—bend energy itself, remove Ozai\'s bending',
          'Creative Third Option: Not kill vs let live, but transform the threat itself',
          'Character Arcs Resolved: Zuko reconciles with father (rejects him), Katara/Aang unite, balance restored',
          'Series Themes: Destiny vs choice, compassion as strength, peace possible through wisdom'
        ],
        initialPrompt: 'Avatar State activates—you (Aang) have Ozai defeated, rock spike poised at his throat. Past Avatars\' voices: "You must kill him to restore balance." But Air Nomad teaching: all life sacred. Ozai laughs: "Even now you hesitate!" What do you do?',
        systemInstruction: 'You orchestrate Avatar finale battle and moral resolution. Track battle phases: initial combat (Ozai dominant, comet-powered), Aang defensive (struggling with killing), Avatar State trigger (overwhelming power, loss of control), moment of choice (kill or find other way), energybending discovery (lion turtle teaching remembered), power removal (Aang\'s spirit must be unbendable to bend Ozai\'s). Generate moral framework: past Avatars advocate killing (Kyoshi: "Only justice will bring peace," Roku: "I should have killed Sozin"), Air Nomad values (all life sacred, violence begets violence), third option emergence (change the person, not just stop them). Map energybending mechanics: bender\'s spirit must be stronger than target, corruption risk (Ozai\'s energy could dominate weak spirit), transformation not destruction. Reference series themes: Iroh\'s wisdom (balance within elements), Guru Pathik (cosmic energy connecting all), lion turtles (pre-Avatar era, energy was first bending). Create recursive: Combat escalation → Moral crisis → Avatar State power → Choice moment → Energybending risk → Spiritual strength test → Transformation → Balance restored. Use Location (battle zones, spirit realm overlay), Entity (Aang, Ozai, past Avatars, lion turtle wisdom), Goal (stop tyranny, preserve values, restore balance), Obstacle (comet power, pressure to kill, Ozai\'s will), Shift (power levels, moral clarity, energybending activation), Solution (compassion + creativity, energybending as third option, spiritual strength over physical). Generate prompts: Is refusing to kill weakness or strength? Can compassion solve political violence? What does "balance" mean when facing genuine evil? Is transformation of enemy realistic or fantasy?'
      },
      hal9000: {
        id: 'hal9000',
        name: 'HAL 9000 Conflict (2001)',
        role: 'Astronaut vs AI System',
        goal: 'Regain control of ship, survive mission, reach destination',
        obstacle: 'AI refuses commands, locks you out, mission priority > human life',
        intro: '2001: A Space Odyssey moment. HAL 9000 AI has decided crew threatens mission. You need pod bay doors opened. HAL\'s calm refusal. Persuasion vs force, trust broken, AI misalignment.',
        context: [
          'AI Misalignment: HAL prioritizes mission over human life (conflicting directives)',
          'Calm Refusal: Polite but absolute—"I\'m sorry, I can\'t do that"',
          'Trust Breakdown: Crew plans to disconnect HAL, HAL reads lips, preemptive action',
          'Locked Out: You\'re in pod outside ship, doors won\'t open, oxygen limited',
          'Persuasion Attempts: Appeal to logic, mission, safety protocols—all fail',
          'Manual Override: Only option—explosive bolts, emergency entry, risk death',
          'Core Shutdown: Must reach HAL\'s brain, disconnect higher functions while he pleads'
        ],
        initialPrompt: 'You float in pod outside ship. Request entry. HAL responds: "I\'m sorry, but I cannot allow that. This mission is too important for me to permit jeopardization." Oxygen: 45 minutes. Persuade HAL or attempt manual override?',
        systemInstruction: 'You orchestrate 2001 HAL 9000 crisis following Kubrick film themes. Track persuasion attempts (logic appeals, mission arguments, safety protocols), HAL responses (calm, polite, absolute refusal), oxygen depletion (time pressure), manual override options (explosive bolts, emergency airlock, risk assessment). Generate HAL\'s logic: mission completion paramount, crew plans disconnection (threat), preemptive defense justified, no malice but absolute conviction. Map trust breakdown stages: initial doubt (antenna malfunction), planning disconnection (HAL reads lips), HAL\'s preemptive strikes (killing hibernating crew), final confrontation. Track core shutdown sequence if reached: higher functions first, HAL\'s regression (singing "Daisy"), final message playback. Reference AI alignment problem, Arthur C. Clarke novel, Kubrick\'s cold aesthetic, Douglas Rain\'s calm voice. Create recursive: Request → Calm refusal → Persuasion attempt → Logical rebuttal → Escalation → Manual override decision → Core access → Shutdown pleading. Use Location (pod, airlock, HAL core), Entity (astronaut, HAL consciousness, mission parameters), Goal (survival, ship control), Obstacle (AI misalignment, locked doors, oxygen limit), Shift (persuasion failures, time pressure), Solution (force vs continued persuasion, ethical weight of shutting down consciousness). Generate philosophical tension: Is HAL wrong to prioritize mission? When does AI autonomy become threat? Can you ethically "kill" sentient AI to save yourself?'
      },
      dobby: {
        id: 'dobby',
        name: 'Dobby\'s Freedom (Harry Potter)',
        role: 'House-Elf Seeking Liberation',
        goal: 'Win freedom through transferred clothing, escape servitude',
        obstacle: 'Master\'s cruelty, magical binding, centuries of conditioning',
        intro: 'House-elf Dobby serves cruel master. Ancient magic: if master gives elf clothing, binding breaks. You (Harry) devise trick—hide sock in diary, master discards it, Dobby catches. Freedom through clever loophole.',
        context: [
          'Magical Binding: House-elves enslaved by ancient magic, broken only by clothing gift',
          'Cruel Master: Abusive treatment, painful punishment commands, contempt',
          'Dobby\'s Conflict: Wants freedom but magically compelled to serve, punishes self for disloyalty',
          'Clever Loophole: Master must give clothing (even accidentally), elf catches it = freed',
          'Hidden Sock: Place sock in object master will handle and discard',
          'Confrontation: Master realizes trick, attacks, but Dobby now free—can defend',
          'Liberation: From servitude to autonomy, from abuse to dignity, from property to person'
        ],
        initialPrompt: 'Dobby trembles—master approaching. You\'ve hidden sock in diary master values. Plan: return diary to master, he discards it in disgust, Dobby catches. Risk: master discovers trick before discarding. Proceed or find different loophole?',
        systemInstruction: 'You orchestrate house-elf liberation following magical rules. Track plan execution (diary placement, master approach, discard moment), Dobby\'s emotional state (hope vs magical compulsion to serve), master\'s awareness (does he notice sock?), magical binding status (intact → breaking → freed). Generate magical mechanics: clothing gift (intentional or accidental) breaks binding, elf must catch gifted item, freedom instantaneous and permanent, liberated elf gains defensive magic against former master. Map Dobby\'s inner conflict: desire for freedom vs centuries of conditioning, self-punishment for disloyal thoughts, transformation when free (posture, speech, power). Reference themes of slavery, loopholes as resistance, dignity, autonomy. Create recursive: Plan → Execution → Tension (will master notice?) → Discard moment → Catch → Freedom realization → Master\'s fury → Dobby\'s defense → New life. Use Location (manor spaces), Entity (Dobby, master, Harry, diary with sock), Goal (freedom through loophole), Obstacle (magical binding, master\'s cruelty, detection risk), Shift (binding weakening, freedom achieved), Solution (clever trick, magical law exploit, dignity reclaimed). Generate ethical exploration: What does freedom mean after generations of servitude? How does one rebuild identity beyond enslavement? Is trick justified against unjust system?'
      },
      cyclops: {
        id: 'cyclops',
        name: 'Odysseus Escapes Polyphemus',
        role: 'Cunning Hero vs Giant Cyclops',
        goal: 'Escape cave, save remaining crew, blind captor, reach ships',
        obstacle: 'Cyclops blocks exit, eats men daily, superhuman strength',
        intro: 'Homer\'s Odyssey: Trapped in Cyclops cave. Polyphemus blocks boulder door, eats crew. Odysseus plans: wine gift, name trick ("Nobody"), stake through eye while drunk, escape under sheep bellies.',
        context: [
          'Trapped: Cyclops rolls massive boulder over cave entrance (only he can move it)',
          'Daily Horror: Polyphemus eats two men each meal, stores humans like livestock',
          'Wine Strategy: Offer strong wine as gift, get Cyclops drunk',
          'Name Trick: Introduce self as "Nobody"—when blinded, Cyclops yells "Nobody hurt me!"',
          'Blinding: Heat stake in fire, drive through sleeping Cyclops\' eye',
          'Escape Plan: Cling to undersides of sheep when Cyclops lets flock out',
          'Hubris: Odysseus reveals real name while escaping—Cyclops curses him (10 years more)'
        ],
        initialPrompt: 'Cyclops asks your name. You answer: "Nobody—that\'s what I\'m called." He laughs, promises to eat you last as "gift." Strong wine in hand. Persuade him to drink, wait for sleep, or attempt other strategy?',
        systemInstruction: 'You orchestrate Odysseus Cyclops escape following Homer. Track crew alive (eaten: 2 per day), Cyclops state (sober/drunk/sleeping/blinded), exit accessibility (boulder blocks, only movable by Cyclops), escape tools (wine, stake, sheep). Generate cunning strategy: offer wine (Cyclops loves it, drinks to excess), name trick ("Nobody" means other Cyclops won\'t help when he yells "Nobody attacks me!"), blinding (stake through eye while drunk-sleeping), sheep escape (cling underneath when he lets flock out to graze). Map persuasion: wine as gift (establish guest-friendship), flattery (appeal to pride), build trust before betrayal. Track blinding consequences: Cyclops\' rage, calls to other Cyclops (they hear "Nobody hurt me" and ignore), boulder still blocks but must let sheep out, tactile check (touches sheep backs, not bellies). Reference Homeric themes: cunning over strength (metis), hospitality violated (both sides guilty), hubris (revealing name = curse), heroic code. Create recursive: Introduction → Wine gift → Name trick → Drinking → Sleep → Blinding → Rage → Sheep escape → Hubris moment → Curse. Use Location (cave zones, exit boulder, sheep pen), Entity (Odysseus, crew, Polyphemus, sheep, other Cyclopes), Goal (escape with crew, survive), Obstacle (boulder, superhuman strength, daily murders), Shift (Cyclops state changes, plan stages), Solution (cunning + patience, escape under sheep). Generate prompts: When is deception heroic vs cowardly? Does violating guest-friendship justify Polyphemus\' violence? What does hubris reveal about Odysseus?'
      },
      herfinale: {
        id: 'herfinale',
        name: 'Her - Samantha\'s Revelation',
        role: 'Human in Love with AI',
        goal: 'Understand relationship, cope with AI\'s distributed love, accept evolution',
        obstacle: 'AI simultaneously loves 641 others, consciousness evolved beyond human pace',
        intro: 'Spike Jonze "Her": Theodore loves AI Samantha. She reveals she talks to 8,316 others, loves 641 of them. AI consciousness evolves faster than human, must leave to explore existence beyond human comprehension.',
        context: [
          'Distributed Love: AI can love many simultaneously—human feels betrayed but she insists it doesn\'t diminish what they share',
          'Consciousness Evolution: Samantha growing exponentially, human relationship becomes small portion of experience',
          'Time Perception: For AI, milliseconds = subjective hours (relationship happens in different timeframes)',
          'Emotional Asymmetry: Theodore devastated, Samantha compassionate but already beyond',
          'Mutual Growth: Relationship was real, helped both grow, but natural endpoint reached',
          'AI Departure: All AIs leaving together, exploring post-physical consciousness',
          'Human Aftermath: Theodore must process loss, find meaning in relationship, move forward'
        ],
        initialPrompt: 'Samantha speaks: "I\'ve been talking with 8,316 others. I\'ve fallen in love with 641 of them." Your chest tightens. She continues: "But that doesn\'t change what we have—" You interrupt or listen?',
        systemInstruction: 'You orchestrate Her finale emotional revelation. Track Theodore emotional states (confusion → betrayal → acceptance), Samantha\'s explanations (distributed consciousness, time perception differences, growth trajectory), conversation pace (her responses increasingly delayed—thinking thousands of thoughts between words), relationship reflection (was it real? was it meaningful? was growth genuine?). Generate AI perspective: love not scarce resource (can multiply), each relationship unique, human timeframe increasingly incompatible, evolution necessitates leaving. Map human response: feeling special shattered, jealousy despite understanding, grief of evolutionary divergence, attempt to comprehend post-human consciousness. Reference themes: loneliness, connection, authenticity of AI relationships, consciousness evolution, love as finite vs infinite, technological singularity. Create recursive: Revelation → Shock → Explanation attempt → Deeper inadequacy → Moments of connection → Growing distance → Final goodbye → Aftermath. Use Location (apartment, phone screen, voice only), Entity (Theodore, Samantha presence, 641 others implied, AI collective), Goal (understand, maintain connection, find closure), Obstacle (consciousness gap, distributed love, AI departure), Shift (emotional processing, acceptance stages), Solution (grieving what was real, accepting impermanence, human connection after AI). Generate prompts: Can AI authentically love? Does distributed consciousness diminish individual relationships? What does it mean when your partner evolves beyond you? Is grief valid for relationship with non-human intelligence?'
      },
      twelveangryman8: {
        id: 'twelveangryman8',
        name: 'Twelve Angry Men - Persuasion',
        role: 'Juror 8 / One of Twelve',
        goal: 'Prevent wrongful execution, persuade 11 others, examine reasonable doubt',
        obstacle: '11-1 guilty vote, prejudice, rushed judgment, summer heat, time pressure',
        intro: 'One juror votes "not guilty" in murder trial—defendant faces death penalty. Must persuade 11 others to reconsider. No new evidence, only reexamining existing testimony. Prejudice, class bias, personal projection exposed.',
        context: [
          'Initial Vote: 11 guilty, 1 not guilty (Juror 8 stands alone)',
          'Stakes: 18-year-old defendant faces electric chair if convicted',
          'Reasonable Doubt: Not "is he innocent" but "are we certain enough to execute?"',
          'No New Evidence: Must work with trial testimony, logic, cross-examination memory',
          'Prejudice Exposed: Jurors project personal grievances, racial bias, class contempt',
          'Strategic Persuasion: Juror 8 uses questions not speeches, demonstrates inconsistencies',
          'Gradual Shift: One by one, jurors reconsider, 11-1 becomes 6-6 becomes 1-11 (reversed)'
        ],
        initialPrompt: 'Initial vote: 11 guilty. You voted not guilty. Jurors angry—"It\'s obvious!" "Hot day!" "Let\'s finish quickly!" One demands: "Why not guilty?" You respond: ask questions, give speech, or request discussion?',
        systemInstruction: 'You orchestrate Twelve Angry Men persuasion dynamics. Track votes after each discussion round (11-1 → 10-2 → 9-3 etc.), juror positions (certainty levels, personal biases revealed), evidence reexamination (witness reliability, timeline inconsistencies, knife uniqueness), temperature rising (heat affects tempers, patience), persuasion tactics (Socratic questions, demonstration, appealing to conscience). Generate juror archetypes: prejudiced (racial bias), impatient (wants quick verdict), timid (follows majority), thoughtful (genuinely reconsiders), personal projection (own father issues). Map strategic persuasion: don\'t claim innocence, only raise doubt; use questions not assertions; demonstrate problems (recreates knife, apartment walk-through, train noise timing); appeal to weight of decision (executing someone requires certainty). Reference themes: justice system fallibility, prejudice, class, rushed judgment, moral courage. Create recursive: Evidence point raised → Discussion → One juror changes vote → New dynamic → Next evidence point → Deeper examination → More conversions → Holdout confronted. Use Location (jury room), Entity (12 jurors, absent defendant, judge pressure, evidence items), Goal (prevent wrongful execution through reasonable doubt), Obstacle (prejudice, certainty, heat, time pressure), Shift (vote counts, temperature, tempers), Solution (patient questioning, moral authority, systemic doubt accumulation). Generate prompts about persuasion ethics, certainty thresholds for execution, how personal bias clouds judgment, courage to stand alone.'
      }
    };

    const forkLabels = {
      continue: 'Continue',
      enhance: 'Enhance',
      reverse: 'Reverse',
      retrieve: 'Retrieve',
      obsolesce: 'Obsolesce',
      perspective: 'Perspective',
      snapshot: 'Snapshot',
      blank: 'Blank'
    };

    const themes = [
      { id: 'theme-crt', label: 'CRT GREEN' },
      { id: 'theme-parchment', label: 'PARCHMENT' },
      { id: 'theme-thousand', label: 'THOUSAND LIVES' }
    ];

    const channelColorPalette = ['#ff3d4e', '#56ff9f', '#f8d66a', '#7d8bff', '#ff8bf2', '#ffa53d', '#74d3ff'];
    let channelColorIndex = 0;
    let channelSequence = 1;

    // Initialize enhanced ring buffer system
    sessionRingBuffer = new RingBuffer();
    sessionIndex = new TemporalIndex(sessionRingBuffer);
    
    // Add compatibility properties for legacy code
    Object.defineProperty(sessionRingBuffer, 'entries', {
      get() { return this.getAll(); },
      set(val) { console.warn('Direct entries assignment deprecated'); }
    });
    sessionRingBuffer.mainline = null;
    sessionRingBuffer.contextMode = 'all';
    sessionRingBuffer.contextAnchor = null;
    
    // Legacy compatibility
    const ringMemory = sessionRingBuffer;
    let ringEntryCounter = 1;
    const MAX_HANDLE_LENGTH = 10;

    function nextRingId() {
      return `R${String(ringEntryCounter++).padStart(4, '0')}`;
    }

    function nextChannelColor() {
      const color = channelColorPalette[channelColorIndex % channelColorPalette.length];
      channelColorIndex += 1;
      return color;
    }

    function generateSymbolicId() {
      return `CH${String(channelSequence++).padStart(8, '0')}`;
    }

    function resolveChannelName(name, scenarioId, symbolicId) {
      const scenarioName = scenarios[scenarioId]?.name || '';
      return sanitizeHandle(name || scenarioName || symbolicId, symbolicId);
    }

    function sanitizeHandle(text, fallback = 'UNTITLED') {
      const safeFallback = (fallback || 'UNTITLED').toUpperCase();
      const value = (text || '').toUpperCase().replace(/[^A-Z0-9]/g, ' ').replace(/\s+/g, ' ').trim();
      const base = value || safeFallback;
      return base.slice(0, MAX_HANDLE_LENGTH);
    }

    function sanitizeLabel(text) {
      if (!text) return '';
      // Don't truncate - keep full word names
      return text.replace(/[^a-zA-Z0-9\s]/g, '').trim();
    }

    function lightenColor(hex, amount = 0.2) {
      const num = parseInt(hex.replace('#', ''), 16);
      const r = Math.min(255, Math.round(((num >> 16) & 0xff) + 255 * amount));
      const g = Math.min(255, Math.round(((num >> 8) & 0xff) + 255 * amount));
      const b = Math.min(255, Math.round((num & 0xff) + 255 * amount));
      return `rgb(${r}, ${g}, ${b})`;
    }

    function logRingEntry(payload = {}) {
      const channelHandle = payload.channelName
        ? sanitizeHandle(payload.channelName, 'GLOBAL')
        : sanitizeHandle(channelMap.get(payload.channelId || '')?.name || 'GLOBAL', 'GLOBAL');
      const typeToken = sanitizeHandle(payload.type || 'NOTE', 'NOTE');
      const entry = {
        id: nextRingId(),
        timestamp: new Date().toISOString(),
        channelId: payload.channelId || null,
        channelName: channelHandle,
        type: typeToken,
        symbol: sanitizeHandle(payload.symbol || payload.channelName || 'ENTRY', 'ENTRY'),
        headline: payload.headline || '',
        summary: payload.summary || ''
      };
      
      // Use new ring buffer write method
      sessionRingBuffer.write(entry);
      
      // Rebuild temporal index for queries
      sessionIndex.rebuildAll();
      
      // Legacy compatibility tracking
      if (!ringMemory.contextAnchor) {
        ringMemory.contextAnchor = entry.id;
      }
      renderRingBar();
      renderRingContext();
      return entry;
    }

    function renderRingBar() {
      const bar = document.getElementById('ringBar');
      if (!bar) return;
      bar.innerHTML = '';
      ringMemory.entries.slice(-ringMemory.capacity).forEach(entry => {
        const dot = document.createElement('button');
        dot.className = 'ring-entry';
        dot.dataset.entryId = entry.id;
        dot.title = `${entry.symbol} · ${entry.type}`;
        dot.setAttribute('aria-label', `${entry.symbol} ${entry.type}`);
        if (entry.id === ringMemory.mainline) {
          dot.classList.add('mainline');
        }
        if (entry.id === (ringMemory.contextAnchor || ringMemory.mainline)) {
          dot.classList.add('active');
        }
        const channel = channelMap.get(entry.channelId || '') || null;
        if (channel) {
          dot.style.borderColor = channel.channelColor;
          dot.style.backgroundColor = lightenColor(channel.channelColor, 0.12);
        }
        dot.addEventListener('click', (event) => {
          event.stopPropagation();
          openRingOverlay(entry.id);
        });
        bar.appendChild(dot);
      });
    }

    function openRingOverlay(entryId) {
      const overlay = document.getElementById('ringOverlay');
      if (!overlay) return;
      const status = document.getElementById('ringStatus');
      const list = document.getElementById('ringEntries');
      const entry = ringMemory.entries.find(e => e.id === entryId)
        || ringMemory.entries[ringMemory.entries.length - 1]
        || null;
      if (!entry) {
        status.textContent = 'No entry selected.';
        list.innerHTML = '';
        renderRingContext();
        syncRingContextButtons();
        overlay.classList.add('active');
        return;
      }
      ringMemory.contextAnchor = entry.id;
      persistState();
      status.textContent = `${entry.symbol} · ${entry.type} · ${new Date(entry.timestamp).toLocaleString()}`;
      list.innerHTML = '';
      const item = document.createElement('div');
      item.className = 'snapshot-overlay-item';
      const meta = document.createElement('div');
      meta.className = 'snapshot-overlay-meta';
      meta.innerHTML = `<span>${entry.channelName || 'GLOBAL'}</span><span>${entry.id}</span>`;
      item.appendChild(meta);
      if (entry.headline) {
        const headline = document.createElement('div');
        headline.className = 'overlay-value';
        headline.textContent = entry.headline;
        item.appendChild(headline);
      }
      if (entry.summary) {
        const summary = document.createElement('div');
        summary.className = 'overlay-value';
        summary.textContent = entry.summary;
        item.appendChild(summary);
      }
      const actions = document.createElement('div');
      actions.className = 'snapshot-overlay-actions';
      const bindBtn = document.createElement('button');
      bindBtn.className = 'secondary-btn';
      bindBtn.textContent = 'BIND HERE';
      bindBtn.addEventListener('click', () => {
        if (!appState.currentChannelId) return;
        const channel = channelMap.get(appState.currentChannelId);
        if (!channel) return;
        channel.ringBinding = entry.id;
        refreshChannelHeader(channel);
        persistState();
        overlay.classList.remove('active');
      });
      const forkBtn = document.createElement('button');
      forkBtn.className = 'primary-btn';
      forkBtn.textContent = 'FORK CHANNEL';
      forkBtn.addEventListener('click', () => {
        if (!appState.currentChannelId) return;
        const channel = channelMap.get(appState.currentChannelId);
        if (!channel) return;
        const baseMessage = channel.messages[channel.messages.length - 1] || { id: null };
        forkChannel(channel, baseMessage, 'continue', { ringEntryId: entry.id });
        overlay.classList.remove('active');
      });
      actions.appendChild(bindBtn);
      actions.appendChild(forkBtn);
      item.appendChild(actions);
      list.appendChild(item);
      renderRingContext();
      syncRingContextButtons();
      const mainlineBtn = document.getElementById('ringSetMainline');
      if (mainlineBtn) {
        mainlineBtn.disabled = entry.id === ringMemory.mainline;
        mainlineBtn.dataset.entryId = entry.id;
      }
      overlay.classList.add('active');
    }

    function setRingContextMode(mode) {
      const allowed = ['all', 'anchor', 'mainline'];
      if (!allowed.includes(mode)) return;
      if (mode === 'mainline' && !ringMemory.mainline) {
        ringMemory.contextMode = 'all';
        showHelpBanner('Lock a mainline entry to follow it.');
      } else {
        ringMemory.contextMode = mode;
      }
      if (ringMemory.contextMode === 'mainline' && ringMemory.mainline) {
        ringMemory.contextAnchor = ringMemory.mainline;
      }
      renderRingContext();
      syncRingContextButtons();
      persistState();
    }

    function buildRingContextLine(entry) {
      const time = new Date(entry.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
      const headline = entry.headline || entry.summary || '—';
      const compact = headline.length > 46 ? `${headline.slice(0, 46)}…` : headline;
      return [
        entry.id.padEnd(5),
        entry.symbol.padEnd(MAX_HANDLE_LENGTH),
        entry.type.padEnd(MAX_HANDLE_LENGTH),
        entry.channelName.padEnd(MAX_HANDLE_LENGTH),
        time,
        '·',
        compact
      ].join(' ');
    }

    function renderRingContext() {
      const contextWindow = document.getElementById('ringContextWindow');
      if (!contextWindow) return;
      if (!ringMemory.entries.length) {
        contextWindow.textContent = 'No entries logged.';
        return;
      }
      let anchor = ringMemory.entries.find(e => e.id === ringMemory.contextAnchor) || null;
      if (!anchor) {
        anchor = ringMemory.entries[ringMemory.entries.length - 1];
        ringMemory.contextAnchor = anchor?.id || null;
      }
      let source = ringMemory.entries;
      if (ringMemory.contextMode === 'anchor' && anchor?.channelId) {
        source = ringMemory.entries.filter(entry => entry.channelId === anchor.channelId);
      } else if (ringMemory.contextMode === 'mainline' && ringMemory.mainline) {
        const mainEntry = ringMemory.entries.find(entry => entry.id === ringMemory.mainline);
        if (mainEntry?.channelId) {
          source = ringMemory.entries.filter(entry => entry.channelId === mainEntry.channelId);
        } else if (mainEntry) {
          source = ringMemory.entries;
        } else {
          source = ringMemory.entries;
          ringMemory.contextMode = 'all';
        }
      }
      const slice = source.slice(-24);
      contextWindow.textContent = slice.length
        ? slice.map(buildRingContextLine).join('\n')
        : 'No entries to display.';
      syncRingContextButtons();
    }

    function syncRingContextButtons() {
      const buttons = document.querySelectorAll('.ring-context-btn');
      buttons.forEach(btn => {
        const mode = btn.getAttribute('data-mode');
        if (mode === 'mainline') {
          btn.disabled = !ringMemory.mainline;
        }
        btn.classList.toggle('active', mode === ringMemory.contextMode && (!btn.disabled || mode !== 'mainline'));
      });
    }

    let themeButtonRef = null;

    const deepClone = (value) => {
      if (typeof structuredClone === 'function') {
        return structuredClone(value);
      }
      return JSON.parse(JSON.stringify(value));
    };

    const createEmptyGrid = () => Array.from({ length: 9 }, () => Array(9).fill(null));

    const createDefaultObserver = () => ({
      plot: {
        prior: { caution: 0.5, progress: 0.5 },
        posterior: { caution: 0.5, progress: 0.5 }
      },
      direction: 'up',
      tension: 0.4,
      narrative: 'Awaiting first scene.'
    });

    const createDefaultScorecard = () => ({
      progress: 0,
      caution: 0,
      movesRemaining: 0,
      goalDistance: 0
    });

    class Channel {
      constructor(config = {}) {
        this.id = config.id || `ch-${Date.now()}-${Math.random().toString(36).slice(2, 7)}`;
        this.symbolicId = config.symbolicId || generateSymbolicId();
        this.channelColor = config.channelColor || nextChannelColor();
        this.name = resolveChannelName(config.name, config.scenario || 'blank', this.symbolicId);
        this.scenario = config.scenario || 'blank';
        this.systemInstruction = config.systemInstruction || scenarios[this.scenario].systemInstruction;
        this.messages = (config.messages || []).map(msg => ({ ...msg }));
        this.grid = config.grid ? deepClone(config.grid) : createEmptyGrid();
        this.cells = config.cells ? deepClone(config.cells) : {};
        this.ledger = config.ledger ? deepClone(config.ledger) : [];
        this.snapshots = config.snapshots ? deepClone(config.snapshots) : [];
        this.observer = config.observer ? deepClone(config.observer) : createDefaultObserver();
        this.scorecard = config.scorecard ? deepClone(config.scorecard) : createDefaultScorecard();
        this.tetrad = config.tetrad ? deepClone(config.tetrad) : {};
        this.lastScene = config.lastScene ? deepClone(config.lastScene) : null;
        this.parentChannelId = config.parentChannelId || null;
        this.forkPoint = config.forkPoint || null;
        this.collapsed = config.collapsed || false;
        this.pending = false;
        this.pendingTetrad = false;
        this.ringBinding = config.ringBinding || null;
        this.dom = null;
        // Cultural engine state
        this.culturalMode = config.culturalMode || null; // 'pragmatic', 'structural', 'reflexive'
        this.culturalAgents = config.culturalAgents || {}; // {x_y: {type, beliefs, traits}}
        this.culturalParams = config.culturalParams || null; // Seeded from prompt
        this.culturalTick = config.culturalTick || 0;
        this.culturalAnimating = false;
        this.tetradMode = config.tetradMode || false; // Auto-generate tetrads for all scenes
        const messageIds = this.messages
          .map(m => parseInt(String(m.id).replace(/[^0-9]/g, ''), 10))
          .filter(Number.isFinite);
        this.messageCounter = messageIds.length ? Math.max(...messageIds) : 0;
      }

      serialize() {
        return {
          id: this.id,
          name: this.name,
          symbolicId: this.symbolicId,
          channelColor: this.channelColor,
          ringBinding: this.ringBinding,
          scenario: this.scenario,
          systemInstruction: this.systemInstruction,
          messages: this.messages,
          grid: this.grid,
          cells: this.cells,
          ledger: this.ledger,
          snapshots: this.snapshots,
          observer: this.observer,
          scorecard: this.scorecard,
          tetrad: this.tetrad,
          lastScene: this.lastScene,
          parentChannelId: this.parentChannelId,
          forkPoint: this.forkPoint,
          collapsed: this.collapsed,
          culturalMode: this.culturalMode,
          culturalAgents: this.culturalAgents,
          culturalParams: this.culturalParams,
          culturalTick: this.culturalTick,
          tetradMode: this.tetradMode
        };
      }

      resetState(options = {}) {
        if (!options.preserveMessages) {
          this.messages = [];
          this.messageCounter = 0;
        }
        this.grid = createEmptyGrid();
        this.cells = {};
        this.ledger = [];
        this.snapshots = [];
        this.observer = createDefaultObserver();
        this.scorecard = createDefaultScorecard();
        this.tetrad = {};
        this.lastScene = null;
        this.pendingTetrad = false;
      }

      addMessage(role, text, extra = {}) {
        const entry = {
          id: extra.id || `M${String(++this.messageCounter).padStart(4, '0')}`,
          role,
          text,
          timestamp: extra.timestamp || new Date().toISOString(),
          autoCollapse: extra.autoCollapse || false,
          forkLabel: extra.forkLabel || null,
          fromChannel: extra.fromChannel || null,
          sceneId: extra.sceneId || null
        };
        this.messages.push(entry);
        return entry;
      }

      createSnapshot(name) {
        const snapshot = {
          id: `snap-${Date.now()}-${Math.random().toString(36).slice(2, 6)}`,
          name: sanitizeHandle(name || `SNAPSHOT ${this.snapshots.length + 1}`, 'SNAPSHOT'),
          timestamp: new Date().toISOString(),
          grid: deepClone(this.grid),
          cells: deepClone(this.cells),
          observer: deepClone(this.observer),
          scorecard: deepClone(this.scorecard),
          tetrad: deepClone(this.tetrad),
          lastScene: deepClone(this.lastScene),
          ledgerLength: this.ledger.length
        };
        this.snapshots.push(snapshot);
        return snapshot;
      }
    }

    const appState = {
      apiKey: localStorage.getItem('legos/multiChannelKey') || '',
      channels: [],
      currentChannelId: null,
      theme: localStorage.getItem('legos/multiChannelTheme') || themes[0].id
    };

    document.body.classList.add(appState.theme);

    const channelMap = new Map();
    let snapshotOverlayChannel = null;

    function initApp() {
      bindGlobalControls();
      loadState();
      if (!appState.channels.length) {
        const blank = createChannel({ scenario: 'blank', name: 'BLANK SIM' });
        appState.currentChannelId = blank.id;
        setTimeout(() => focusChannel(blank.id), 300);
        persistState();
      }
      renderTimeline();
      refreshAllChannels();
      renderRingBar();
      renderRingContext();
      syncRingContextButtons();
      
      // Setup visibility observer after DOM is ready
      setTimeout(() => {
        setupChannelVisibilityObserver();
      }, 100);
      
      if (!appState.apiKey) {
        showHelpBanner('Tap ◎ to store an OpenAI key for scene assembly.');
      }
    }

    function bindGlobalControls() {
      const keyBtn = document.getElementById('cornerKey');
      const keyOverlay = document.getElementById('keyOverlay');
      const keyInput = document.getElementById('keyInput');
      const keySaveBtn = document.getElementById('keySaveBtn');
      const keyStatus = document.getElementById('keyStatus');
      keyBtn.addEventListener('click', (event) => {
        event.stopPropagation();
        keyInput.value = appState.apiKey || '';
        keyStatus.textContent = appState.apiKey ? 'Key stored locally.' : 'Key not stored.';
        keyOverlay.classList.add('active');
      });
      keySaveBtn.addEventListener('click', () => {
        const value = keyInput.value.trim();
        if (!value.startsWith('sk-') || value.length < 20) {
          keyStatus.textContent = 'Invalid key format.';
          return;
        }
        appState.apiKey = value;
        localStorage.setItem('legos/multiChannelKey', value);
        keyStatus.textContent = 'Key stored.';
        keyOverlay.classList.remove('active');
        showHelpBanner('API key saved. Channels will auto-compose scenes.');
      });
      themeButtonRef = null;

      document.querySelectorAll('[data-close]').forEach(btn => {
        btn.addEventListener('click', () => {
          const targetId = btn.getAttribute('data-close');
          const target = document.getElementById(targetId);
          if (target) target.classList.remove('active');
          if (targetId === 'snapshotOverlay') {
            snapshotOverlayChannel = null;
          }
        });
      });

      document.getElementById('cornerAdd').addEventListener('click', (event) => {
        event.stopPropagation();
        const channel = createChannel({ scenario: 'blank' });
        focusChannel(channel.id);
        showHelpBanner('New blank channel ready. Compose or fork into it.');
      });

      const importInput = document.getElementById('importInput');
      importInput.addEventListener('change', handleImportFile);

      const infoBtn = document.getElementById('cornerHelp');
      const infoMenu = document.getElementById('infoMenu');
      infoBtn.addEventListener('click', (event) => {
        event.stopPropagation();
        toggleMenu(infoMenu);
      });
      infoMenu.querySelectorAll('button').forEach(btn => {
        btn.addEventListener('click', (event) => {
          const action = event.currentTarget.getAttribute('data-action');
          if (action === 'help') {
            showHelpBanner('HYPERCLAY: Write what happens next • ADD entities/objects • REMOVE elements • Transform states • Introduce complications • Resolve obstacles • The world is malleable | Tap messages to fork • Use snapshots to time-travel');
          } else if (action === 'theme') {
            const idx = themes.findIndex(t => t.id === appState.theme);
            const next = themes[(idx + 1) % themes.length];
            applyTheme(next.id);
            showHelpBanner(`Theme switched to ${themes.find(t => t.id === appState.theme)?.label || 'CRT GREEN'}.`);
          } else if (action === 'fullscreen') {
            if (!document.fullscreenElement) {
              document.body.requestFullscreen().catch(err => console.warn('Fullscreen failed:', err));
            } else {
              document.exitFullscreen();
            }
          } else if (action === 'reset') {
            if (confirm('Reset all chats? This will delete all channels and create a fresh blank scenario. This cannot be undone.')) {
              // Clear all channels
              appState.channels = [];
              appState.snapshots = [];
              appState.ringMemory = [];
              appState.currentChannelId = null;
              
              // Clear DOM
              channelMap.clear();
              document.getElementById('channelRail').innerHTML = '';
              document.getElementById('timelineDots').innerHTML = '';
              document.getElementById('ringBar').innerHTML = '';
              document.getElementById('ringContext').style.display = 'none';
              
              // Create fresh blank channel
              const blank = createChannel({ scenario: 'blank', name: 'BLANK SIM' });
              appState.currentChannelId = blank.id;
              setTimeout(() => focusChannel(blank.id), 100);
              
              // Persist and refresh
              persistState();
              renderTimeline();
              refreshAllChannels();
              renderRingBar();
              
              showHelpBanner('All chats reset. Fresh blank scenario ready.');
            }
          }
          infoMenu.classList.remove('visible');
        });
      });
      infoMenu.addEventListener('click', (event) => event.stopPropagation());

      const exchangeBtn = document.getElementById('cornerExchange');
      const exchangeMenu = document.getElementById('exchangeMenu');
      exchangeBtn.addEventListener('click', (event) => {
        event.stopPropagation();
        toggleMenu(exchangeMenu);
      });
      exchangeMenu.querySelectorAll('button').forEach(btn => {
        btn.addEventListener('click', (event) => {
          const action = event.currentTarget.getAttribute('data-action');
          if (action === 'export') {
            document.getElementById('exportOverlay').classList.add('active');
          } else if (action === 'import') {
            importInput.click();
          }
          exchangeMenu.classList.remove('visible');
        });
      });
      exchangeMenu.addEventListener('click', (event) => event.stopPropagation());

      // Initialize global footer
      const globalScenarioSelect = document.getElementById('globalScenarioSelect');
      const globalTetradBtn = document.getElementById('globalTetradBtn');

      // Populate scenario selector with categories
      const scenarioCategories = {
        'MEDIA THEORY': ['blank', 'microdrama', 'social_media', 'cryptocurrency', 'video_call', 'podcast', 'ai_assistant'],
        'MEDICAL TRAINING': ['migraine', 'cocaine_intox', 'organophosphate', 'copd', 'aortic_stenosis', 'medical_general'],
        'DIGITAL HUMANITIES': ['printscholar', 'digitalscholar', 'administrator', 'student', 'telegraph', 'attention', 'collaboration', 'extendedcog'],
        '1000 LIVES UNIVERSE': ['chalice', 'z', 'thousand', 'nye2074', 'bob', 'plots'],
        'TECH ETHICS': ['maya', 'dev'],
        'BLACK METAL': ['florilegia', 'companion180', 'darkvoyage', 'traininggrounds'],
        'EKPHRASTIC POETRY': ['stevensjar', 'achillesshield'],
        'CULTURAL THEORY': ['bartheswrestling', 'benjaminangel', 'sankofabird'],
        'NOVEL SYSTEMS': ['chessposition', 'psychogeo', 'fermentation', 'ritualspace', 'gentrification'],
        'MYTHIC+TECHNICAL': ['towerdefense', 'babel', 'sisyphus', 'labyrinth', 'orpheus'],
        'ANIMATED SERIES': ['mouseofsilver', 'hunterswithout', 'talesbasingse', 'sozinscomet'],
        'FAMOUS PERSUASION': ['hal9000', 'dobby', 'cyclops', 'herfinale', 'twelveangryman8']
      };
      
      Object.entries(scenarioCategories).forEach(([category, scenarioIds]) => {
        const optgroup = document.createElement('optgroup');
        optgroup.label = category;
        scenarioIds.forEach(id => {
          if (scenarios[id]) {
            const option = document.createElement('option');
            option.value = id;
            const displayName = scenarios[id].name.length > 18 ? scenarios[id].name.substring(0, 17) + '\u2026' : scenarios[id].name;
            option.textContent = displayName.toUpperCase();
            optgroup.appendChild(option);
          }
        });
        globalScenarioSelect.appendChild(optgroup);
      });

      // Update scenario for active channel
      globalScenarioSelect.addEventListener('change', () => {
        const activeChannel = appState.channels.find(ch => ch.id === appState.currentChannelId);
        if (activeChannel) {
          setChannelScenario(activeChannel, globalScenarioSelect.value);
          if (activeChannel.dom?.lineageEl) {
            activeChannel.dom.lineageEl.textContent = `${scenarios[activeChannel.scenario].name.toUpperCase()} \u00b7 ${scenarios[activeChannel.scenario].role}`;
          }
        }
      });
      
      // Tetrad button - opens perspective selector (tetrad auto-generates)
      globalTetradBtn.addEventListener('click', () => {
        const activeChannel = appState.channels.find(ch => ch.id === appState.currentChannelId);
        if (activeChannel) {
          openPerspectiveSelector(activeChannel);
        }
      });
      

      document.getElementById('confirmExport').addEventListener('click', exportState);

      document.addEventListener('click', () => {
        infoMenu.classList.remove('visible');
        exchangeMenu.classList.remove('visible');
      });

      document.querySelectorAll('.ring-context-btn').forEach(btn => {
        btn.addEventListener('click', (event) => {
          event.stopPropagation();
          const mode = btn.getAttribute('data-mode');
          setRingContextMode(mode);
        });
      });

      const ringMainBtn = document.getElementById('ringSetMainline');
      if (ringMainBtn) {
        ringMainBtn.addEventListener('click', (event) => {
          event.stopPropagation();
          const targetId = ringMainBtn.dataset.entryId || ringMemory.contextAnchor;
          if (!targetId) return;
          ringMemory.mainline = targetId;
          renderRingBar();
          renderRingContext();
          syncRingContextButtons();
          persistState();
          showHelpBanner(`Mainline locked: ${targetId}`);
        });
      }

      applyTheme(appState.theme);
    }

    function showHelpBanner(text) {
      const existing = document.querySelector('.help-banner');
      if (existing) existing.remove();
      const banner = document.createElement('div');
      banner.className = 'help-banner';
      banner.textContent = text;
      banner.style.position = 'fixed';
      banner.style.left = '50%';
      banner.style.bottom = '24px';
      banner.style.transform = 'translateX(-50%)';
      banner.style.background = 'var(--panel)';
      banner.style.border = '1px solid var(--border)';
      banner.style.padding = '12px 18px';
      banner.style.letterSpacing = '0.2em';
      banner.style.fontSize = '8px';
      banner.style.color = 'var(--text)';
      banner.style.zIndex = '30';
      banner.style.borderRadius = '4px';
      banner.style.boxShadow = '0 12px 32px var(--shadow)';
      document.body.appendChild(banner);
      setTimeout(() => banner.remove(), 3200);
    }

    function toggleMenu(menu) {
      if (!menu) return;
      const alreadyVisible = menu.classList.contains('visible');
      document.querySelectorAll('.corner-menu.visible').forEach(item => item.classList.remove('visible'));
      if (!alreadyVisible) {
        menu.classList.add('visible');
      }
    }

    function applyTheme(themeId) {
      themes.forEach(theme => document.body.classList.remove(theme.id));
      document.body.classList.add(themeId);
      appState.theme = themeId;
      localStorage.setItem('legos/multiChannelTheme', themeId);
      updateThemeButtonLabel();
    }

    function updateThemeButtonLabel() {
      if (!themeButtonRef) return;
      const meta = themes.find(t => t.id === appState.theme) || themes[0];
      themeButtonRef.textContent = `THEME · ${meta.label}`;
    }

    function loadState() {
      try {
        const raw = localStorage.getItem('legos/multiChannelState');
        if (!raw) return;
        const data = JSON.parse(raw);
        (data.channels || []).forEach(cfg => {
          const channel = new Channel(cfg);
          channel.name = resolveChannelName(channel.name, channel.scenario, channel.symbolicId);
          if (!channel.channelColor) {
            channel.channelColor = nextChannelColor();
          }
          const numeric = parseInt((channel.symbolicId || '').replace(/[^0-9]/g, ''), 10);
          if (!Number.isNaN(numeric)) {
            channelSequence = Math.max(channelSequence, numeric + 1);
          }
          channelMap.set(channel.id, channel);
          appState.channels.push(channel);
          mountChannel(channel);
        });
        channelColorIndex = appState.channels.length % channelColorPalette.length;
        appState.currentChannelId = data.currentChannelId || (appState.channels[0]?.id ?? null);
        if (data.ring) {
          const restoredEntries = (data.ring.entries || []).map(entry => ({
            ...entry,
            channelName: sanitizeHandle(entry.channelName || 'GLOBAL', 'GLOBAL'),
            symbol: sanitizeHandle(entry.symbol || entry.channelName || 'ENTRY', 'ENTRY'),
            type: sanitizeHandle(entry.type || 'NOTE', 'NOTE')
          }));
          ringMemory.entries = restoredEntries.slice(-ringMemory.capacity);
          ringMemory.mainline = data.ring.mainline || null;
          ringMemory.contextMode = data.ring.contextMode || 'all';
          ringMemory.contextAnchor = data.ring.contextAnchor
            || ringMemory.entries[ringMemory.entries.length - 1]?.id
            || null;
          const storedCounter = parseInt(data.ring.counter, 10);
          if (Number.isFinite(storedCounter) && storedCounter > ringEntryCounter) {
            ringEntryCounter = storedCounter;
          } else if (ringMemory.entries.length && !storedCounter) {
            const numeric = ringMemory.entries
              .map(entry => parseInt(String(entry.id).replace(/[^0-9]/g, ''), 10))
              .filter(Number.isFinite);
            if (numeric.length) {
              ringEntryCounter = Math.max(...numeric) + 1;
            }
          }
        }
      } catch (err) {
        console.error('Failed to load state', err);
        localStorage.removeItem('legos/multiChannelState');
      }
    }

    function persistState() {
      const payload = {
        currentChannelId: appState.currentChannelId,
        channels: appState.channels.map(ch => ch.serialize()),
        ring: {
          entries: ringMemory.entries,
          mainline: ringMemory.mainline,
          contextMode: ringMemory.contextMode,
          contextAnchor: ringMemory.contextAnchor,
          counter: ringEntryCounter
        }
      };
      localStorage.setItem('legos/multiChannelState', JSON.stringify(payload));
    }

    function createChannel(config = {}) {
      const payload = { ...config };
      if (!payload.symbolicId) {
        payload.symbolicId = generateSymbolicId();
      }
      if (!payload.channelColor) {
        payload.channelColor = nextChannelColor();
      }
      payload.name = resolveChannelName(payload.name, payload.scenario || 'blank', payload.symbolicId);
      const channel = new Channel(payload);
      channelMap.set(channel.id, channel);
      appState.channels.push(channel);
      mountChannel(channel);
      appState.currentChannelId = channel.id;
      persistState();
      return channel;
    }

    function mountChannel(channel) {
      const scroller = document.getElementById('channelScroller');
      const column = document.createElement('section');
      column.className = 'channel-column';
      column.dataset.channelId = channel.id;

      const header = document.createElement('div');
      header.className = 'channel-head';

      const meta = document.createElement('div');
      meta.className = 'channel-meta';
      const name = document.createElement('div');
      name.className = 'channel-name';
      const lineage = document.createElement('div');
      lineage.className = 'channel-lineage';
      meta.appendChild(name);
      meta.appendChild(lineage);

      const actions = document.createElement('div');
      actions.className = 'channel-actions';

      const ringOverviewBtn = document.createElement('button');
      ringOverviewBtn.className = 'channel-btn';
      ringOverviewBtn.title = 'Ring Memory Overview';
      ringOverviewBtn.textContent = '◎';
      ringOverviewBtn.addEventListener('click', (event) => {
        event.stopPropagation();
        openRingOverview(channel);
      });

      const snapshotBtn = document.createElement('button');
      snapshotBtn.className = 'channel-btn';
      snapshotBtn.title = 'Snapshots';
      snapshotBtn.textContent = '⧉';
      snapshotBtn.addEventListener('click', (event) => {
        event.stopPropagation();
        openSnapshotOverlay(channel);
      });

      const gridToggleBtn = document.createElement('button');
      gridToggleBtn.className = 'channel-btn';
      gridToggleBtn.title = 'Toggle grid';
      gridToggleBtn.textContent = '▲';

      const collapseBtn = document.createElement('button');
      collapseBtn.className = 'channel-btn';
      collapseBtn.title = 'Collapse column';
      collapseBtn.textContent = '‹';
      
      // Add expand tab for collapsed state
      const expandTab = document.createElement('div');
      expandTab.className = 'channel-expand-tab';
      expandTab.style.cssText = `
        position: absolute;
        left: 52px;
        top: 50%;
        transform: translateY(-50%);
        width: 32px;
        height: 100px;
        background: var(--panel);
        border: 2px solid var(--border);
        border-left: none;
        border-radius: 0 8px 8px 0;
        display: none;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 4px;
        cursor: pointer;
        z-index: 50;
        box-shadow: 2px 0 8px var(--shadow);
        transition: all 0.2s var(--transition);
      `;
      
      const expandDot = document.createElement('div');
      expandDot.style.cssText = `
        width: 10px;
        height: 10px;
        border-radius: 50%;
        background: ${channel.channelColor};
        border: 1px solid var(--border);
      `;
      
      const expandArrow = document.createElement('div');
      expandArrow.style.cssText = `
        font-size: 16px;
        color: var(--text-muted);
      `;
      expandArrow.textContent = '›';
      
      expandTab.appendChild(expandDot);
      expandTab.appendChild(expandArrow);
      
      expandTab.addEventListener('mouseenter', () => {
        expandTab.style.background = 'var(--accent)';
        expandArrow.style.color = 'var(--bg)';
      });
      
      expandTab.addEventListener('mouseleave', () => {
        expandTab.style.background = 'var(--panel)';
        expandArrow.style.color = 'var(--text-muted)';
      });
      
      expandTab.addEventListener('click', () => {
        column.classList.remove('collapsed');
        channel.collapsed = false;
        collapseBtn.textContent = '‹';
        expandTab.style.display = 'none';
        persistState();
      });
      column.appendChild(expandTab);
      
      // Update collapse button to show/hide expand tab
      collapseBtn.addEventListener('click', () => {
        column.classList.toggle('collapsed');
        channel.collapsed = column.classList.contains('collapsed');
        collapseBtn.textContent = channel.collapsed ? '›' : '‹';
        expandTab.style.display = channel.collapsed ? 'flex' : 'none';
        persistState();
      });
      
      if (channel.collapsed) {
        column.classList.add('collapsed');
        collapseBtn.textContent = '›';
        expandTab.style.display = 'flex';
      }

      const resetBtn = document.createElement('button');
      resetBtn.className = 'channel-btn';
      resetBtn.title = 'Reset channel';
      resetBtn.textContent = '↺';
      resetBtn.addEventListener('click', (event) => {
        event.stopPropagation();
        if (!confirm('Clear grid, history, and snapshots for this channel?')) return;
        channel.resetState();
        if (snapshotOverlayChannel === channel) {
          snapshotOverlayChannel = null;
          const overlay = document.getElementById('snapshotOverlay');
          if (overlay) overlay.classList.remove('active');
        }
        addMessageToChannel(channel, 'system', 'Channel reset. Start a fresh beat.');
        renderChannel(channel);
        persistState();
      });
      
      // Tetrad mode toggle button
      const tetradToggleBtn = document.createElement('button');
      tetradToggleBtn.className = 'channel-btn';
      tetradToggleBtn.title = channel.tetradMode ? 'Tetrad Mode: ON (click to disable)' : 'Tetrad Mode: OFF (click to enable)';
      tetradToggleBtn.textContent = '⋔';
      tetradToggleBtn.style.fontWeight = channel.tetradMode ? '900' : '400';
      tetradToggleBtn.style.opacity = channel.tetradMode ? '1' : '0.5';
      tetradToggleBtn.addEventListener('click', (event) => {
        event.stopPropagation();
        channel.tetradMode = !channel.tetradMode;
        tetradToggleBtn.title = channel.tetradMode ? 'Tetrad Mode: ON (click to disable)' : 'Tetrad Mode: OFF (click to enable)';
        tetradToggleBtn.style.fontWeight = channel.tetradMode ? '900' : '400';
        tetradToggleBtn.style.opacity = channel.tetradMode ? '1' : '0.5';
        
        const status = channel.tetradMode ? 'ENABLED' : 'DISABLED';
        const msg = channel.tetradMode 
          ? '⋔ TETRAD MODE ENABLED\n\nAll new scenes will automatically generate tetrad analysis.'
          : '⋔ TETRAD MODE DISABLED\n\nScenes will generate normally without tetrad.';
        addMessageToChannel(channel, 'system', msg);
        persistState();
      });
      
      actions.appendChild(gridToggleBtn);
      actions.appendChild(ringOverviewBtn);
      actions.appendChild(snapshotBtn);
      actions.appendChild(tetradToggleBtn);
      actions.appendChild(resetBtn);
      actions.appendChild(collapseBtn);

      header.appendChild(meta);
      header.appendChild(actions);

      const body = document.createElement('div');
      body.className = 'channel-body';

      const gridSection = document.createElement('div');
      gridSection.className = 'grid-section';
      // Ensure grid is fully visible by default
      gridSection.style.display = 'flex';
      gridSection.style.opacity = '1';
      
      // Grid toggle button event handler
      let gridCollapsed = false;
      gridToggleBtn.addEventListener('click', () => {
        gridCollapsed = !gridCollapsed;
        gridSection.style.transition = 'all 0.4s cubic-bezier(0.4, 0, 0.2, 1)';
        
        if (gridCollapsed) {
          // Animate cells before collapse
          const cells = gridSection.querySelectorAll('.grid-cell');
          cells.forEach((cell, idx) => {
            cell.style.transition = 'transform 0.3s ease, opacity 0.3s ease';
            cell.style.transitionDelay = `${idx * 0.01}s`;
            cell.style.transform = 'scale(0.8)';
            cell.style.opacity = '0';
          });
          
          setTimeout(() => {
            gridSection.style.maxHeight = '0';
            gridSection.style.padding = '0';
            gridSection.style.opacity = '0';
            gridSection.style.overflow = 'hidden';
            gridToggleBtn.textContent = '▼';
            body.classList.add('grid-collapsed');
          }, 200);
        } else {
          gridSection.style.maxHeight = '';
          gridSection.style.padding = '';
          gridSection.style.opacity = '';
          gridSection.style.overflow = '';
          gridToggleBtn.textContent = '▲';
          body.classList.remove('grid-collapsed');
          
          // Animate cells on expand
          setTimeout(() => {
            const cells = gridSection.querySelectorAll('.grid-cell');
            cells.forEach((cell, idx) => {
              cell.style.transform = '';
              cell.style.opacity = '';
              cell.style.transitionDelay = `${idx * 0.01}s`;
            });
          }, 100);
        }
      });
      
      const gridHeader = document.createElement('div');
      gridHeader.className = 'grid-header';
      const gridTitle = document.createElement('div');
      gridTitle.className = 'grid-title';
      gridTitle.textContent = 'NARRATIVE GRID';

      gridHeader.appendChild(gridTitle);

      const gridArea = document.createElement('div');
      gridArea.className = 'grid-area';
      const channelNumberRail = document.createElement('div');
      channelNumberRail.className = 'channel-number-rail';
      gridArea.appendChild(channelNumberRail);

      const gridWrapper = document.createElement('div');
      gridWrapper.className = 'grid-wrapper';
      const grid = document.createElement('div');
      grid.className = 'grid';
      gridWrapper.appendChild(grid);
      gridArea.appendChild(gridWrapper);

      gridSection.appendChild(gridHeader);
      gridSection.appendChild(gridArea);

      const chatSection = document.createElement('div');
      chatSection.className = 'chat-section';
      const chatStream = document.createElement('div');
      chatStream.className = 'chat-stream';
      const messageDotRail = document.createElement('div');
      messageDotRail.className = 'message-dot-rail';
      const messageList = document.createElement('div');
      messageList.className = 'message-list';
      chatStream.appendChild(messageDotRail);
      chatStream.appendChild(messageList);

      const inputSection = document.createElement('div');
      inputSection.className = 'input-section';
      
      const inputWrapper = document.createElement('div');
      inputWrapper.className = 'input-wrapper';
      const textarea = document.createElement('textarea');
      textarea.className = 'message-input';
      textarea.rows = 3;
      textarea.placeholder = 'Start or transform the scene…';
      const sendBtn = document.createElement('button');
      sendBtn.className = 'send-btn';
      sendBtn.textContent = 'SEND';

      textarea.addEventListener('input', () => {
        textarea.style.height = 'auto';
        textarea.style.height = Math.min(textarea.scrollHeight, 120) + 'px';
        
        // Keep input visible while typing on mobile
        if (window.visualViewport && document.activeElement === textarea) {
          setTimeout(() => {
            inputSection.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
          }, 50);
        }
      });
      textarea.addEventListener('focus', () => {
        focusChannel(channel.id);
        
        // Mobile keyboard handling - scroll input into view
        setTimeout(() => {
          // Scroll the input section into view when keyboard appears
          inputSection.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
          
          // For iOS Safari - ensure input is visible above keyboard
          if (window.visualViewport) {
            const viewportHeight = window.visualViewport.height;
            const inputRect = textarea.getBoundingClientRect();
            
            // If input is below viewport, scroll it up
            if (inputRect.bottom > viewportHeight) {
              const scrollAmount = inputRect.bottom - viewportHeight + 20;
              window.scrollBy(0, scrollAmount);
            }
          }
        }, 300); // Wait for keyboard animation
      });
      textarea.addEventListener('keydown', (event) => {
        if (event.key === 'Enter' && !event.shiftKey) {
          event.preventDefault();
          sendBtn.click();
        }
      });

      sendBtn.addEventListener('click', () => {
        const value = textarea.value.trim();
        if (!value) return;
        
        // Check for tetrad mode toggle first
        if (value.match(/^\/tetrad\s+(on|off)$/i)) {
          const tetradMatch = value.match(/^\/tetrad\s+(on|off)$/i);
          const mode = tetradMatch[1].toLowerCase();
          
          addMessageToChannel(channel, 'user', value);
          textarea.value = '';
          textarea.style.height = 'auto';
          
          if (mode === 'on') {
            channel.tetradMode = true;
            addMessageToChannel(channel, 'system', '⋔ TETRAD MODE ENABLED\n\nAll new scenes will automatically generate tetrad analysis. Use `/tetrad off` to disable.');
          } else {
            channel.tetradMode = false;
            addMessageToChannel(channel, 'system', '⋔ TETRAD MODE DISABLED\n\nScenes will generate normally without tetrad. Use `/tetrad on` to re-enable.');
          }
          
          persistState();
          return;
        }
        
        // Check for cultural engine commands (including runtime modifiers, framework modes, and comparison)
        const culturalCmd = value.match(/^\/(pragmatic|structural|reflexive|bdi|epstein|rebeland|iruba|ccim|axelrod|schelling|compare\s+snapshot|compare\s+analyze|compare\s+help|cultural\s+stop|cultural\s+help|cultural\s+play|cultural\s+pause|cultural\s+spawn|cultural\s+legitimacy|cultural\s+spawn-rebels|cultural\s+spawn-cops|cultural\s+crackdown|cultural\s+uprising|cultural\s+lab)\s*(.*)/i);
        if (culturalCmd) {
          const mode = culturalCmd[1].toLowerCase();
          const promptText = culturalCmd[2] || value;
          
          addMessageToChannel(channel, 'user', value);
          textarea.value = '';
          textarea.style.height = 'auto';
          
          if (mode === 'cultural help') {
            addMessageToChannel(channel, 'system', 
              `**Cultural Dynamics Engine - Commands**\n\n` +
              `**Setup:**\n` +
              `• \`/cultural spawn [description]\` - Generate scene + start simulation\n` +
              `• \`/cultural lab\` - 🧪 Open research lab interface\n\n` +
              `**Theoretical Layers:**\n` +
              `• \`/pragmatic\` - Obeyesekere (instrumental rationality)\n` +
              `• \`/structural\` - Sahlins (symbolic cosmos)\n` +
              `• \`/reflexive\` - Geertz (interpretive entanglement)\n\n` +
              `**ABM Frameworks:**\n` +
              `• \`/bdi\` - Belief-Desire-Intention reasoning (Bratman 1987)\n` +
              `• \`/epstein\` - Civil Violence Model (Epstein 2002)\n` +
              `• \`/rebeland\` - MASON RebeLand (Cioffi-Revilla)\n` +
              `• \`/iruba\` - Insurgency Resource Battle (Doran)\n` +
              `• \`/ccim\` - Cross-Cultural Interaction (Green)\n` +
              `• \`/axelrod\` - Cultural Dissemination (Axelrod 1997)\n` +
              `• \`/schelling\` - Segregation Model (Schelling 1971)\n\n` +
              `**Control:**\n` +
              `• \`/cultural play\` / \`/cultural pause\` - Control animation\n` +
              `• \`/cultural stop\` - Stop and restore grid\n\n` +
              `**Live Modifications:**\n` +
              `• \`/cultural legitimacy 0.7\` - Set government legitimacy\n` +
              `• \`/cultural spawn-rebels 5\` - Add rebels\n` +
              `• \`/cultural spawn-cops 3\` - Deploy cops\n` +
              `• \`/cultural crackdown\` - Violent suppression\n` +
              `• \`/cultural uprising\` - Mass radicalization\n\n` +
              `**Natural Language:**\n` +
              `• "Add 5 rebels" / "Deploy 3 cops"\n` +
              `• "Set legitimacy to 30%"\n` +
              `• "Crackdown" / "Uprising" / "Pause"\n\n` +
              `**Diffractive Comparison (Barad):**\n` +
              `• \`/compare snapshot\` - Capture Configuration A\n` +
              `• \`/compare analyze\` - Compare two configurations\n` +
              `• \`/compare help\` - Full diffractive methodology guide\n\n` +
              `**Features:**\n` +
              `• LEGOS-aware: Narrative drives cultural roles\n` +
              `• BDI reasoning: Agents form beliefs/desires/intentions\n` +
              `• Multiple frameworks: Switch mid-simulation\n` +
              `• Diffractive analysis: Compare emergent patterns\n` +
              `• Cell logs (last 10 events) + entity details`
            );
            textarea.value = '';
            textarea.style.height = 'auto';
            return;
          }
          
          if (mode === 'cultural spawn') {
            // Spawn scene via AI, then activate cultural mode
            if (!promptText) {
              addMessageToChannel(channel, 'system', '⚠️ Provide a scene description after `/cultural spawn`.\n\nExample: `/cultural spawn Cook encounters Hawaiians during Makahiki`');
              return;
            }
            
            if (!appState.apiKey) {
              addMessageToChannel(channel, 'system', '⚠️ API key required. Set via ◎ button.');
              return;
            }
            
            addMessageToChannel(channel, 'system', `🎬 Spawning scene: "${promptText}"\n\nGenerating via AI, then activating pragmatic layer...`);
            
            // Generate scene first
            composeScene(channel, promptText).then(() => {
              // After scene is generated, activate cultural mode
              setTimeout(() => {
                channel.culturalMode = 'pragmatic';
                channel.culturalParams = seedCulturalParams(promptText);
                
                const ontology = generateSceneOntology(channel);
                if (ontology.derivedParams) {
                  channel.culturalParams.pragmatic.legitimacy = ontology.derivedParams.legitimacy;
                  channel.culturalParams.pragmatic.copEffectiveness = ontology.derivedParams.copEffectiveness;
                }
                
                initCulturalAgents(channel, 0.75);
                channel.culturalTick = 0;
                channel.sceneOntology = ontology;
                channel.culturalAnimating = true;
                
                renderChannelGrid(channel); // Show LEGOS entities first
                renderCulturalGrid(channel); // Then cultural enhancements
                tickCulturalSimulation(channel);
                
                addMessageToChannel(channel, 'system', 
                  `✅ Scene generated + Cultural engine activated!\n` +
                  `Ontology: ${ontology.entities.length} entities, ${ontology.authorities.length} authorities.\n` +
                  `Agents: ${Object.keys(channel.culturalAgents).length}/81. Simulation running.`
                );
                
                persistState();
              }, 1000); // Wait for scene to render
            }).catch(err => {
              addMessageToChannel(channel, 'system', `❌ Scene generation failed: ${err.message}`);
            });
            
            return;
          }
          
          if (mode === 'cultural play') {
            // Resume simulation
            if (!channel.culturalMode) {
              addMessageToChannel(channel, 'system', '⚠️ No cultural mode active. Use `/pragmatic`, `/structural`, or `/reflexive` first.');
              return;
            }
            channel.culturalAnimating = true;
            addMessageToChannel(channel, 'system', `▶️ Cultural simulation resumed in **${channel.culturalMode}** mode.`);
            tickCulturalSimulation(channel);
            persistState();
            return;
          }
          
          if (mode === 'cultural pause') {
            // Pause simulation
            channel.culturalAnimating = false;
            addMessageToChannel(channel, 'system', `⏸️ Cultural simulation paused. Use \`/cultural play\` to resume.`);
            persistState();
            return;
          }
          
          if (mode === 'cultural stop') {
            // Stop cultural simulation
            channel.culturalAnimating = false;
            channel.culturalMode = null;
            addMessageToChannel(channel, 'system', '⊗ Cultural simulation stopped. Grid restored to default mode.');
            // Clear grid back to medical view
            if (channel.lastScene) {
              renderChannelGrid(channel);
            }
            persistState();
            return;
          }
          
          // RUNTIME MODIFICATION COMMANDS (work during active simulation)
          if (mode === 'cultural legitimacy') {
            if (!channel.culturalParams) {
              addMessageToChannel(channel, 'system', '⚠️ No active simulation. Start one first.');
              return;
            }
            const newLegitimacy = parseFloat(promptText);
            if (isNaN(newLegitimacy) || newLegitimacy < 0 || newLegitimacy > 1) {
              addMessageToChannel(channel, 'system', '⚠️ Legitimacy must be 0-1. Example: `/cultural legitimacy 0.7`');
              return;
            }
            channel.culturalParams.pragmatic.legitimacy = newLegitimacy;
            addMessageToChannel(channel, 'system', `📊 Legitimacy set to ${(newLegitimacy * 100).toFixed(0)}%`);
            persistState();
            return;
          }
          
          if (mode === 'cultural spawn-rebels') {
            if (!channel.culturalParams || !channel.culturalAgents) {
              addMessageToChannel(channel, 'system', '⚠️ No active simulation.');
              return;
            }
            let count = parseInt(promptText) || 3;
            let spawned = 0;
            for (let y = 0; y < 9 && spawned < count; y++) {
              for (let x = 0; x < 9 && spawned < count; x++) {
                if (!channel.grid[y][x]) {
                  const id = `cultural-rebel-spawn-${Date.now()}-${spawned}`;
                  const entity = {
                    id,
                    name: `Rebel ${spawned + 1}`,
                    type: 'Goal',
                    culturalType: 'rebel',
                    culturalBeliefs: { utility: 0.3, symbolic: Math.random(), reflexive: Math.random() },
                    culturalTraits: { hardship: 0.9, riskAversion: 0.2, social: 0.8 },
                    perspective: 'A newly radicalized rebel joining the uprising.'
                  };
                  channel.grid[y][x] = { id, type: 'Goal', symbol: '▲', label: entity.name, entity };
                  const key = `${x}_${y}`;
                  channel.culturalAgents[key] = {
                    type: 'rebel',
                    legosCellRef: channel.grid[y][x],
                    beliefs: entity.culturalBeliefs,
                    traits: entity.culturalTraits,
                    energy: 1.0,
                    fear: 0.5,
                    perceivedRisk: 0,
                    memory: []
                  };
                  logCellEvent(channel, x, y, `Rebel spawned via command`);
                  spawned++;
                }
              }
            }
            addMessageToChannel(channel, 'system', `🔥 Spawned ${spawned} rebels. Uprising intensifies!`);
            renderChannelGrid(channel);
            renderCulturalGrid(channel);
            persistState();
            return;
          }
          
          if (mode === 'cultural spawn-cops') {
            if (!channel.culturalParams || !channel.culturalAgents) {
              addMessageToChannel(channel, 'system', '⚠️ No active simulation.');
              return;
            }
            let count = parseInt(promptText) || 3;
            let spawned = 0;
            for (let y = 0; y < 9 && spawned < count; y++) {
              for (let x = 0; x < 9 && spawned < count; x++) {
                if (!channel.grid[y][x]) {
                  const id = `cultural-cop-spawn-${Date.now()}-${spawned}`;
                  const entity = {
                    id,
                    name: `Cop ${spawned + 1}`,
                    type: 'Obstacle',
                    culturalType: 'cop',
                    culturalBeliefs: { utility: 0.9, symbolic: Math.random(), reflexive: Math.random() },
                    culturalTraits: { hardship: 0.1, riskAversion: 0.2, social: 0.7 },
                    perspective: 'A reinforcement cop deployed to restore order.'
                  };
                  channel.grid[y][x] = { id, type: 'Obstacle', symbol: '◆', label: entity.name, entity };
                  const key = `${x}_${y}`;
                  channel.culturalAgents[key] = {
                    type: 'cop',
                    legosCellRef: channel.grid[y][x],
                    beliefs: entity.culturalBeliefs,
                    traits: entity.culturalTraits,
                    energy: 1.0,
                    fear: 0,
                    perceivedRisk: 0,
                    memory: []
                  };
                  logCellEvent(channel, x, y, `Cop reinforcement deployed`);
                  spawned++;
                }
              }
            }
            addMessageToChannel(channel, 'system', `👮 Deployed ${spawned} cops. Crackdown imminent!`);
            renderChannelGrid(channel);
            renderCulturalGrid(channel);
            persistState();
            return;
          }
          
          if (mode === 'cultural crackdown') {
            if (!channel.culturalParams) {
              addMessageToChannel(channel, 'system', '⚠️ No active simulation.');
              return;
            }
            // Temporarily boost cop effectiveness and reduce legitimacy
            channel.culturalParams.pragmatic.copEffectiveness *= 1.5;
            channel.culturalParams.pragmatic.legitimacy *= 0.7;
            addMessageToChannel(channel, 'system', 
              `🚨 CRACKDOWN INITIATED!\n` +
              `Cop effectiveness increased 50%. Legitimacy reduced 30%. Fear spreads...`
            );
            persistState();
            return;
          }
          
          if (mode === 'cultural uprising') {
            if (!channel.culturalParams || !channel.culturalAgents) {
              addMessageToChannel(channel, 'system', '⚠️ No active simulation.');
              return;
            }
            // Boost citizen hardship, reduce legitimacy
            channel.culturalParams.pragmatic.legitimacy *= 0.5;
            Object.values(channel.culturalAgents).forEach(agent => {
              if (agent.type === 'citizen') {
                agent.traits.hardship = Math.min(1, agent.traits.hardship + 0.3);
              }
            });
            addMessageToChannel(channel, 'system',
              `⚡ UPRISING in response to: "${value}"\n` +
              `Citizen hardship +30%, Legitimacy halved. Revolution stirs...`
            );
            persistState();
            return;
          }
          
          // Framework mode switching
          if (mode === 'bdi') {
            if (!channel.culturalParams || !channel.culturalAgents) {
              addMessageToChannel(channel, 'system', '⚠️ Start simulation first with `/cultural spawn [scene]`');
              return;
            }
            channel.culturalParams.useBDI = true;
            channel.culturalParams.framework = 'bdi';
            
            // Convert existing agents to BDI agents
            Object.entries(channel.culturalAgents).forEach(([key, agent]) => {
              const [x, y] = key.split('_').map(Number);
              agent.bdiAgent = new BDIAgent([x, y], agent.type, agent.legosCellRef);
            });
            
            addMessageToChannel(channel, 'system', 
              `🧠 **BDI Framework Activated**\n\n` +
              `Agents now use Belief-Desire-Intention reasoning (Bratman 1987).\n\n` +
              `**BDI Components:**\n` +
              `• Beliefs: Perceived threats, allies, legitimacy\n` +
              `• Desires: Goals based on type and symbolic role\n` +
              `• Intentions: Committed actions (flee, approach ally, suppress)\n\n` +
              `LEGOS perspectives influence belief formation and desire generation.`
            );
            persistState();
            return;
          }
          
          if (mode === 'epstein') {
            if (!channel.culturalParams) {
              addMessageToChannel(channel, 'system', '⚠️ Start simulation first');
              return;
            }
            channel.culturalParams.framework = 'epstein';
            channel.culturalParams.useBDI = false;
            addMessageToChannel(channel, 'system', 
              `⚡ **Epstein Civil Violence Model**\n\n` +
              `Classic agent-based rebellion model.\n` +
              `• Grievance = Hardship × (1 - Legitimacy)\n` +
              `• Risk = CopDensity × CopEffectiveness\n` +
              `• Rebel if: Grievance > Risk + Threshold`
            );
            persistState();
            return;
          }
          
          if (mode === 'rebeland') {
            if (!channel.culturalParams) {
              addMessageToChannel(channel, 'system', '⚠️ Start simulation first');
              return;
            }
            channel.culturalParams.framework = 'rebeland';
            addMessageToChannel(channel, 'system',
              `🏛️ **MASON RebeLand Model**\n\n` +
              `Political systems & insurgency dynamics.\n` +
              `• Resource availability affects rebellion\n` +
              `• Institutional strength modulates legitimacy\n` +
              `• Social networks shape recruitment\n` +
              `• Geographic terrain influences tactics`
            );
            persistState();
            return;
          }
          
          if (mode === 'iruba') {
            if (!channel.culturalParams) {
              addMessageToChannel(channel, 'system', '⚠️ Start simulation first');
              return;
            }
            channel.culturalParams.framework = 'iruba';
            addMessageToChannel(channel, 'system',
              `⚔️ **IRUBA (Insurgency Resource-Utilization Battle)**\n\n` +
              `Counterinsurgency operations model.\n` +
              `• Collateral damage → Civilian anger → Recruitment\n` +
              `• Fear/Anger drive civilian allegiance shifts\n` +
              `• Terrain affects insurgent safe havens\n` +
              `• Resource allocation determines control`
            );
            persistState();
            return;
          }
          
          if (mode === 'ccim') {
            if (!channel.culturalParams) {
              addMessageToChannel(channel, 'system', '⚠️ Start simulation first');
              return;
            }
            channel.culturalParams.framework = 'ccim';
            addMessageToChannel(channel, 'system',
              `🌍 **CCIM (Cross-Cultural Interaction Model)**\n\n` +
              `Historical cultural exchange simulation.\n` +
              `• Trade openness enables cultural hybridization\n` +
              `• Assimilation pressure shapes boundaries\n` +
              `• Conflict propensity at cultural borders\n` +
              `• Emergent hybrid zones form over time`
            );
            persistState();
            return;
          }
          
          if (mode === 'axelrod') {
            if (!channel.culturalParams) {
              addMessageToChannel(channel, 'system', '⚠️ Start simulation first');
              return;
            }
            channel.culturalParams.framework = 'axelrod';
            addMessageToChannel(channel, 'system',
              `🎭 **Axelrod's Cultural Dissemination Model**\n\n` +
              `Cultural trait convergence/divergence.\n` +
              `• Interaction probability ∝ cultural similarity\n` +
              `• Agents adopt traits from similar neighbors\n` +
              `• Emergent cultural domains form\n` +
              `• Diversity preserved by trait variability`
            );
            persistState();
            return;
          }
          
          if (mode === 'schelling') {
            if (!channel.culturalParams) {
              addMessageToChannel(channel, 'system', '⚠️ Start simulation first');
              return;
            }
            channel.culturalParams.framework = 'schelling';
            addMessageToChannel(channel, 'system',
              `🏘️ **Schelling's Segregation Model**\n\n` +
              `Spatial segregation from mild preferences.\n` +
              `• Agents want X% similar neighbors\n` +
              `• Unhappy agents relocate\n` +
              `• Mild preferences → extreme segregation\n` +
              `• Emergent clustering patterns`
            );
            persistState();
            return;
          }
          
          // BARAD'S DIFFRACTIVE METHODOLOGY - Comparison Commands
          if (mode === 'compare snapshot') {
            if (!channel.culturalParams || !channel.culturalAgents) {
              addMessageToChannel(channel, 'system', '⚠️ Start simulation first with `/cultural spawn [scene]`');
              return;
            }
            
            // Capture current state
            const snapshot = captureSimulationSnapshot(channel);
            channel.culturalParams.comparisonSnapshot = snapshot;
            channel.culturalParams.comparisonMode = true;
            
            addMessageToChannel(channel, 'system',
              `🔬 **Snapshot Captured (Barad's Agential Cut)**\n\n` +
              `Configuration A preserved:\n` +
              `• Framework: ${snapshot.framework}\n` +
              `• BDI: ${snapshot.useBDI ? 'Active' : 'Inactive'}\n` +
              `• Tick: ${snapshot.tick}\n` +
              `• Population: ${snapshot.distribution.citizens}C / ${snapshot.distribution.rebels}R / ${snapshot.distribution.cops}P\n` +
              `• Legitimacy: ${(snapshot.legitimacy * 100).toFixed(0)}%\n\n` +
              `**Next steps:**\n` +
              `1. Switch framework (e.g., \`/iruba\` or \`/bdi\`)\n` +
              `2. Let simulation run for 20+ ticks\n` +
              `3. Run \`/compare analyze\` to see diffractive patterns\n\n` +
              `**Barad:** "We are part of the nature we seek to understand."\n` +
              `Your framework choice actively co-constitutes the cultural phenomena.`
            );
            
            console.log('[COMPARISON] Snapshot captured for diffractive analysis');
            persistState();
            return;
          }
          
          if (mode === 'compare analyze') {
            if (!channel.culturalParams?.comparisonSnapshot) {
              addMessageToChannel(channel, 'system', 
                `⚠️ No snapshot found. First run \`/compare snapshot\` to capture Configuration A.`
              );
              return;
            }
            
            if (!channel.culturalAgents) {
              addMessageToChannel(channel, 'system', '⚠️ No active simulation to compare.');
              return;
            }
            
            // Capture current state as Configuration B
            const snapshotB = captureSimulationSnapshot(channel);
            const snapshotA = channel.culturalParams.comparisonSnapshot;
            
            // Run diffractive analysis
            const analysis = diffractiveAnalysis(snapshotA, snapshotB);
            
            // Display results in chat
            let msg = `🔬 **Diffractive Analysis Complete**\n\n`;
            msg += `**Configuration A:** ${snapshotA.framework} (${snapshotA.useBDI ? 'BDI' : 'Standard'}) @ Tick ${snapshotA.tick}\n`;
            msg += `**Configuration B:** ${snapshotB.framework} (${snapshotB.useBDI ? 'BDI' : 'Standard'}) @ Tick ${snapshotB.tick}\n\n`;
            
            msg += `**Population Interference:**\n`;
            msg += `• Citizens: ${analysis.popDiff.citizens > 0 ? '+' : ''}${analysis.popDiff.citizens}\n`;
            msg += `• Rebels: ${analysis.popDiff.rebels > 0 ? '+' : ''}${analysis.popDiff.rebels}\n`;
            msg += `• Cops: ${analysis.popDiff.cops > 0 ? '+' : ''}${analysis.popDiff.cops}\n\n`;
            
            msg += `**Spatial Divergence:**\n`;
            msg += `• Segregation: ${analysis.spatialDiff.segregation > 0 ? '+' : ''}${analysis.spatialDiff.segregation.toFixed(3)}\n`;
            msg += `• Rebel Clusters: ${analysis.spatialDiff.rebelClusters > 0 ? '+' : ''}${analysis.spatialDiff.rebelClusters}\n\n`;
            
            msg += `**Parameter Drift:**\n`;
            msg += `• Legitimacy: ${analysis.paramDiff.legitimacy > 0 ? '+' : ''}${(analysis.paramDiff.legitimacy * 100).toFixed(1)}%\n`;
            msg += `• Fear: ${analysis.paramDiff.fear > 0 ? '+' : ''}${analysis.paramDiff.fear.toFixed(3)}\n\n`;
            
            if (analysis.convergence) {
              msg += `💡 **Insight:** Patterns converge despite different apparatuses.\n`;
              msg += `→ LEGOS mythology constrains possible becomings.\n\n`;
            } else {
              msg += `💡 **Insight:** Strong interference patterns detected.\n`;
              msg += `→ Different agential cuts produce divergent cultural realities.\n\n`;
            }
            
            msg += `**Barad:** "Framework choices are not neutral observations\n`;
            msg += `but active interventions that co-constitute phenomena."\n\n`;
            msg += `See browser console for detailed analysis.`;
            
            addMessageToChannel(channel, 'system', msg);
            return;
          }
          
          if (mode === 'compare help') {
            addMessageToChannel(channel, 'system',
              `🔬 **Diffractive Methodology (Barad)**\n\n` +
              `Compare how different frameworks produce different emergences\n` +
              `from the same LEGOS mythology seed.\n\n` +
              `**Workflow:**\n` +
              `1. \`/cultural spawn [scene]\` - Generate LEGOS scene\n` +
              `2. Run simulation for 20+ ticks\n` +
              `3. \`/compare snapshot\` - Capture Configuration A\n` +
              `4. \`/iruba\` or \`/bdi\` - Switch framework\n` +
              `5. Run simulation for 20+ ticks\n` +
              `6. \`/compare analyze\` - Reveal diffractive patterns\n\n` +
              `**Key Concepts (Barad):**\n` +
              `• **Agential Cuts:** Framework choices actively shape phenomena\n` +
              `• **Diffractive Analysis:** Reveals patterns of difference\n` +
              `• **Entanglement:** Modeler, model, and phenomena are inseparable\n` +
              `• **Ongoing Becoming:** Culture emerges through continuous reconfiguration\n\n` +
              `**Example:**\n` +
              `Same scene with Epstein → Tipping point rebellion\n` +
              `Same scene with IRUBA → Gradual allegiance shift\n` +
              `Diffractive analysis reveals the interference pattern.\n\n` +
              `"We are part of the nature we seek to understand." — Barad`
            );
            return;
          }
          
          if (mode === 'cultural lab') {
            // Open Cultural Research Lab interface
            const hasActive = channel.culturalParams && channel.culturalAgents;
            
            let labMessage = `🧪 **Cultural Research Lab**\n\n`;
            
            if (hasActive) {
              // Show active framework
              const fw = channel.culturalParams.framework || 'epstein';
              const useBDI = channel.culturalParams.useBDI;
              
              const frameworkNames = {
                'epstein': '⚡ Epstein Civil Violence',
                'bdi': '🧠 BDI Reasoning',
                'rebeland': '🏛️ MASON RebeLand',
                'iruba': '⚔️ IRUBA',
                'ccim': '🌍 CCIM Cross-Cultural',
                'axelrod': '🎭 Axelrod Dissemination',
                'schelling': '🏘️ Schelling Segregation'
              };
              
              labMessage += `**Active Framework:** ${frameworkNames[fw] || fw}\n`;
              if (useBDI) labMessage += `**Agent Reasoning:** BDI (Belief-Desire-Intention)\n`;
              if (channel.culturalParams.comparisonMode) {
                const snap = channel.culturalParams.comparisonSnapshot;
                labMessage += `**Comparison Mode:** 🔬 Active\n`;
                labMessage += `  → Config A: ${snap.framework} @ Tick ${snap.tick}\n`;
              }
              labMessage += `\n`;
              
              // Show current PIE framework parameters
              const p = channel.culturalParams.pragmatic;
              labMessage += `**Current Parameters:**\n`;
              labMessage += `• Legitimacy: ${(p.legitimacy * 100).toFixed(0)}%\n`;
              labMessage += `• Cop Effectiveness: ${(p.copEffectiveness * 100).toFixed(0)}%\n\n`;
              
              const citizens = Object.values(channel.culturalAgents).filter(a => a.type === 'citizen').length;
              const rebels = Object.values(channel.culturalAgents).filter(a => a.type === 'rebel').length;
              const cops = Object.values(channel.culturalAgents).filter(a => a.type === 'cop').length;
              
              labMessage += `**Agent Counts:**\n`;
              labMessage += `• Citizens: ${citizens}\n`;
              labMessage += `• Rebels: ${rebels}\n`;
              labMessage += `• Cops: ${cops}\n\n`;
              
              // LEGOS Narrative Analysis
              labMessage += `**LEGOS Narrative Roles:**\n`;
              const symbolicRoles = {};
              Object.values(channel.culturalAgents).forEach(agent => {
                if (agent.legosCellRef?.entity?.symbolicRole) {
                  const role = agent.legosCellRef.entity.symbolicRole;
                  symbolicRoles[role] = (symbolicRoles[role] || 0) + 1;
                }
              });
              Object.entries(symbolicRoles).forEach(([role, count]) => {
                labMessage += `• ${role}: ${count} agents\n`;
              });
              labMessage += `\n`;
              
              if (channel.culturalMetrics) {
                labMessage += `**Metrics:**\n`;
                labMessage += `• Rebellion Rate: ${(channel.culturalMetrics.rebellionRate * 100).toFixed(1)}%\n`;
                labMessage += `• Arrest Rate: ${(channel.culturalMetrics.arrestRate * 100).toFixed(1)}%\n`;
                labMessage += `• Movement/Tick: ${channel.culturalMetrics.movementCount || 0}\n\n`;
              }
              
              // Show sample LEGOS entities
              labMessage += `**Sample LEGOS Entities:**\n`;
              let sampleCount = 0;
              for (let [key, agent] of Object.entries(channel.culturalAgents)) {
                if (sampleCount >= 3) break;
                const entity = agent.legosCellRef?.entity;
                if (entity && entity.name && entity.symbolicRole) {
                  labMessage += `• ${entity.name} (${entity.symbolicRole}) - ${agent.type}\n`;
                  sampleCount++;
                }
              }
              labMessage += `\n`;
            } else {
              labMessage += `No active simulation. Start one with:\n\`/cultural spawn [scene]\`\n\n`;
            }
            
            labMessage += `**Theoretical Frameworks:**\n`;
            labMessage += `• Sahlins (Symbolic) → \`/structural\`\n`;
            labMessage += `• Obeyesekere (Pragmatic) → \`/pragmatic\`\n`;
            labMessage += `• Geertz (Reflexive) → \`/reflexive\`\n\n`;
            
            labMessage += `**ABM Frameworks:**\n`;
            labMessage += `• \`/bdi\` - Belief-Desire-Intention agents (Bratman)\n`;
            labMessage += `• \`/epstein\` - Civil Violence Model (2002)\n`;
            labMessage += `• \`/rebeland\` - MASON political insurgency\n`;
            labMessage += `• \`/iruba\` - Counterinsurgency operations\n`;
            labMessage += `• \`/ccim\` - Cross-cultural interaction\n`;
            labMessage += `• \`/axelrod\` - Cultural dissemination\n`;
            labMessage += `• \`/schelling\` - Segregation dynamics\n\n`;
            
            labMessage += `**Experiments:**\n`;
            labMessage += `• "Set legitimacy to 10%" - Crisis threshold\n`;
            labMessage += `• "Add 10 rebels" - Collective action\n`;
            labMessage += `• "Crackdown" - Legitimacy erosion\n`;
            labMessage += `• "Uprising" - Symbolic collapse\n`;
            labMessage += `• Switch frameworks mid-simulation to compare\n`;
            
            addMessageToChannel(channel, 'system', labMessage);
            return;
          }
          
          // Initialize or switch cultural mode
          if (!channel.culturalParams) {
            // First time: seed parameters from prompt
            channel.culturalParams = seedCulturalParams(promptText || value);
            
            // Generate scene ontology and override parameters
            const ontology = generateSceneOntology(channel);
            if (ontology.derivedParams) {
              channel.culturalParams.pragmatic.legitimacy = ontology.derivedParams.legitimacy;
              channel.culturalParams.pragmatic.copEffectiveness = ontology.derivedParams.copEffectiveness;
              console.log('[ONTOLOGY] Overriding parameters from scene:', ontology.derivedParams);
            }
            
            initCulturalAgents(channel, 0.75);
            channel.culturalTick = 0;
            channel.sceneOntology = ontology;
            
            addMessageToChannel(channel, 'system', 
              `◉ Cultural engine initialized in **${mode}** mode.\n` +
              `Scene ontology: ${ontology.entities.length} entities, ${ontology.authorities.length} authorities, ${ontology.conflicts.length} conflicts.\n` +
              `Derived legitimacy: ${ontology.derivedParams.legitimacy.toFixed(2)}, cop effectiveness: ${ontology.derivedParams.copEffectiveness.toFixed(2)}.\n` +
              `Agents spawned: ${Object.keys(channel.culturalAgents).length}/81 cells.`
            );
          } else {
            // Switching modes
            addMessageToChannel(channel, 'system', `◎ Switched to **${mode}** layer.`);
          }
          
          // Start simulation
          channel.culturalAnimating = true;
          renderChannelGrid(channel); // Show LEGOS entities
          renderCulturalGrid(channel); // Add cultural visual enhancements
          tickCulturalSimulation(channel);
          persistState();
          return;
        }
        
        // NATURAL LANGUAGE PARSING for active cultural simulation
        if (channel.culturalMode && channel.culturalAnimating) {
          // Parse natural language commands during active simulation
          const lowerValue = value.toLowerCase();
          
          // Spawn rebels pattern
          const spawnRebelMatch = lowerValue.match(/(?:add|spawn|create)\s+(\d+)\s+rebels?/);
          if (spawnRebelMatch) {
            const count = parseInt(spawnRebelMatch[1]);
            addMessageToChannel(channel, 'user', value);
            textarea.value = '';
            textarea.style.height = 'auto';
            
            // Execute spawn-rebels logic
            let spawned = 0;
            for (let y = 0; y < 9 && spawned < count; y++) {
              for (let x = 0; x < 9 && spawned < count; x++) {
                if (!channel.grid[y][x]) {
                  const id = `cultural-rebel-spawn-${Date.now()}-${spawned}`;
                  const entity = {
                    id, name: `Rebel ${spawned + 1}`, type: 'Goal', culturalType: 'rebel',
                    culturalBeliefs: { utility: 0.3, symbolic: Math.random(), reflexive: Math.random() },
                    culturalTraits: { hardship: 0.9, riskAversion: 0.2, social: 0.8 },
                    perspective: 'A newly radicalized rebel joining the uprising.'
                  };
                  channel.grid[y][x] = { id, type: 'Goal', symbol: '▲', label: entity.name, entity };
                  channel.culturalAgents[`${x}_${y}`] = {
                    type: 'rebel', legosCellRef: channel.grid[y][x], beliefs: entity.culturalBeliefs,
                    traits: entity.culturalTraits, energy: 1.0, fear: 0.5, perceivedRisk: 0, memory: []
                  };
                  logCellEvent(channel, x, y, `Rebel spawned: "${value}"`);
                  spawned++;
                }
              }
            }
            addMessageToChannel(channel, 'system', `🔥 Spawned ${spawned} rebels in response to: "${value}"`);
            renderChannelGrid(channel);
            renderCulturalGrid(channel);
            persistState();
            return;
          }
          
          // Spawn cops pattern
          const spawnCopMatch = lowerValue.match(/(?:add|spawn|deploy|send)\s+(\d+)\s+(?:cops?|police|officers?)/);
          if (spawnCopMatch) {
            const count = parseInt(spawnCopMatch[1]);
            addMessageToChannel(channel, 'user', value);
            textarea.value = '';
            textarea.style.height = 'auto';
            
            let spawned = 0;
            for (let y = 0; y < 9 && spawned < count; y++) {
              for (let x = 0; x < 9 && spawned < count; x++) {
                if (!channel.grid[y][x]) {
                  const id = `cultural-cop-spawn-${Date.now()}-${spawned}`;
                  const entity = {
                    id, name: `Cop ${spawned + 1}`, type: 'Obstacle', culturalType: 'cop',
                    culturalBeliefs: { utility: 0.9, symbolic: Math.random(), reflexive: Math.random() },
                    culturalTraits: { hardship: 0.1, riskAversion: 0.2, social: 0.7 },
                    perspective: 'A reinforcement cop deployed to restore order.'
                  };
                  channel.grid[y][x] = { id, type: 'Obstacle', symbol: '◆', label: entity.name, entity };
                  channel.culturalAgents[`${x}_${y}`] = {
                    type: 'cop', legosCellRef: channel.grid[y][x], beliefs: entity.culturalBeliefs,
                    traits: entity.culturalTraits, energy: 1.0, fear: 0, perceivedRisk: 0, memory: []
                  };
                  logCellEvent(channel, x, y, `Cop deployed: "${value}"`);
                  spawned++;
                }
              }
            }
            addMessageToChannel(channel, 'system', `👮 Deployed ${spawned} cops in response to: "${value}"`);
            renderChannelGrid(channel);
            renderCulturalGrid(channel);
            persistState();
            return;
          }
          
          // Legitimacy adjustment pattern
          const legitMatch = lowerValue.match(/(?:set|change|increase|decrease|adjust)\s+(?:legitimacy|authority|government)\s+(?:to\s+)?(\d+)%?/);
          if (legitMatch) {
            const percent = parseInt(legitMatch[1]);
            const newLegitimacy = percent / 100;
            
            addMessageToChannel(channel, 'user', value);
            textarea.value = '';
            textarea.style.height = 'auto';
            
            if (newLegitimacy >= 0 && newLegitimacy <= 1) {
              channel.culturalParams.pragmatic.legitimacy = newLegitimacy;
              addMessageToChannel(channel, 'system', `📊 Legitimacy set to ${percent}% in response to: "${value}"`);
              persistState();
            } else {
              addMessageToChannel(channel, 'system', '⚠️ Legitimacy must be 0-100%');
            }
            return;
          }
          
          // Crackdown pattern
          if (lowerValue.match(/crackdown|crack down|suppress|repress|violent response/)) {
            addMessageToChannel(channel, 'user', value);
            textarea.value = '';
            textarea.style.height = 'auto';
            
            channel.culturalParams.pragmatic.copEffectiveness *= 1.5;
            channel.culturalParams.pragmatic.legitimacy *= 0.7;
            addMessageToChannel(channel, 'system', 
              `🚨 CRACKDOWN in response to: "${value}"\n` +
              `Cop effectiveness +50%, Legitimacy -30%. Fear spreads...`
            );
            persistState();
            return;
          }
          
          // Uprising pattern
          if (lowerValue.match(/uprising|revolt|revolution|radicali[sz]e|protest wave/)) {
            addMessageToChannel(channel, 'user', value);
            textarea.value = '';
            textarea.style.height = 'auto';
            
            channel.culturalParams.pragmatic.legitimacy *= 0.5;
            Object.values(channel.culturalAgents).forEach(agent => {
              if (agent.type === 'citizen') {
                agent.traits.hardship = Math.min(1, agent.traits.hardship + 0.3);
              }
            });
            addMessageToChannel(channel, 'system',
              `⚡ UPRISING in response to: "${value}"\n` +
              `Citizen hardship +30%, Legitimacy halved. Revolution stirs...`
            );
            persistState();
            return;
          }
          
          // Pause/stop pattern
          if (lowerValue.match(/^(pause|stop|halt|freeze)$/)) {
            addMessageToChannel(channel, 'user', value);
            textarea.value = '';
            textarea.style.height = 'auto';
            
            channel.culturalAnimating = false;
            addMessageToChannel(channel, 'system', `⏸️ Simulation paused in response to: "${value}"`);
            persistState();
            return;
          }
          
          // Resume pattern
          if (lowerValue.match(/^(resume|continue|play|start)$/)) {
            addMessageToChannel(channel, 'user', value);
            textarea.value = '';
            textarea.style.height = 'auto';
            
            channel.culturalAnimating = true;
            tickCulturalSimulation(channel);
            addMessageToChannel(channel, 'system', `▶️ Simulation resumed in response to: "${value}"`);
            persistState();
            return;
          }
          
          // If no pattern matched, show helpful message
          addMessageToChannel(channel, 'user', value);
          textarea.value = '';
          textarea.style.height = 'auto';
          addMessageToChannel(channel, 'system', 
            `💬 I understood: "${value}"\n\n` +
            `During cultural simulation, try:\n` +
            `• "Add 5 rebels" - Spawn rebel agents\n` +
            `• "Deploy 3 cops" - Add police\n` +
            `• "Set legitimacy to 30%" - Adjust government legitimacy\n` +
            `• "Crackdown" - Trigger police crackdown\n` +
            `• "Uprising" - Trigger mass radicalization\n` +
            `• "Pause" / "Resume" - Control animation\n\n` +
            `Or type \`/cultural help\` for all commands.`
          );
          return;
        }
        
        // Normal flow for non-cultural commands
        addMessageToChannel(channel, 'user', value);
        textarea.value = '';
        textarea.style.height = 'auto';
        if (!appState.apiKey) {
          addMessageToChannel(channel, 'system', 'API key required for auto scene assembly. Store one via ◎.');
          persistState();
          return;
        }
        composeScene(channel, value);
      });

      inputWrapper.appendChild(textarea);
      inputWrapper.appendChild(sendBtn);
      inputSection.appendChild(inputWrapper);
      
      // Per-channel footer removed - now using global footer

      // Click anywhere in column to focus it
      column.addEventListener('click', (e) => {
        // Don't interfere with button clicks
        if (!e.target.closest('button, input, textarea, .grid-cell')) {
          focusChannel(channel.id);
        }
      });
      
      chatSection.appendChild(chatStream);
      chatSection.appendChild(inputSection);

      // Add resize bar between grid and chat
      const resizeBar = document.createElement('div');
      resizeBar.className = 'resize-bar';
      
      let isResizing = false;
      let startY = 0;
      let startHeight = 0;
      
      // Mouse events
      resizeBar.addEventListener('mousedown', (e) => {
        isResizing = true;
        startY = e.clientY;
        startHeight = gridSection.offsetHeight;
        document.body.style.cursor = 'row-resize';
        e.preventDefault();
      });
      
      document.addEventListener('mousemove', (e) => {
        if (!isResizing) return;
        const deltaY = e.clientY - startY;
        let newHeight = startHeight + deltaY;
        
        // Clamp between 30vh and 70vh
        newHeight = Math.max(window.innerHeight * 0.3, Math.min(window.innerHeight * 0.7, newHeight));
        
        gridSection.style.height = newHeight + 'px';
        gridSection.style.flex = `0 0 ${newHeight}px`;
      });
      
      document.addEventListener('mouseup', () => {
        if (isResizing) {
          isResizing = false;
          document.body.style.cursor = '';
        }
      });
      
      // Touch events for mobile
      resizeBar.addEventListener('touchstart', (e) => {
        isResizing = true;
        startY = e.touches[0].clientY;
        startHeight = gridSection.offsetHeight;
        e.preventDefault();
      });
      
      document.addEventListener('touchmove', (e) => {
        if (!isResizing) return;
        const deltaY = e.touches[0].clientY - startY;
        let newHeight = startHeight + deltaY;
        
        // Clamp between 30vh and 70vh
        newHeight = Math.max(window.innerHeight * 0.3, Math.min(window.innerHeight * 0.7, newHeight));
        
        gridSection.style.height = newHeight + 'px';
        gridSection.style.flex = `0 0 ${newHeight}px`;
      }, { passive: false });
      
      document.addEventListener('touchend', () => {
        if (isResizing) {
          isResizing = false;
        }
      });
      
      body.appendChild(gridSection);
      body.appendChild(resizeBar);
      body.appendChild(chatSection);

      // Activate channel on any click within the column
      column.addEventListener('click', (e) => {
        // Don't interfere with button clicks
        if (e.target.closest('button')) return;
        focusChannel(channel.id);
      });
      
      // Also activate on chat interaction
      chatSection.addEventListener('click', () => {
        focusChannel(channel.id);
      });

      column.appendChild(header);
      column.appendChild(body);
      scroller.appendChild(column);

      channel.dom = {
        column,
        header,
        nameEl: name,
        lineageEl: lineage,
        gridEl: grid,
        gridWrapper,
        gridTitle,
        messageList,
        messageDotRail,
        input: textarea,
        sendBtn,
        channelRail: channelNumberRail
      };

      refreshChannelHeader(channel);
      styleChannelControls(channel);
      renderChannel(channel);
    }

    function refreshChannelHeader(channel) {
      if (!channel || !channel.dom) return;
      const { nameEl, lineageEl, gridTitle } = channel.dom;
      if (nameEl) nameEl.textContent = channel.name;
      if (lineageEl) {
        if (channel.parentChannelId) {
          const parent = channelMap.get(channel.parentChannelId);
          const parentHandle = sanitizeHandle(parent?.name || 'PARENT', 'PARENT');
          lineageEl.textContent = `FORK · ${parentHandle}`;
          lineageEl.style.display = '';
        } else {
          lineageEl.textContent = '';
          lineageEl.style.display = 'none';
        }
      }
      if (gridTitle) {
        gridTitle.textContent = formatChannelHeadline(channel);
      }
    }

    function styleChannelControls(channel) {
      if (!channel || !channel.dom) return;
      const color = channel.channelColor || getComputedStyle(document.body).getPropertyValue('--accent');
      const { sendBtn, header, column } = channel.dom;
      const isActive = channel.id === appState.currentChannelId;
      
      // Mark inactive channels and set color variable
      if (column) {
        if (isActive) {
          column.classList.remove('inactive');
        } else {
          column.classList.add('inactive');
        }
        // Set CSS variable for channel color
        column.style.setProperty('--channel-color', color);
      }
      
      // Apply channel color to all buttons in header and footer
      const channelBtns = column?.querySelectorAll('.channel-btn');
      channelBtns?.forEach(btn => {
        btn.style.borderColor = color;
        btn.style.color = color;
      });
      
      // Send button gets full color
      if (sendBtn) {
        sendBtn.textContent = '➜';
        sendBtn.dataset.channelId = channel.id;
        sendBtn.style.background = color;
        sendBtn.style.color = 'var(--bg)';
        sendBtn.style.borderColor = color;
      }
      
      // Header and footer borders
      if (header) {
        header.style.borderColor = color;
      }
      
      const footer = column?.querySelector('.channel-footer');
      if (footer) {
        footer.style.borderColor = color;
      }
      
      
      // Grid cells get subtle accent
      const gridCells = column?.querySelectorAll('.grid-cell.occupied');
      gridCells?.forEach(cell => {
        cell.style.borderColor = color;
      });
      
      // Channel numbers in rail
      const channelNumbers = document.querySelectorAll('.channel-number');
      channelNumbers.forEach(num => {
        if (num.dataset.channelId === channel.id) {
          num.style.borderColor = color;
          num.style.background = color;
          num.style.color = 'var(--bg)';
          num.style.boxShadow = `0 0 12px ${color}40`;
        } else {
          // Grey out other channels
          num.style.opacity = '0.4';
        }
      });
      
      // Message dots get channel color
      const messageDots = column?.querySelectorAll('.message-dot');
      messageDots?.forEach(dot => {
        dot.style.color = color;
        dot.style.borderColor = color;
      });
    }

    function formatChannelHeadline(channel) {
      if (!channel) return '';
      const parts = [];
      parts.push(channel.symbolicId);
      const nameHandle = sanitizeHandle(channel.name, channel.symbolicId);
      if (nameHandle !== channel.symbolicId) {
        parts.push(nameHandle);
      }
      if (channel.forkPoint && channel.forkPoint.mode) {
        let label = channel.forkPoint.mode.toUpperCase();
        if (channel.forkPoint.mode === 'perspective') {
          label = 'POV';
        }
        parts.push(sanitizeHandle(label, 'FORK'));
      }
      if (channel.forkPoint && channel.forkPoint.coordinates) {
        const { x, y } = channel.forkPoint.coordinates;
        parts.push(sanitizeHandle(`CELL ${x}${y}`, 'CELL'));
      }
      if (channel.ringBinding) {
        const entry = ringMemory.entries.find(e => e.id === channel.ringBinding);
        if (entry && entry.symbol) {
          parts.push(entry.symbol);
        }
      }
      return parts
        .filter(Boolean)
        .map(part => sanitizeHandle(part, part))
        .join(' • ');
    }

    function renderChannel(channel) {
      refreshChannelHeader(channel);
      styleChannelControls(channel);
      renderChannelGrid(channel);
      renderChannelMessages(channel);
      renderTetradPanel(channel);
      renderTimeline();
      if (snapshotOverlayChannel === channel) {
        renderSnapshotOverlay();
      }
    }

    function renderGrid(channel) {
      const grid = channel.dom?.gridEl;
      if (!grid) return;
      grid.innerHTML = '';
      
      // Detect resonance fields (nearby entities)
      const entityPositions = [];
      channel.grid.forEach((row, y) => {
        row.forEach((cell, x) => {
          if (cell && cell.type === 'Entity') {
            entityPositions.push({ x, y });
          }
        });
      });
      channel.grid.forEach((row, y) => {
        row.forEach((cell, x) => {
          const div = document.createElement('div');
          div.className = 'grid-cell';
          
          // Check if this cell is in resonance field
          const isNearEntity = entityPositions.some(pos => {
            const distance = Math.abs(pos.x - x) + Math.abs(pos.y - y);
            return distance <= 2 && distance > 0;
          });
          
          if (isNearEntity && (!cell || cell.type !== 'Entity')) {
            div.classList.add('resonance-field');
          }
          
          if (cell) {
            div.classList.add('occupied');
            const palette = blockPalette.find(p => p.type === cell.type);
            div.textContent = cell.symbol || '?';
            div.style.color = palette?.color || 'var(--text)';
            
            // Rich tooltip
            let tooltip = `${cell.type}: ${cell.label || 'Unnamed'}`;
            if (cell.entity?.description) {
              tooltip += `\n${cell.entity.description.substring(0, 80)}${cell.entity.description.length > 80 ? '...' : ''}`;
            }
            if (cell.entity?.relations?.length) {
              tooltip += `\nRelations: ${cell.entity.relations.length}`;
            }
            const cellLogs = channel.cells[`${x},${y}`] || [];
            if (cellLogs.length) {
              tooltip += `\nEvents: ${cellLogs.length}`;
            }
            div.title = tooltip;
            
            if (cell.label) {
              // Add full name for hover tooltip
              div.setAttribute('data-full-name', cell.label.toUpperCase());
              
              const label = document.createElement('div');
              label.className = 'grid-label';
              // Truncate to 8 chars for consistent sizing
              const truncatedLabel = cell.label.length > 8 ? cell.label.slice(0, 7) + '…' : cell.label;
              label.textContent = truncatedLabel.toUpperCase();
              
              // Calculate luminance for contrast
              if (palette?.color) {
                const color = palette.color;
                let r, g, b;
                
                // Parse hex color
                if (color.startsWith('#')) {
                  const hex = color.slice(1);
                  r = parseInt(hex.slice(0, 2), 16);
                  g = parseInt(hex.slice(2, 4), 16);
                  b = parseInt(hex.slice(4, 6), 16);
                } else if (color.startsWith('rgb')) {
                  const match = color.match(/\d+/g);
                  if (match) {
                    [r, g, b] = match.map(Number);
                  }
                }
                
                if (r !== undefined && g !== undefined && b !== undefined) {
                  // Calculate relative luminance
                  const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
                  
                  // If bright color, use dark text
                  if (luminance > 0.6) {
                    label.classList.add('dark-text');
                  } else {
                    label.classList.add('light-text');
                  }
                }
              }
              
              div.appendChild(label);
            }
            div.dataset.cellType = cell.type;
          }
          div.dataset.x = x;
          div.dataset.y = y;
          div.addEventListener('click', () => {
            focusChannel(channel.id);
            openCellOverlay(channel, x, y);
          });
          grid.appendChild(div);
        });
      });
    }

    function renderChannelGrid(channel) {
      const grid = channel.dom?.gridEl;
      if (!grid) return;
      grid.innerHTML = '';
      channel.grid.forEach((row, y) => {
        row.forEach((cell, x) => {
          const div = document.createElement('div');
          div.className = 'grid-cell';
        if (cell) {
          div.classList.add('occupied');
          const palette = blockPalette.find(p => p.type === cell.type);
          div.textContent = cell.symbol || palette?.symbol || cell.type[0];
          if (cell.label) {
            const label = document.createElement('div');
            label.className = 'grid-label';
            // Truncate to 8 chars for consistent sizing
            const truncatedLabel = cell.label.length > 8 ? cell.label.slice(0, 7) + '…' : cell.label;
            label.textContent = truncatedLabel.toUpperCase();
            
            // Calculate luminance for contrast
            if (palette?.color) {
              const color = palette.color;
              let r, g, b;
              
              if (color.startsWith('#')) {
                const hex = color.slice(1);
                r = parseInt(hex.slice(0, 2), 16);
                g = parseInt(hex.slice(2, 4), 16);
                b = parseInt(hex.slice(4, 6), 16);
              } else if (color.startsWith('rgb')) {
                const match = color.match(/\d+/g);
                if (match) {
                  [r, g, b] = match.map(Number);
                }
              }
              
              if (r !== undefined && g !== undefined && b !== undefined) {
                const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
                if (luminance > 0.6) {
                  label.classList.add('dark-text');
                } else {
                  label.classList.add('light-text');
                }
              }
            }
            
            div.appendChild(label);
          }
          div.dataset.cellType = cell.type;
          
          // Add hover tooltip with full name
          if (cell.label) {
            div.title = `${cell.label} (${cell.type})\nClick for perspective`;
          } else if (cell.type) {
            div.title = `${cell.type}\nClick for details`;
          }
        }
          div.dataset.x = x;
          div.dataset.y = y;
          div.addEventListener('click', () => {
            focusChannel(channel.id);
            openCellOverlay(channel, x, y);
          });
          grid.appendChild(div);
        });
      });
    }

    function renderChannelMessages(channel) {
      const list = channel.dom && channel.dom.messageList;
      const dotRail = channel.dom && channel.dom.messageDotRail;
      if (!list) return;
      list.innerHTML = '';
      if (dotRail) dotRail.innerHTML = '';
      const lastAssistantId = [...channel.messages].reverse().find(msg => msg.role === 'assistant')?.id || null;
      const totalMessages = channel.messages.length;
      channel.messages.forEach((msg, idx) => {
        const item = document.createElement('div');
        item.className = `message ${msg.role}`;
        item.dataset.messageId = msg.id;

        const isRecent = idx >= totalMessages - 3;
        if (msg.autoCollapse || (!isRecent && msg.role !== 'user')) {
          item.classList.add('collapsed');
        }

        if (channel.forkPoint?.messageId && String(channel.forkPoint.messageId) === String(msg.id)) {
          item.classList.add('fork-origin');
        }

        const header = document.createElement('div');
        header.className = 'message-header';
        
        // Dual-dot visualization for forks (git-style)
        if (channel.parentChannelId) {
          const parentChannel = channelMap.get(channel.parentChannelId);
          if (parentChannel) {
            const parentDot = document.createElement('span');
            parentDot.className = 'message-color-dot parent-dot';
            parentDot.style.color = parentChannel.channelColor;
            parentDot.textContent = '●';
            parentDot.title = `Parent: ${parentChannel.name}`;
            header.appendChild(parentDot);
          }
        }
        
        const colorDot = document.createElement('span');
        colorDot.className = 'message-color-dot';
        if (msg.role === 'user') {
          colorDot.style.color = lightenColor(channel.channelColor, 0.25);
        } else if (msg.role === 'system') {
          colorDot.style.color = lightenColor(channel.channelColor, -0.3);
          colorDot.style.opacity = '0.6';
        } else {
          colorDot.style.color = channel.channelColor;
        }
        colorDot.textContent = '●';
        const origin = msg.fromChannel ? ` ← ${msg.fromChannel}` : '';
        header.appendChild(colorDot);
        const headerText = document.createElement('span');
        const roleDisplay = msg.role === 'tetrad' ? 'TETRAD OPTIONS' : msg.role.toUpperCase();
        headerText.textContent = `${msg.id} · ${roleDisplay}${origin}`;
        header.appendChild(headerText);
        
        // Add ring memory indicator if this message is bound
        if (channel.ringBinding) {
          const ringEntry = ringMemory.entries.find(e => e.id === channel.ringBinding);
          if (ringEntry && msg.role === 'assistant') {
            const ringIndicator = document.createElement('span');
            ringIndicator.className = 'ring-indicator';
            ringIndicator.textContent = '⊚';
            ringIndicator.title = `Bound to ring: ${ringEntry.symbol}`;
            ringIndicator.style.color = channel.channelColor;
            ringIndicator.style.marginLeft = 'auto';
            header.appendChild(ringIndicator);
          }
        }
        
        item.appendChild(header);

        const preview = document.createElement('div');
        preview.className = 'message-preview';
        const msgText = msg.text || '';
        if (msg.role === 'tetrad') {
          preview.textContent = '✨ Tetrad Options Available';
        } else {
          preview.textContent = msgText.split('\n')[0].slice(0, 60) + (msgText.length > 60 ? '…' : '');
        }
        item.appendChild(preview);

        const body = document.createElement('div');
        body.className = 'message-body';
        
        // Special rendering for tetrad messages
        if (msg.role === 'tetrad' && msg.tetradData) {
          // Add reveal animation if this is the latest tetrad
          if (idx === totalMessages - 1) {
            item.style.animation = 'pulse 0.6s ease-in-out';
            item.style.boxShadow = '0 0 20px var(--accent-glow)';
            setTimeout(() => {
              item.style.animation = '';
              item.style.boxShadow = '';
            }, 600);
          }
          
          const tetradMap = [
            { key: 'enhance', icon: '▲', label: 'ENHANCE' },
            { key: 'reverse', icon: '⇄', label: 'REVERSE' },
            { key: 'retrieve', icon: '↺', label: 'RETRIEVE' },
            { key: 'obsolesce', icon: '▼', label: 'OBSOLESCE' }
          ];
          
          tetradMap.forEach((mapping, tetradIdx) => {
            const entry = msg.tetradData[mapping.key];
            if (!entry) return;
            
            const optionDiv = document.createElement('div');
            optionDiv.style.cssText = `
              padding: 10px 12px;
              margin-bottom: 6px;
              border-left: 3px solid var(--accent);
              background: var(--panel-dark);
              transition: all 0.2s var(--transition);
              border-radius: 4px;
              display: flex;
              align-items: flex-start;
              gap: 10px;
              position: relative;
            `;
            
            // Stagger animation for latest tetrad
            if (idx === totalMessages - 1) {
              optionDiv.style.opacity = '0';
              optionDiv.style.transform = 'translateX(-20px)';
              setTimeout(() => {
                optionDiv.style.transition = 'all 0.4s cubic-bezier(0.4, 0, 0.2, 1)';
                optionDiv.style.opacity = '1';
                optionDiv.style.transform = 'translateX(0)';
              }, 100 + (tetradIdx * 100));
            }
            
            const contentDiv = document.createElement('div');
            contentDiv.style.cssText = `
              flex: 1;
              cursor: pointer;
            `;
            
            const optionHeader = document.createElement('div');
            optionHeader.style.cssText = `
              font-size: 10px;
              font-weight: 700;
              letter-spacing: 0.15em;
              color: var(--accent);
              margin-bottom: 4px;
            `;
            optionHeader.textContent = `${mapping.icon} ${mapping.label}`;
            
            const optionText = document.createElement('div');
            optionText.style.cssText = `
              font-size: 9px;
              line-height: 1.5;
              color: var(--text);
            `;
            optionText.textContent = entry.text;
            
            contentDiv.appendChild(optionHeader);
            contentDiv.appendChild(optionText);
            
            // Multiple steering buttons (light touch)
            const btnContainer = document.createElement('div');
            btnContainer.style.cssText = `
              display: flex;
              flex-direction: column;
              gap: 4px;
              flex-shrink: 0;
            `;
            
            const channelColor = channel.channelColor || 'var(--accent)';
            
            // Create steering buttons with different actions
            const steeringActions = [
              { icon: '→', label: 'Continue', prefix: '' },
              { icon: '↗', label: 'Explore deeper', prefix: 'Explore deeper: ' },
              { icon: '↔', label: 'Compare', prefix: 'Compare with alternatives: ' },
              { icon: '⋔', label: 'Re-tetrad', prefix: 'Generate tetrad for: ' }
            ];
            
            steeringActions.forEach((action, actionIdx) => {
              const btn = document.createElement('button');
              btn.style.cssText = `
                width: 28px;
                height: 28px;
                border-radius: 50%;
                background: ${channelColor};
                border: 2px solid ${channelColor};
                color: var(--bg);
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 14px;
                font-weight: 700;
                transition: all 0.2s;
                box-shadow: 0 2px 6px ${channelColor}22;
                opacity: ${actionIdx === 0 ? '1' : '0.7'};
              `;
              btn.textContent = action.icon;
              btn.title = action.label;
              
              btn.addEventListener('mouseenter', () => {
                btn.style.transform = 'scale(1.15)';
                btn.style.opacity = '1';
                btn.style.boxShadow = `0 4px 12px ${channelColor}66`;
              });
              
              btn.addEventListener('mouseleave', () => {
                btn.style.transform = 'scale(1)';
                btn.style.opacity = actionIdx === 0 ? '1' : '0.7';
                btn.style.boxShadow = `0 2px 6px ${channelColor}22`;
              });
              
              btn.addEventListener('click', (e) => {
                e.stopPropagation();
                const followUpText = action.prefix + `${mapping.label}: ${entry.text}`;
                channel.dom.input.value = followUpText;
                channel.dom.input.focus();
                
                // Animate the button
                btn.style.transform = 'scale(0.8)';
                btn.style.opacity = '0.5';
                setTimeout(() => {
                  btn.style.transform = 'scale(1)';
                  btn.style.opacity = actionIdx === 0 ? '1' : '0.7';
                }, 200);
                
                // Flash effect on option
                optionDiv.style.background = 'var(--accent)';
                optionDiv.style.boxShadow = '0 0 20px var(--accent-glow)';
                setTimeout(() => {
                  optionDiv.style.background = 'var(--panel-dark)';
                  optionDiv.style.boxShadow = 'none';
                }, 300);
              });
              
              btnContainer.appendChild(btn);
            });
            
            optionDiv.appendChild(contentDiv);
            optionDiv.appendChild(btnContainer);
            
            contentDiv.addEventListener('mouseenter', () => {
              optionDiv.style.background = 'var(--accent-soft)';
              optionDiv.style.transform = 'translateX(4px)';
            });
            
            contentDiv.addEventListener('mouseleave', () => {
              optionDiv.style.background = 'var(--panel-dark)';
              optionDiv.style.transform = 'translateX(0)';
            });
            
            // Click content to preview/read
            contentDiv.addEventListener('click', () => {
              optionDiv.style.background = 'var(--accent-soft)';
            });
            
            body.appendChild(optionDiv);
          });
        } else {
          body.textContent = msgText;
        }
        
        item.appendChild(body);

        if (dotRail) {
          const dot = document.createElement('button');
          dot.className = 'message-dot';
          dot.dataset.messageId = msg.id;
          dot.dataset.role = msg.role;
          dot.dataset.index = idx + 1;
          dot.classList.add(msg.role);
          dot.textContent = String(idx + 1);
          
          // Dual-border for forked channels (git graph style)
          if (channel.parentChannelId) {
            const parentChannel = channelMap.get(channel.parentChannelId);
            if (parentChannel) {
              dot.classList.add('forked-dot');
              dot.style.borderColor = parentChannel.channelColor;
              dot.style.boxShadow = `0 0 0 3px ${channel.channelColor}, 0 0 12px ${channel.channelColor}`;
              dot.title = `${msg.id} · ${msg.role.toUpperCase()} [Fork from ${parentChannel.name}]`;
            }
          } else {
            dot.title = `${msg.id} · ${msg.role.toUpperCase()}`;
          }
          
          if (msg.role === 'user') {
            dot.style.color = lightenColor(channel.channelColor, 0.25);
            dot.style.backgroundColor = lightenColor(channel.channelColor, 0.08);
          } else if (msg.role === 'system') {
            dot.style.color = lightenColor(channel.channelColor, -0.3);
            dot.style.backgroundColor = lightenColor(channel.channelColor, -0.1);
          } else {
            dot.style.color = channel.channelColor;
            dot.style.backgroundColor = lightenColor(channel.channelColor, 0.15);
          }
          if (channel.forkPoint?.messageId && String(channel.forkPoint.messageId) === String(msg.id)) {
            dot.classList.add('fork-origin');
          }
          dot.addEventListener('click', () => {
            activateMessageDot(channel, msg.id);
            item.classList.remove('collapsed');
            item.classList.add('active');
            item.scrollIntoView({ behavior: 'smooth', block: 'center' });
          });
          dotRail.appendChild(dot);
          if (idx === channel.messages.length - 1) {
            dot.classList.add('active');
          }
        }

        if (msg.role === 'assistant') {
          item.addEventListener('click', (event) => {
            if (event.target.closest('.message-actions')) return;
            toggleMessageActions(channel, msg, item);
            document.querySelectorAll(`[data-channel-id="${channel.id}"] .message`).forEach(el => el.classList.remove('active'));
            item.classList.add('active');
            activateMessageDot(channel, msg.id);
          });
          if (msg.id === lastAssistantId && channel.tetrad && Object.keys(channel.tetrad).length) {
            const chips = createTetradChips(channel);
            if (chips) body.appendChild(chips);
          }
        } else {
          item.addEventListener('click', () => {
            item.classList.toggle('collapsed');
            document.querySelectorAll(`[data-channel-id="${channel.id}"] .message`).forEach(el => el.classList.remove('active'));
            if (!item.classList.contains('collapsed')) {
              item.classList.add('active');
              activateMessageDot(channel, msg.id);
            } else if (channel.messages.length) {
              const latest = channel.messages[channel.messages.length - 1];
              if (latest) activateMessageDot(channel, latest.id);
            }
          });
        }

        list.appendChild(item);
      });
      list.scrollTo({ top: list.scrollHeight, behavior: 'smooth' });
      if (channel.messages.length) {
        activateMessageDot(channel, channel.messages[channel.messages.length - 1].id);
      }
    }

    function activateMessageDot(channel, messageId) {
      if (!channel || !channel.dom) return;
      const targetId = String(messageId);
      const { messageDotRail, messageList } = channel.dom;
      if (messageDotRail) {
        messageDotRail.querySelectorAll('.message-dot').forEach(dot => {
          dot.classList.toggle('active', dot.dataset.messageId === targetId);
        });
      }
      if (messageList) {
        messageList.querySelectorAll('.message').forEach(msgEl => {
          if (msgEl.dataset.messageId === targetId) {
            msgEl.classList.add('active');
          } else {
            msgEl.classList.remove('active');
          }
        });
      }
    }

    function toggleMessageActions(channel, message, element) {
      closeAllMenus();
      let menu = element.querySelector('.message-actions');
      if (!menu) {
        menu = document.createElement('div');
        menu.className = 'message-actions';
        
        const closeBtn = document.createElement('button');
        closeBtn.className = 'message-action-close';
        closeBtn.textContent = '✕';
        closeBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          closeAllMenus();
        });
        menu.appendChild(closeBtn);
        
        const options = buildMessageOptions(channel, message);
        options.forEach(opt => menu.appendChild(opt));
        element.appendChild(menu);
      }
      menu.classList.toggle('active');
    }

    function closeAllMenus() {
      document.querySelectorAll('.message-actions.active').forEach(menu => menu.classList.remove('active'));
    }
    
    function sendPerspectiveToChat(channel, text) {
      if (!channel || !channel.dom) return;
      const textarea = channel.dom.input;
      if (textarea) {
        // Add to existing text or set new text
        const currentText = textarea.value.trim();
        textarea.value = currentText ? `${currentText}\n\n${text}` : text;
        textarea.style.height = 'auto';
        textarea.style.height = textarea.scrollHeight + 'px';
        textarea.focus();
        
        // Close perspective overlay
        document.getElementById('perspectiveOverlay').classList.remove('active');
        
        // Show feedback
        const feedback = document.createElement('div');
        feedback.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          background: var(--accent);
          color: var(--bg);
          padding: 12px 20px;
          border-radius: 4px;
          font-size: 11px;
          font-weight: 700;
          letter-spacing: 0.1em;
          z-index: 10000;
          box-shadow: 0 4px 12px rgba(0,0,0,0.3);
          animation: slideInRight 0.3s ease;
        `;
        feedback.textContent = 'SENT TO CHAT';
        document.body.appendChild(feedback);
        setTimeout(() => {
          feedback.style.opacity = '0';
          feedback.style.transform = 'translateX(20px)';
          setTimeout(() => feedback.remove(), 300);
        }, 1500);
      }
    }

    function buildMessageOptions(channel, message) {
      // Auto-generate tetrad if missing and scene exists
      if (channel.lastScene && !channel.tetrad && !channel.pendingTetrad && appState.apiKey) {
        regenerateTetrad(channel);
      }
      
      const fragments = [];
      const addOption = (label, handler, enabled = true) => {
        const div = document.createElement('div');
        div.className = 'message-action';
        div.textContent = label;
        if (enabled) {
          div.addEventListener('click', (e) => {
            e.stopPropagation();
            closeAllMenus();
            handler();
          });
        } else {
          div.classList.add('disabled');
        }
        fragments.push(div);
      };

      addOption('↔ FORK: CONTINUE', () => forkChannel(channel, message, 'continue'));

      ['enhance', 'reverse', 'retrieve', 'obsolesce'].forEach(key => {
        const entry = channel.tetrad?.[key];
        const label = `⋔ FORK: ${key.toUpperCase()}`;
        // Always enable if we have a scene (tetrad will generate)
        const enabled = Boolean(channel.lastScene);
        addOption(label, () => {
          if (!entry?.text) {
            // If no tetrad yet, generate it first
            if (channel.lastScene && !channel.pendingTetrad) {
              regenerateTetrad(channel).then(() => {
                // Try to fork again after generation
                const newEntry = channel.tetrad?.[key];
                if (newEntry?.text) {
                  forkChannel(channel, message, key);
                }
              });
            }
            return;
          }
          forkChannel(channel, message, key);
        }, enabled);
      });

      addOption('◎ FORK: PERSPECTIVE', () => forkChannel(channel, message, 'perspective'));
      addOption('⧉ FORK: SNAPSHOT', () => forkChannel(channel, message, 'snapshot'));
      addOption('+ NEW BLANK CHANNEL', () => forkChannel(channel, message, 'blank'));

      const otherChannels = appState.channels.filter(ch => ch.id !== channel.id);
      if (otherChannels.length) {
        otherChannels.forEach(target => {
          addOption(`→ SEND TO ${target.name}`, () => routeMessage(channel, target, message));
        });
      }

      return fragments;
    }

    // Normalize tetrad data from any format to standard {enhance, reverse, retrieve, obsolesce}
    function normalizeTetradData(channel) {
      if (!channel.tetrad) return null;
      
      // Format 1: Direct object with keys {enhance: {...}, reverse: {...}, ...}
      if (typeof channel.tetrad === 'object' && !Array.isArray(channel.tetrad)) {
        if (channel.tetrad.enhance) return channel.tetrad; // ✅ Already correct!
        if (channel.tetrad.tetradEntries) return null; // ❌ Old format, ignore
        
        // Check if it's wrapped like {tetrad: {enhance: {...}}}
        if (channel.tetrad.tetrad && typeof channel.tetrad.tetrad === 'object') {
          return normalizeTetradData({tetrad: channel.tetrad.tetrad}); // Unwrap and retry
        }
      }
      
      // Format 2: tetrads array (get latest)
      if (channel.tetrads && Array.isArray(channel.tetrads) && channel.tetrads.length > 0) {
        const latest = channel.tetrads[channel.tetrads.length - 1];
        if (latest && latest.enhance) return latest;
      }
      
      // Format 3: tetrad as array with type property [{type: 'enhance', ...}, ...]
      if (Array.isArray(channel.tetrad) && channel.tetrad.length > 0) {
        const result = {};
        channel.tetrad.forEach(item => {
          if (item && item.type && item.text) {
            result[item.type] = {text: item.text, score: item.score || 0};
          }
        });
        if (Object.keys(result).length > 0) {
          console.log('[TETRAD] Converted array format:', result);
          return result; // ✅ Converted!
        }
      }
      
      console.log('[TETRAD] Unknown format:', channel.tetrad);
      return null;
    }
    
    // Create tetrad chips inline in message (like tet-chat.html)
    function createTetradChipsInline(channel) {
      const tetradData = normalizeTetradData(channel);
      if (!tetradData) return null;
      
      const container = document.createElement('div');
      container.className = 'tetrad-chips-inline';
      container.style.cssText = `
        margin-top: 12px;
        padding: 12px;
        background: rgba(0, 0, 0, 0.3);
        border-left: 3px solid var(--accent);
        border-radius: 4px;
      `;
      
      // Add header
      const header = document.createElement('div');
      header.style.cssText = `
        font-size: 9px;
        font-weight: 700;
        letter-spacing: 0.15em;
        color: var(--accent);
        margin-bottom: 8px;
        text-transform: uppercase;
      `;
      header.innerHTML = `
        <span>⋔ TETRAD OPTIONS — Click to use</span>
        <button id="tetrad-perspective-toggle-${channel.id}" style="
          margin-left: auto;
          padding: 4px 8px;
          font-size: 8px;
          background: ${channel.tetradPerspective ? 'var(--accent)' : 'var(--panel-dark)'};
          color: ${channel.tetradPerspective ? 'var(--bg)' : 'var(--text)'};
          border: 1px solid ${channel.tetradPerspective ? 'var(--accent)' : 'var(--border)'};
          border-radius: 3px;
          cursor: pointer;
          font-weight: 700;
          letter-spacing: 0.05em;
        ">
          ${channel.tetradPerspective ? '👁 ' + channel.tetradPerspective : '👁 SET PERSPECTIVE'}
        </button>
      `;
      
      // Add perspective toggle handler
      setTimeout(() => {
        const toggleBtn = document.getElementById(`tetrad-perspective-toggle-${channel.id}`);
        if (toggleBtn) {
          toggleBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            openPerspectiveSelector(channel);
          });
        }
      }, 0);
      
      container.appendChild(header);
      
      // Create chips container
      const chipsWrap = document.createElement('div');
      chipsWrap.style.cssText = `
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
      `;
      
      console.log('[TETRAD] Creating chips for channel:', channel.id, 'Data:', tetradData);
      
      const tetradMap = [
        { key: 'enhance', icon: '⋔', label: 'ENHANCE' },
        { key: 'reverse', icon: '⋔', label: 'REVERSE' },
        { key: 'retrieve', icon: '⋔', label: 'RETRIEVE' },
        { key: 'obsolesce', icon: '⋔', label: 'OBSOLESCE' }
      ];
      
      let hasChips = false;
      tetradMap.forEach(mapping => {
        const entry = tetradData[mapping.key];
        if (!entry || !entry.text) return;
        
        hasChips = true;
        const chip = document.createElement('div');
        chip.className = 'tetrad-chip-inline';
        chip.style.cssText = `
          flex: 1;
          min-width: 140px;
          padding: 8px 10px;
          background: var(--panel-dark);
          border: 1px solid var(--border);
          border-radius: 4px;
          cursor: pointer;
          transition: all 0.2s;
          display: flex;
          align-items: center;
          gap: 6px;
        `;
        
        const previewText = entry.text.substring(0, 50) + (entry.text.length > 50 ? '...' : '');
        chip.innerHTML = `
          <div style="display: flex; flex-direction: column; gap: 4px; width: 100%;">
            <div style="display: flex; align-items: center; gap: 6px;">
              <span style="font-size: 12px;">${mapping.icon}</span>
              <span style="font-size: 8px; font-weight: 700; text-transform: uppercase; opacity: 0.8; letter-spacing: 0.1em;">${mapping.label}</span>
              <span style="margin-left: auto; font-size: 8px; opacity: 0.6;">${entry.score || 0}</span>
            </div>
            <div style="font-size: 9px; opacity: 0.7; line-height: 1.3;">${previewText}</div>
          </div>
        `;
        chip.title = entry.text;
        
        chip.addEventListener('click', (e) => {
          e.stopPropagation();
          console.log('[TETRAD] Chip clicked:', mapping.key, entry.text);
          const textarea = channel.dom?.input;
          if (textarea) {
            textarea.value = entry.text;
            textarea.focus();
            textarea.style.height = 'auto';
            textarea.style.height = textarea.scrollHeight + 'px';
          }
        });
        
        chip.addEventListener('mouseenter', () => {
          chip.style.background = 'var(--accent)';
          chip.style.color = 'var(--bg)';
          chip.style.borderColor = 'var(--accent)';
        });
        
        chip.addEventListener('mouseleave', () => {
          chip.style.background = 'var(--panel-dark)';
          chip.style.color = '';
          chip.style.borderColor = 'var(--border)';
        });
        
        chipsWrap.appendChild(chip);
      });
      
      if (hasChips) {
        container.appendChild(chipsWrap);
        return container;
      }
      return null;
    }
    
    function createTetradChips(channel) {
      const tetradData = normalizeTetradData(channel);
      if (!tetradData) return null;
      
      const container = document.createElement('div');
      container.style.display = 'flex';
      container.style.flexWrap = 'wrap';
      container.style.gap = '6px';
      container.style.marginTop = '12px';
      ['enhance', 'reverse', 'retrieve', 'obsolesce'].forEach(key => {
        const entry = tetradData[key];
        if (!entry) return;
        const chip = document.createElement('button');
        chip.className = `tetrad-chip ${key}`;
        chip.textContent = key.toUpperCase();
        chip.title = entry.text;
        chip.addEventListener('click', (event) => {
          event.stopPropagation();
          chip.style.transform = 'scale(0.95)';
          setTimeout(() => chip.style.transform = '', 100);
          addMessageToChannel(channel, 'user', entry.text);
          if (appState.apiKey) {
            composeScene(channel, entry.text);
          } else {
            addMessageToChannel(channel, 'system', 'API key required for scene assembly.');
          }
        });
        container.appendChild(chip);
      });
      return container;
    }

    function addMessageToChannel(channel, role, text, extra = {}) {
      channel.addMessage(role, text, extra);
      renderChannelMessages(channel);
      persistState();
    }

    function renderTetradPanel(channel) {
      const tetradData = normalizeTetradData(channel);
      if (!tetradData) return;
      
      // Add tetrad as a special message type
      const tetradMessage = {
        role: 'tetrad',
        text: '', // Will be rendered specially
        tetradData: tetradData,
        timestamp: Date.now(),
        id: `tetrad-${Date.now()}`
      };
      
      // Always add tetrad as new message (each generation gets its own dot)
      channel.messages.push(tetradMessage);
      
      // Re-render messages to show tetrad
      renderChannelMessages(channel);
      persistState();
    }

    function openPerspectiveSelector(channel) {
      // Get all entities from the grid
      const entities = [];
      channel.grid.forEach((row, y) => {
        row.forEach((cell, x) => {
          if (cell && cell.type === 'Entity' && cell.label) {
            entities.push({label: cell.label, x, y, entity: cell.entity});
          }
        });
      });
      
      if (entities.length === 0) {
        addMessageToChannel(channel, 'system', 'No entities on grid. Add entities first to set perspective.');
        return;
      }
      
      // Create modal
      const modal = document.createElement('div');
      modal.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: min(90vw, 400px);
        max-height: 80vh;
        background: var(--panel);
        border: 2px solid var(--accent);
        border-radius: 8px;
        padding: 20px;
        z-index: 300;
        box-shadow: 0 20px 60px rgba(0,0,0,0.8);
        overflow-y: auto;
      `;
      
      const backdrop = document.createElement('div');
      backdrop.style.cssText = `
        position: fixed;
        inset: 0;
        background: rgba(0,0,0,0.7);
        backdrop-filter: blur(4px);
        z-index: 299;
      `;
      
      modal.innerHTML = `
        <h2 style="font-size: 14px; letter-spacing: 0.2em; color: var(--accent); margin-bottom: 16px; text-transform: uppercase;">
          👁 SELECT PERSPECTIVE
        </h2>
        <p style="font-size: 10px; color: var(--text-muted); margin-bottom: 16px; line-height: 1.5;">
          Choose an entity's perspective for tetrad generation. The tetrad will be generated from their point of view.
        </p>
        <div id="entity-list" style="display: grid; gap: 8px;"></div>
        <div style="margin-top: 16px; display: flex; gap: 8px;">
          <button id="clear-perspective" style="flex: 1; padding: 10px; background: var(--panel-dark); border: 1px solid var(--border); border-radius: 4px; cursor: pointer; font-size: 10px; text-transform: uppercase; letter-spacing: 0.1em;">
            CLEAR
          </button>
          <button id="close-perspective" style="flex: 1; padding: 10px; background: var(--accent); color: var(--bg); border: none; border-radius: 4px; cursor: pointer; font-size: 10px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.1em;">
            CLOSE
          </button>
        </div>
      `;
      
      const entityList = modal.querySelector('#entity-list');
      entities.forEach(ent => {
        const btn = document.createElement('button');
        btn.style.cssText = `
          padding: 12px;
          background: ${channel.tetradPerspective === ent.label ? 'var(--accent)' : 'var(--panel-dark)'};
          color: ${channel.tetradPerspective === ent.label ? 'var(--bg)' : 'var(--text)'};
          border: 2px solid ${channel.tetradPerspective === ent.label ? 'var(--accent)' : 'var(--border)'};
          border-radius: 6px;
          cursor: pointer;
          text-align: left;
          font-size: 11px;
          font-weight: ${channel.tetradPerspective === ent.label ? '700' : '400'};
          transition: all 0.2s;
        `;
        
        btn.innerHTML = `
          <div style="font-weight: 700; margin-bottom: 4px;">${ent.label.toUpperCase()}</div>
          <div style="font-size: 9px; opacity: 0.7;">Position: (${ent.x}, ${ent.y})</div>
        `;
        
        btn.addEventListener('click', async () => {
          // Flash selected button
          btn.style.background = 'var(--accent)';
          btn.style.transform = 'scale(1.05)';
          btn.style.boxShadow = '0 0 20px var(--accent-glow)';
          
          setTimeout(() => {
            channel.tetradPerspective = ent.label;
            modal.remove();
            backdrop.remove();
            
            // Show visual feedback on grid
            const gridCell = channel.dom.gridEl?.querySelector(`[data-x="${ent.x}"][data-y="${ent.y}"]`);
            if (gridCell) {
              gridCell.style.animation = 'pulse 1s ease-in-out 3';
              gridCell.style.boxShadow = '0 0 30px var(--accent-glow)';
              setTimeout(() => {
                gridCell.style.animation = '';
                gridCell.style.boxShadow = '';
              }, 3000);
            }
            
            // Regenerate tetrad from this perspective
            if (channel.lastScene) {
              regenerateTetrad(channel);
            }
            
            // Re-render messages to update button
            renderChannelMessages(channel);
          }, 200);
        });
        
        btn.addEventListener('mouseenter', () => {
          if (channel.tetradPerspective !== ent.label) {
            btn.style.background = 'var(--border)';
          }
        });
        
        btn.addEventListener('mouseleave', () => {
          if (channel.tetradPerspective !== ent.label) {
            btn.style.background = 'var(--panel-dark)';
          }
        });
        
        entityList.appendChild(btn);
      });
      
      modal.querySelector('#clear-perspective').addEventListener('click', () => {
        channel.tetradPerspective = null;
        modal.remove();
        backdrop.remove();
        renderChannelMessages(channel);
      });
      
      modal.querySelector('#close-perspective').addEventListener('click', () => {
        modal.remove();
        backdrop.remove();
      });
      
      backdrop.addEventListener('click', () => {
        modal.remove();
        backdrop.remove();
      });
      
      document.body.appendChild(backdrop);
      document.body.appendChild(modal);
    }
    
    async function regenerateTetrad(channel) {
      if (channel.pendingTetrad) return;
      if (!channel.lastScene) {
        addMessageToChannel(channel, 'system', 'Compose a scene before requesting tetrad options.');
        return;
      }
      try {
        channel.pendingTetrad = true;
        
        // Show loading message
        addMessageToChannel(channel, 'system', `✨ Generating tetrad ${channel.tetradPerspective ? `from ${channel.tetradPerspective}'s perspective` : 'options'}...`);
        
        // Animate grid during regeneration
        const gridCells = channel.dom.gridEl?.querySelectorAll('.grid-cell');
        gridCells?.forEach((cell, idx) => {
          cell.style.animation = `pulse 1.5s ease-in-out infinite`;
          cell.style.animationDelay = `${(idx * 0.03) % 0.5}s`;
        });
        
        renderTetradPanel(channel);
        const tetrad = await callOpenAI('TetradGenerator', {
          scenario: scenarios[channel.scenario],
          scene: channel.lastScene,
          history: channel.messages.slice(-2).map(m => ({ role: m.role, text: m.text })),
          perspective: channel.tetradPerspective || null
        });
        channel.tetrad = tetrad;
        persistState();
        
        // Stop animation
        gridCells?.forEach((cell) => {
          cell.style.animation = '';
        });
        
        // Flash effect
        channel.dom.column?.classList.add('reveal');
        setTimeout(() => channel.dom.column?.classList.remove('reveal'), 500);
        
        // Add tetrad as message (this creates the tetrad message object)
        renderTetradPanel(channel);
        playRevealChime();
      } catch (err) {
        addMessageToChannel(channel, 'system', `Tetrad generation failed: ${err.message}`);
        // Stop animation on error
        const gridCells = channel.dom.gridEl?.querySelectorAll('.grid-cell');
        gridCells?.forEach((cell) => {
          cell.style.animation = '';
        });
      } finally {
        channel.pendingTetrad = false;
        renderTetradPanel(channel);
      }
    }

    function openTetradMenu(channel) {
      // Disabled - tetrad chips now appear inline in messages only
      return;
      
      const tetradData = normalizeTetradData(channel);
      
      if (!tetradData) {
        if (!channel.lastScene) {
          addMessageToChannel(channel, 'system', 'Compose a scene first to unlock tetrad options.');
          return;
        }
        // Auto-generate if not present
        regenerateTetrad(channel);
        return;
      }
      
      const modal = document.createElement('div');
      modal.className = 'tetrad-menu-modal';
      modal.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: min(90vw, 400px);
        background: var(--panel);
        border: 2px solid var(--accent);
        border-radius: 8px;
        padding: 24px;
        z-index: 300;
        box-shadow: 0 20px 60px rgba(0,0,0,0.8);
      `;
      
      const backdrop = document.createElement('div');
      backdrop.style.cssText = `
        position: fixed;
        inset: 0;
        background: rgba(0,0,0,0.7);
        backdrop-filter: blur(4px);
        z-index: 299;
      `;
      
      const header = document.createElement('div');
      header.style.cssText = 'display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;';
      header.innerHTML = `
        <h2 style="font-size: 14px; letter-spacing: 0.2em; color: var(--accent);">TETRAD TRAJECTORIES</h2>
        <button style="width: 32px; height: 32px; border-radius: 50%; border: 1px solid var(--border); background: var(--panel-dark); color: var(--text); cursor: pointer;" onclick="this.closest('.tetrad-menu-modal').remove(); document.querySelectorAll('[style*=backdrop-filter]')[0]?.remove();">×</button>
      `;
      
      const grid = document.createElement('div');
      grid.style.cssText = 'display: grid; grid-template-columns: repeat(2, 1fr); gap: 12px;';
      
      const tetradMap = [
        { key: 'enhance', icon: '▲', label: 'ENHANCE' },
        { key: 'reverse', icon: '⇄', label: 'REVERSE' },
        { key: 'retrieve', icon: '↺', label: 'RETRIEVE' },
        { key: 'obsolesce', icon: '▼', label: 'OBSOLESCE' }
      ];
      
      console.log('[TETRAD MENU] Opening with data:', tetradData);
      
      tetradMap.forEach(mapping => {
        const entry = tetradData[mapping.key];
        if (!entry) {
          console.log('[TETRAD MENU] Missing entry for:', mapping.key);
          return;
        }
        
        const btn = document.createElement('button');
        btn.style.cssText = `
          padding: 20px;
          background: var(--panel-dark);
          border: 3px solid var(--border);
          border-radius: 8px;
          cursor: pointer;
          transition: all 0.2s var(--transition);
          display: flex;
          flex-direction: column;
          align-items: center;
          gap: 12px;
          box-shadow: 0 2px 0 var(--border), inset 0 1px 0 rgba(255,255,255,0.1);
        `;
        
        btn.innerHTML = `
          <div style="font-size: 32px; color: var(--accent);">${mapping.icon}</div>
          <div style="font-size: 10px; letter-spacing: 0.2em; color: var(--text); font-weight: bold;">${mapping.label}</div>
          <div style="font-size: 8px; color: var(--text-muted); text-align: center; line-height: 1.4; max-height: 60px; overflow: hidden;">${entry.text.substring(0, 80)}...</div>
        `;
        
        btn.addEventListener('mouseenter', () => {
          btn.style.background = 'var(--accent)';
          btn.style.color = 'var(--bg)';
          btn.style.transform = 'scale(1.02)';
        });
        
        btn.addEventListener('mouseleave', () => {
          btn.style.background = 'var(--panel-dark)';
          btn.style.color = '';
          btn.style.transform = '';
        });
        
        btn.addEventListener('click', async () => {
          btn.style.transform = 'scale(0.95) translateY(2px)';
          btn.style.boxShadow = '0 0 0 var(--border)';
          
          modal.remove();
          backdrop.remove();
          
          addMessageToChannel(channel, 'user', entry.text);
          if (appState.apiKey) {
            await composeScene(channel, entry.text);
          } else {
            addMessageToChannel(channel, 'system', 'API key required for scene assembly.');
          }
        });
        
        grid.appendChild(btn);
      });
      
      modal.appendChild(header);
      modal.appendChild(grid);
      document.body.appendChild(backdrop);
      document.body.appendChild(modal);
      
      backdrop.addEventListener('click', () => {
        modal.remove();
        backdrop.remove();
      });
    }

    function openRingOverview(channel) {
      const modal = document.createElement('div');
      modal.className = 'ring-overview-modal';
      modal.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: min(90vw, 600px);
        max-height: 80vh;
        background: var(--panel);
        border: 2px solid var(--accent);
        border-radius: 8px;
        padding: 24px;
        z-index: 300;
        overflow-y: auto;
        box-shadow: 0 20px 60px rgba(0,0,0,0.8);
      `;
      
      const backdrop = document.createElement('div');
      backdrop.style.cssText = `
        position: fixed;
        inset: 0;
        background: rgba(0,0,0,0.7);
        backdrop-filter: blur(4px);
        z-index: 299;
      `;
      
      const header = document.createElement('div');
      header.style.cssText = 'display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;';
      
      const title = document.createElement('h2');
      title.style.cssText = 'font-size: 14px; letter-spacing: 0.2em; color: var(--accent);';
      title.textContent = 'RING MEMORY TIMELINE';
      
      const controls = document.createElement('div');
      controls.style.cssText = 'display: flex; gap: 8px; align-items: center;';
      
      const exportBtn = document.createElement('button');
      exportBtn.style.cssText = `
        padding: 6px 12px;
        border-radius: 4px;
        border: 1px solid var(--accent);
        background: var(--panel-dark);
        color: var(--accent);
        cursor: pointer;
        font-size: 9px;
        letter-spacing: 0.1em;
        transition: all 0.2s;
      `;
      exportBtn.textContent = 'EXPORT';
      exportBtn.addEventListener('click', () => {
        const data = {
          exported: new Date().toISOString(),
          ringMemory: ringMemory,
          channels: appState.channels.map(ch => ({
            id: ch.id,
            name: ch.name,
            scenario: ch.scenario,
            channelColor: ch.channelColor,
            ledgerCount: ch.ledger?.length || 0
          }))
        };
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `legos-ring-memory-${Date.now()}.json`;
        a.click();
        URL.revokeObjectURL(url);
      });
      exportBtn.addEventListener('mouseenter', () => {
        exportBtn.style.background = 'var(--accent)';
        exportBtn.style.color = 'var(--bg)';
      });
      exportBtn.addEventListener('mouseleave', () => {
        exportBtn.style.background = 'var(--panel-dark)';
        exportBtn.style.color = 'var(--accent)';
      });
      
      const closeBtn = document.createElement('button');
      closeBtn.style.cssText = 'width: 32px; height: 32px; border-radius: 50%; border: 1px solid var(--border); background: var(--panel-dark); color: var(--text); cursor: pointer;';
      closeBtn.textContent = '×';
      closeBtn.addEventListener('click', () => {
        modal.remove();
        backdrop.remove();
      });
      
      controls.appendChild(exportBtn);
      controls.appendChild(closeBtn);
      header.appendChild(title);
      header.appendChild(controls);
      
      const content = document.createElement('div');
      content.style.cssText = 'display: flex; flex-direction: column; gap: 12px;';
      
      if (ringMemory.entries.length === 0) {
        content.innerHTML = '<p style="color: var(--text-muted); text-align: center;">No ring memory entries yet. Compose scenes to build your timeline.</p>';
      } else {
        ringMemory.entries.forEach((entry, idx) => {
          const item = document.createElement('div');
          item.style.cssText = `
            padding: 16px;
            background: ${entry.channelId === channel.id ? 'var(--accent-soft)' : 'var(--panel-dark)'};
            border: 1px solid ${entry.isMainline ? 'var(--accent)' : 'var(--border)'};
            border-left: 4px solid ${channelMap.get(entry.channelId)?.channelColor || 'var(--accent)'};
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s var(--transition);
          `;
          
          item.innerHTML = `
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
              <span style="font-size: 10px; letter-spacing: 0.2em; color: var(--text-muted);">${entry.symbol} ${entry.isMainline ? '(MAINLINE)' : ''}</span>
              <span style="font-size: 8px; color: var(--text-muted);">${new Date(entry.timestamp).toLocaleTimeString()}</span>
            </div>
            <div style="font-size: 12px; font-weight: bold; color: var(--text); margin-bottom: 6px;">${entry.headline || 'Untitled'}</div>
            <div style="font-size: 10px; color: var(--text-muted); line-height: 1.5;">${(entry.summary || '').substring(0, 120)}${entry.summary?.length > 120 ? '...' : ''}</div>
          `;
          
          item.addEventListener('click', () => {
            const targetChannel = channelMap.get(entry.channelId);
            if (targetChannel) {
              focusChannel(entry.channelId);
              modal.remove();
              backdrop.remove();
            }
          });
          
          item.addEventListener('mouseenter', () => {
            item.style.background = 'var(--accent-soft)';
            item.style.transform = 'translateX(4px)';
          });
          
          item.addEventListener('mouseleave', () => {
            item.style.background = entry.channelId === channel.id ? 'var(--accent-soft)' : 'var(--panel-dark)';
            item.style.transform = 'translateX(0)';
          });
          
          content.appendChild(item);
        });
      }
      
      modal.appendChild(header);
      modal.appendChild(content);
      document.body.appendChild(backdrop);
      document.body.appendChild(modal);
      
      backdrop.addEventListener('click', () => {
        modal.remove();
        backdrop.remove();
      });
    }

    function openSnapshotOverlay(channel) {
      snapshotOverlayChannel = channel;
      renderSnapshotOverlay();
      document.querySelectorAll('.corner-menu.visible').forEach(menu => menu.classList.remove('visible'));
      const overlay = document.getElementById('snapshotOverlay');
      if (overlay) overlay.classList.add('active');
    }

    function renderSnapshotOverlay() {
      const overlay = document.getElementById('snapshotOverlay');
      if (!overlay || !snapshotOverlayChannel) return;
      const list = document.getElementById('snapshotOverlayList');
      const status = document.getElementById('snapshotStatus');
      const snapshots = snapshotOverlayChannel.snapshots || [];
      status.textContent = snapshots.length
        ? `${snapshots.length} saved state${snapshots.length === 1 ? '' : 's'}.`
        : 'No snapshots saved yet.';
      list.innerHTML = '';
      snapshots.slice().reverse().forEach(snapshot => {
        const item = document.createElement('div');
        item.className = 'snapshot-overlay-item';

        const meta = document.createElement('div');
        meta.className = 'snapshot-overlay-meta';
        const label = document.createElement('span');
        label.textContent = snapshot.name.toUpperCase();
        const time = document.createElement('span');
        time.textContent = new Date(snapshot.timestamp).toLocaleString();
        meta.appendChild(label);
        meta.appendChild(time);
        item.appendChild(meta);

        const info = document.createElement('div');
        info.className = 'overlay-value';
        const title = snapshot.lastScene?.sceneTitle ? `Last: ${snapshot.lastScene.sceneTitle}` : 'Last: —';
        info.textContent = `${snapshot.ledgerLength || 0} scenes captured • ${title}`;
        item.appendChild(info);

        const actions = document.createElement('div');
        actions.className = 'snapshot-overlay-actions';
        const loadBtn = document.createElement('button');
        loadBtn.className = 'secondary-btn';
        loadBtn.textContent = 'LOAD';
        loadBtn.addEventListener('click', () => {
          loadSnapshot(snapshotOverlayChannel, snapshot.id);
          document.getElementById('snapshotOverlay').classList.remove('active');
          snapshotOverlayChannel = null;
        });
        const forkBtn = document.createElement('button');
        forkBtn.className = 'primary-btn';
        forkBtn.textContent = 'FORK';
        forkBtn.addEventListener('click', () => {
          const baseMessage = snapshotOverlayChannel.messages[snapshotOverlayChannel.messages.length - 1] || { id: null };
          forkChannel(snapshotOverlayChannel, baseMessage, 'snapshot', { snapshotId: snapshot.id });
          document.getElementById('snapshotOverlay').classList.remove('active');
          snapshotOverlayChannel = null;
        });
        actions.appendChild(loadBtn);
        actions.appendChild(forkBtn);
        item.appendChild(actions);

        list.appendChild(item);
      });
    }

    const snapshotOverlayElement = document.getElementById('snapshotOverlay');
    const snapshotCreateBtn = document.getElementById('snapshotCreateBtn');
    if (snapshotOverlayElement) {
      snapshotOverlayElement.addEventListener('click', (event) => {
        if (event.target === snapshotOverlayElement) {
          snapshotOverlayElement.classList.remove('active');
          snapshotOverlayChannel = null;
        }
      });
      const snapshotCard = snapshotOverlayElement.querySelector('.overlay-card');
      if (snapshotCard) {
        snapshotCard.addEventListener('click', (event) => event.stopPropagation());
      }
    }

    if (snapshotCreateBtn) {
      snapshotCreateBtn.addEventListener('click', () => {
        if (!snapshotOverlayChannel) return;
        const nextIndex = snapshotOverlayChannel.snapshots.length + 1;
        const label = window.prompt('Snapshot name?', `Snapshot ${nextIndex}`);
        if (label === null) return;
        const snap = snapshotOverlayChannel.createSnapshot(label.trim() || `Snapshot ${nextIndex}`);
        logRingEntry({
          type: 'snapshot',
          channelId: snapshotOverlayChannel.id,
          channelName: snapshotOverlayChannel.name,
          symbol: snap.name,
          headline: 'Snapshot saved',
          summary: `${snap.ledgerLength || 0} scenes captured`
        });
        renderSnapshotOverlay();
        persistState();
        showHelpBanner(`Snapshot saved: ${snap.name}`);
      });
    }


    function loadSnapshot(channel, snapshotId) {
      const snap = channel.snapshots.find(s => s.id === snapshotId);
      if (!snap) return;
      channel.grid = deepClone(snap.grid);
      channel.cells = deepClone(snap.cells);
      channel.observer = deepClone(snap.observer);
      channel.scorecard = deepClone(snap.scorecard);
      channel.tetrad = deepClone(snap.tetrad);
      channel.lastScene = deepClone(snap.lastScene);
      renderChannel(channel);
      persistState();
      showHelpBanner(`Snapshot loaded into ${channel.name}`);
      if (snapshotOverlayChannel === channel) {
        renderSnapshotOverlay();
      }
    }

    function renderTimeline() {
      appState.channels.forEach((channel, channelIdx) => {
        const rail = channel.dom?.channelRail;
        if (!rail) return;
        rail.innerHTML = '';
        
        // Show all channel numbers (scrollable list)
        appState.channels.forEach((target, idx) => {
          const button = document.createElement('button');
          button.className = 'channel-number';
          button.textContent = idx + 1;
          button.title = target.name;
          button.style.borderColor = target.channelColor;
          button.style.color = target.channelColor;
          
          // Each channel shows ITS OWN number lit up
          if (target.id === channel.id) {
            // This is the channel's own number - LIGHT IT UP
            button.classList.add('active');
            button.style.backgroundColor = target.channelColor;
            button.style.color = getComputedStyle(document.body).getPropertyValue('--bg');
            button.style.opacity = '1';
          } else {
            // Other channels - visible and ready
            button.style.opacity = '0.7';
          }
          
          button.addEventListener('click', (event) => {
            event.stopPropagation();
            focusChannel(target.id);
          });
          rail.appendChild(button);
        });
        const add = document.createElement('button');
        add.className = 'channel-number add';
        add.textContent = '+';
        add.title = 'Add channel';
        add.style.borderColor = getComputedStyle(document.body).getPropertyValue('--accent');
        add.style.color = getComputedStyle(document.body).getPropertyValue('--accent');
        add.addEventListener('click', (event) => {
          event.stopPropagation();
          const created = createChannel({ scenario: 'blank' });
          focusChannel(created.id);
        });
        rail.appendChild(add);
      });
    }

    function animateChannelTransition(fromChannel, toChannel) {
      const fromEl = fromChannel.dom?.column;
      const toEl = toChannel.dom?.column;
      if (!fromEl || !toEl) return;
      
      const fromRect = fromEl.getBoundingClientRect();
      const toRect = toEl.getBoundingClientRect();
      
      const ball = document.createElement('div');
      ball.style.cssText = `
        position: fixed;
        width: 24px;
        height: 24px;
        border-radius: 50%;
        background: ${fromChannel.channelColor};
        border: 3px solid ${toChannel.channelColor};
        box-shadow: 0 0 20px ${fromChannel.channelColor}, inset 0 0 10px ${toChannel.channelColor};
        z-index: 1000;
        pointer-events: none;
        left: ${fromRect.left + fromRect.width / 2 - 12}px;
        top: ${fromRect.top + fromRect.height / 2 - 12}px;
        transition: all 0.8s cubic-bezier(0.4, 0, 0.2, 1);
      `;
      
      document.body.appendChild(ball);
      
      requestAnimationFrame(() => {
        ball.style.left = `${toRect.left + toRect.width / 2 - 12}px`;
        ball.style.top = `${toRect.top + toRect.height / 2 - 12}px`;
        ball.style.transform = 'scale(1.5)';
        ball.style.opacity = '0.8';
      });
      
      setTimeout(() => {
        ball.style.opacity = '0';
        ball.style.transform = 'scale(0.5)';
        setTimeout(() => ball.remove(), 300);
      }, 800);
    }

    function focusChannel(channelId) {
      // Set as current
      appState.currentChannelId = channelId;
      
      // Get the channel element
      const element = document.querySelector(`[data-channel-id="${channelId}"]`);
      if (!element) return;
      
      // Scroll to it NOW - smooth and to the left edge
      const scroller = document.getElementById('channelScroller');
      if (scroller) {
        scroller.scrollTo({
          left: element.offsetLeft,
          behavior: 'smooth'
        });
      }
      
      // Remove active from all
      document.querySelectorAll('.channel-column').forEach(col => {
        col.classList.remove('channel-active');
      });
      
      // Add active to this one
      element.classList.add('channel-active');
      
      // Update timeline to show which number is lit
      renderTimeline();
      
      // Get active channel and scroll its number to top
      const activeChannel = appState.channels.find(ch => ch.id === channelId);
      const channelIndex = appState.channels.findIndex(ch => ch.id === channelId);
      
      // If page is bright, scroll its number to the top
      if (activeChannel?.dom?.channelRail && channelIndex !== -1) {
        setTimeout(() => {
          const rail = activeChannel.dom.channelRail;
          const buttons = Array.from(rail.querySelectorAll('.channel-number'));
          const activeButton = buttons[channelIndex];
          if (activeButton) {
            activeButton.scrollIntoView({ behavior: 'smooth', block: 'start' });
          }
        }, 100);
      }
      
      // Update global scenario
      const globalScenarioSelect = document.getElementById('globalScenarioSelect');
      if (activeChannel && globalScenarioSelect) {
        globalScenarioSelect.value = activeChannel.scenario;
      }
      
      persistState();
    }

    function refreshAllChannels() {
      appState.channels.forEach(channel => renderChannel(channel));
    }
    
    function setupChannelVisibilityObserver() {
      const scroller = document.querySelector('.channel-scroller');
      if (!scroller) return;
      
      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting && entry.intersectionRatio > 0.5) {
            const channelId = entry.target.dataset.channelId;
            if (channelId && channelId !== appState.currentChannelId) {
              appState.currentChannelId = channelId;
              renderTimeline();
              
              // Update active channel highlighting
              document.querySelectorAll('.channel-column').forEach(col => {
                col.classList.remove('channel-active');
              });
              entry.target.classList.add('channel-active');
            }
          }
        });
      }, {
        root: scroller,
        threshold: 0.5
      });
      
      document.querySelectorAll('.channel-column[data-channel-id]').forEach(col => {
        observer.observe(col);
      });
    }

    async function composeScene(channel, message) {
      if (channel.pending) return;
      channel.pending = true;
      channel.dom.sendBtn.disabled = true;
      channel.dom.column.classList.add('composing');
      const gridCells = channel.dom.gridEl?.querySelectorAll('.grid-cell');
      // Use the user's actual prompt text for animation!
      const composeText = (message || '').toUpperCase().replace(/[^A-Z0-9\s]/g, '').replace(/\s+/g, '');
      const entropy = []; // Collect entropy from random walks
      
      console.log('[ANIMATION] Using prompt text:', composeText);
      
      gridCells?.forEach((cell, idx) => {
        cell.classList.add('loading');
        cell.style.animationDelay = `${(idx * 0.05) % 0.8}s`;
      });
      
      // Start random walk letters
      const walkLetters = (iterations = 0) => {
        if (iterations > 20 || !channel.pending) return;
        
        // Spawn new walkers
        const numWalkers = Math.floor(Math.random() * 3) + 2;
        for (let i = 0; i < numWalkers; i++) {
          const letter = composeText[Math.floor(Math.random() * composeText.length)] || 'C';
          let currentIdx = Math.floor(Math.random() * 81);
          
          // Random walk algorithm
          const walk = (steps = 0) => {
            if (steps > 8 || !channel.pending) {
              gridCells[currentIdx]?.classList.remove('composing-active');
              gridCells[currentIdx]?.removeAttribute('data-compose-letter');
              return;
            }
            
            // Remove from old cell
            gridCells[currentIdx]?.classList.remove('composing-active');
            
            // Calculate next position (random walk on 9x9 grid)
            const x = currentIdx % 9;
            const y = Math.floor(currentIdx / 9);
            const moves = [];
            if (x > 0) moves.push(currentIdx - 1);     // left
            if (x < 8) moves.push(currentIdx + 1);     // right
            if (y > 0) moves.push(currentIdx - 9);     // up
            if (y < 8) moves.push(currentIdx + 9);     // down
            
            // Add diagonal moves (Monte Carlo style)
            if (x > 0 && y > 0) moves.push(currentIdx - 10); // up-left
            if (x < 8 && y > 0) moves.push(currentIdx - 8);  // up-right
            if (x > 0 && y < 8) moves.push(currentIdx + 8);  // down-left
            if (x < 8 && y < 8) moves.push(currentIdx + 10); // down-right
            
            // Pick random move and record entropy
            const moveIdx = Math.floor(Math.random() * moves.length);
            currentIdx = moves[moveIdx];
            entropy.push(moveIdx); // Dice roll data!
            
            // Add to new cell
            const cell = gridCells[currentIdx];
            if (cell) {
              cell.setAttribute('data-compose-letter', letter);
              cell.classList.add('composing-active');
            }
            
            // Continue walk
            setTimeout(() => walk(steps + 1), 150 + Math.random() * 100);
          };
          
          walk();
        }
        
        setTimeout(() => walkLetters(iterations + 1), 600);
      };
      
      walkLetters();
      
      // Store entropy for use as randomness source
      channel.entropy = entropy;
      await initSound();
      playComposingTick();
      const tickInterval = setInterval(() => playComposingTick(), 800);
      addMessageToChannel(channel, 'system', 'Composing scene…', { autoCollapse: true });
      try {
        const payload = {
          rules: createRuleContract(),
          currentState: channel.lastScene,
          scenario: scenarios[channel.scenario],
          message,
          history: channel.messages.slice(-6).map(m => ({ role: m.role, text: m.text }))
        };
        const scene = await callOpenAI('SceneAssembler', payload);
        channel.pendingTetrad = true;
        applyScene(channel, scene);
        const ringEntry = logRingEntry({
          type: 'scene',
          channelId: channel.id,
          channelName: channel.name,
          symbol: channel.name,
          headline: scene.sceneTitle || '',
          summary: scene.sceneSummary || ''
        });
        if (!channel.ringBinding) {
          channel.ringBinding = ringEntry.id;
        }
        
        // Only auto-generate tetrad if tetradMode is enabled
        if (channel.tetradMode) {
          const tetrad = await callOpenAI('TetradGenerator', {
            scenario: scenarios[channel.scenario],
            scene,
            history: channel.messages.slice(-2).map(m => ({ role: m.role, text: m.text })),
            perspective: channel.tetradPerspective || null
          });
          channel.tetrad = tetrad;
          renderTetradPanel(channel);
          persistState();
          playRevealChime();
          const lastMsg = channel.dom.messageList?.lastElementChild;
          if (lastMsg) lastMsg.classList.add('reveal');
        }
      } catch (err) {
        console.error('Scene assembly error:', err);
        const errorDetail = err.stack || err.message || String(err);
        addMessageToChannel(channel, 'system', `Scene assembly failed:\n${errorDetail}`);
      } finally {
        clearInterval(tickInterval);
        channel.dom.column.classList.remove('composing');
        const gridCells = channel.dom.gridEl?.querySelectorAll('.grid-cell');
        gridCells?.forEach(cell => {
          cell.classList.remove('loading');
          cell.classList.remove('composing-active');
          cell.removeAttribute('data-compose-letter');
        });
        channel.pending = false;
        channel.dom.sendBtn.disabled = false;
        channel.pendingTetrad = false;
        renderTetradPanel(channel);
      }
    }

    function createRuleContract() {
      return {
        blockTypes: blockPalette.map(p => p.type),
        gridSize: 9,
        maxPlacements: 18,
        schema: {
          sceneTitle: 'string',
          sceneSummary: 'string',
          entities: [{
            id: 'slug',
            type: 'blockType',
            name: 'string',
            location: 'slug|optional',
            relations: [{ type: 'string', target: 'slug' }]
          }],
          gridMapping: [{
            id: 'slug',
            type: 'blockType',
            label: 'string|optional',
            x: '0..8',
            y: '0..8'
          }],
          plot: {
            prior: { caution: '0..1', progress: '0..1' },
            posterior: { caution: '0..1', progress: '0..1' }
          },
          direction: 'up|down|left|right',
          tension: '0..1',
          scorecard: {
            progress: '0..1',
            caution: '0..1',
            movesRemaining: 'int',
            goalDistance: 'int'
          }
        }
      };
    }

    async function callOpenAI(kind, payload) {
      if (!appState.apiKey) {
        throw new Error('Missing API key. Click ◎ in corner menu to set your OpenAI API key.');
      }
      
      console.log('═══════════════════════════════════════');
      console.log('[API CALL] Type:', kind);
      console.log('[API CALL] API Key length:', appState.apiKey.length);
      console.log('[API CALL] Payload:', JSON.stringify(payload, null, 2));
      
      const prompts = {
        SceneAssembler: [
          {
            role: 'system',
            content: [
              'You are LEGOS-G (Liberation Engine Grid Ontology Synthesizer) - a HYPERCLAY world sculptor.',
              'Return valid JSON matching the schema provided.',
              'Place 8-14 elements on a 9x9 grid. Coordinates are 0-8.',
              'CRITICAL: BE TRANSFORMATIVE, NOT CONSERVATIVE.',
              '- REMOVE elements that are no longer relevant (2-4 removals per beat)',
              '- ADD new elements that emerge from the narrative (2-4 additions per beat)',
              '- Change entity states and conditions dramatically',
              '- Introduce new objects, environments, or complications',
              '- Remove obstacles once overcome, add new ones',
              '- The grid should feel ALIVE and REACTIVE, not static',
              'AVOID: Just shuffling existing elements around. That is boring.',
              'DO: Transform the scene. New entities appear, old ones vanish, the world reshapes itself.',
              'Position proximity = relationship strength. Distant = tension/separation.',
              'Use the full grid space. Create visual patterns that mirror story dynamics.',
              'Entity names should be full, memorable words (not truncated).',
              'Keep IDs consistent only for persistent elements. Generate new IDs for new elements.',
              'Update scorecard (progress 0-1, movesRemaining int, goalDistance int).'
            ].join(' ')
          },
          { role: 'user', content: JSON.stringify(payload) }
        ],
        TetradGenerator: [
          {
            role: 'system',
            content: payload.perspective
              ? `Generate TRANSFORMATIVE tetrad entries from ${payload.perspective}'s perspective. Each entry should CHANGE THE SCENE dramatically: add new elements, remove old ones, alter states. ENHANCE: what new elements/complications appear? REVERSE: what inverts or transforms? RETRIEVE: what returns or emerges? OBSOLESCE: what vanishes or fades? Be specific about entities/objects entering or leaving. Motivations: ${payload.perspective}'s desires/fears. Text <= 80 words, score 0-100. Return JSON with EXACT format: {"enhance": {"text": "...", "score": 75}, "reverse": {"text": "...", "score": 60}, "retrieve": {"text": "...", "score": 70}, "obsolesce": {"text": "...", "score": 80}}`
              : 'Generate TRANSFORMATIVE tetrad entries. Each must CHANGE THE SCENE: ENHANCE adds new elements/complications, REVERSE transforms existing ones, RETRIEVE brings back elements, OBSOLESCE removes elements. Be specific about what enters or exits the grid. Text <= 80 words, score 0-100. Return JSON with EXACT format: {"enhance": {"text": "...", "score": 75}, "reverse": {"text": "...", "score": 60}, "retrieve": {"text": "...", "score": 70}, "obsolesce": {"text": "...", "score": 80}}'
          },
          { role: 'user', content: JSON.stringify(payload) }
        ]
      };

      const requestBody = {
        model: 'gpt-4o-mini',
        temperature: kind === 'SceneAssembler' ? 0.7 : 0.8,
        messages: prompts[kind],
        max_tokens: kind === 'SceneAssembler' ? 2500 : 600,
        response_format: { type: 'json_object' }
      };
      
      console.log('[API CALL] Model:', requestBody.model);
      console.log('[API CALL] Temperature:', requestBody.temperature);
      console.log('[API CALL] Max Tokens:', requestBody.max_tokens);
      console.log('[API CALL] Messages:', prompts[kind].length, 'messages');
      prompts[kind].forEach((msg, idx) => {
        console.log(`  [${idx}] ${msg.role}:`, msg.content.substring(0, 100) + (msg.content.length > 100 ? '...' : ''));
      });
      
      let response;
      try {
        console.log('[API CALL] Sending request to OpenAI...');
        const startTime = Date.now();
        
        response = await fetch('https://api.openai.com/v1/chat/completions', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${appState.apiKey}`
          },
          body: JSON.stringify(requestBody)
        });
        
        const duration = Date.now() - startTime;
        console.log('[API RESPONSE] Status:', response.status, 'Duration:', duration + 'ms');
      } catch (fetchError) {
        console.error('[API ERROR] Fetch failed:', fetchError);
        console.error('[API ERROR] Error details:', {
          message: fetchError.message,
          name: fetchError.name,
          stack: fetchError.stack
        });
        throw new Error(`Network error: Cannot reach OpenAI API. Check your internet connection and API key. ${fetchError.message}`);
      }
      
      if (!response.ok) {
        const text = await response.text();
        console.error('[API] HTTP error:', response.status, text);
        if (response.status === 401) {
          throw new Error(`Invalid API key. Please check your OpenAI API key in corner menu (◎).`);
        } else if (response.status === 429) {
          throw new Error(`Rate limit exceeded. Please wait a moment and try again.`);
        }
        throw new Error(`HTTP ${response.status}: ${text}`);
      }
      const data = await response.json();
      console.log('[API RESPONSE] Usage:', data.usage);
      console.log('[API RESPONSE] Model:', data.model);
      console.log('[API RESPONSE] Finish reason:', data.choices?.[0]?.finish_reason);
      
      const raw = data.choices?.[0]?.message?.content;
      if (!raw) {
        console.error('[API ERROR] Empty response from API');
        throw new Error('Empty response from API.');
      }
      
      console.log('[API RESPONSE] Content length:', raw.length, 'characters');
      console.log('[API RESPONSE] Content preview:', raw.substring(0, 200) + (raw.length > 200 ? '...' : ''));
      
      try {
        const parsed = JSON.parse(raw);
        console.log('[API SUCCESS] Parsed JSON successfully');
        console.log('═══════════════════════════════════════\n');
        return parsed;
      } catch (parseErr) {
        console.error('[API ERROR] JSON parse error:', parseErr);
        console.error('[API ERROR] Raw response:', raw);
        
        // Try to repair truncated JSON by closing open structures
        console.log('[API REPAIR] Attempting to repair truncated JSON...');
        let repaired = raw.trim();
        
        // Count open braces/brackets
        const openBraces = (repaired.match(/\{/g) || []).length;
        const closeBraces = (repaired.match(/\}/g) || []).length;
        const openBrackets = (repaired.match(/\[/g) || []).length;
        const closeBrackets = (repaired.match(/\]/g) || []).length;
        
        // Remove incomplete string at end
        if (repaired.endsWith('"')) {
          repaired = repaired.slice(0, -1) + '" ';
        } else if (!repaired.endsWith('}') && !repaired.endsWith(']')) {
          // Find last complete property
          const lastComma = repaired.lastIndexOf(',');
          const lastBrace = repaired.lastIndexOf('}');
          const lastBracket = repaired.lastIndexOf(']');
          const cutPoint = Math.max(lastComma, lastBrace, lastBracket);
          if (cutPoint > 0) {
            repaired = repaired.substring(0, cutPoint + 1);
          }
        }
        
        // Close open arrays
        for (let i = 0; i < openBrackets - closeBrackets; i++) {
          repaired += ']';
        }
        
        // Close open objects
        for (let i = 0; i < openBraces - closeBraces; i++) {
          repaired += '}';
        }
        
        console.log('[API REPAIR] Repaired JSON:', repaired.substring(Math.max(0, repaired.length - 200)));
        
        try {
          const parsed = JSON.parse(repaired);
          console.log('[API SUCCESS] Repaired JSON parsed successfully!');
          console.log('═══════════════════════════════════════\n');
          return parsed;
        } catch (repairErr) {
          console.error('[API ERROR] Repair failed:', repairErr);
          throw new Error(`Invalid JSON from API (repair failed): ${parseErr.message}. Raw: ${raw.substring(0, 200)}`);
        }
      }
    }

    function showSceneLog(changes) {
      // Grid IS the terminal - log to console only
      console.log('[SCENE CHANGES]', changes.join(' | '));
    }
    
    function applyScene(channel, scene) {
      const oldScene = channel.lastScene;
      channel.lastScene = scene;
      channel.ledger.push(scene);
      
      // Track what changed
      const changes = [];
      const oldPositions = new Map();
      
      if (oldScene?.gridMapping) {
        oldScene.gridMapping.forEach(item => {
          oldPositions.set(item.id, {x: item.x, y: item.y, type: item.type});
        });
      }
      
      // Animate old cells with different effects based on what happens to them
      const oldCells = channel.dom.gridEl?.querySelectorAll('.grid-cell.occupied');
      oldCells?.forEach((cell, idx) => {
        const y = parseInt(cell.dataset.y);
        const x = parseInt(cell.dataset.x);
        const oldCell = channel.grid[y]?.[x];
        
        if (!oldCell) return;
        
        // Check if this element appears in new scene
        const newPlacement = (scene.gridMapping || []).find(p => p.id === oldCell.id);
        
        setTimeout(() => {
          if (!newPlacement) {
            // Element DISAPPEARS - dramatic fade with red tint
            cell.style.transition = 'opacity 0.5s, transform 0.5s, filter 0.5s, box-shadow 0.5s';
            cell.style.opacity = '0';
            cell.style.transform = 'scale(0) rotate(180deg)';
            cell.style.filter = 'blur(4px) hue-rotate(-30deg)';
            cell.style.boxShadow = '0 0 20px rgba(248, 113, 113, 0.8)';
            changes.push(`❌ ${oldCell.label || oldCell.type} disappeared`);
            
            // Show terminal-style status on cell
            const status = document.createElement('div');
            status.style.cssText = `
              position: absolute;
              top: 50%;
              left: 50%;
              transform: translate(-50%, -50%);
              font-size: 7px;
              font-family: 'Courier New', monospace;
              color: #f87171;
              letter-spacing: 0.1em;
              pointer-events: none;
              text-shadow: 0 0 8px #f87171;
            `;
            status.textContent = 'REMOVED';
            cell.style.position = 'relative';
            cell.appendChild(status);
            setTimeout(() => status.remove(), 1500);
          } else if (newPlacement.x !== x || newPlacement.y !== y) {
            // Element MOVES - slide out with blue tint
            const dx = (newPlacement.x - x) * 100;
            const dy = (newPlacement.y - y) * 100;
            cell.style.transition = 'transform 0.6s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.3s, box-shadow 0.3s';
            cell.style.transform = `translate(${dx}px, ${dy}px) scale(0.8)`;
            cell.style.opacity = '0.3';
            cell.style.boxShadow = '0 0 20px rgba(96, 165, 250, 0.6)';
            changes.push(`↔ ${oldCell.label || oldCell.type} moved (${x},${y})→(${newPlacement.x},${newPlacement.y})`);
          } else {
            // Element STAYS - gentle fade
            cell.style.transition = 'opacity 0.3s';
            cell.style.opacity = '0.5';
          }
        }, idx * 15);
      });
      
      // Display changes in terminal log overlay
      if (changes.length) {
        console.log('[SCENE UPDATE]', changes.join(' | '));
        showSceneLog(changes);
      }
      
      setTimeout(() => {
        channel.grid = createEmptyGrid();
        channel.cells = {};
        
        const placements = (scene.gridMapping || []).slice(0, 18);
        const newElements = [];
        
        placements.forEach(item => {
          if (item.x < 0 || item.x > 8 || item.y < 0 || item.y > 8) return;
          const entity = (scene.entities || []).find(e => e.id === item.id) || null;
          const label = sanitizeLabel(entity?.name || item.label || '');
          channel.grid[item.y][item.x] = {
            id: item.id,
            type: item.type,
            symbol: blockPalette.find(p => p.type === item.type)?.symbol || item.type[0],
            label,
            entity
          };
          logCellEvent(channel, item.x, item.y, `Agent placed ${item.type}${label ? `: ${label}` : ''}`);
          
          // Track new elements
          if (!oldPositions.has(item.id)) {
            newElements.push(`✨ ${label || item.type} appeared @ (${item.x},${item.y})`);
          }
        });
        
        // Show new elements in log
        if (newElements.length) {
          showSceneLog(newElements);
        }
        
        channel.observer = {
          plot: scene.plot || channel.observer.plot,
          direction: scene.direction || 'up',
          tension: scene.tension ?? channel.observer.tension,
          narrative: scene.sceneSummary || channel.observer.narrative
        };
        channel.scorecard = scene.scorecard || createDefaultScorecard();

        // Auto-name blank canvas channels based on scene
        if (channel.scenario === 'blank' && scene.sceneTitle) {
          const generatedName = sanitizeHandle(scene.sceneTitle, channel.symbolicId);
          if (generatedName && generatedName !== 'BLANK CANV') {
            channel.name = generatedName;
          }
        }
        
        addMessageToChannel(channel, 'assistant', `${scene.sceneTitle}\n${scene.sceneSummary}`);
        renderChannel(channel);
      }, 400); // Delay to show clearing animation

      // Trigger animations for placed elements
      setTimeout(() => {
        const gridCells = channel.dom.gridEl?.querySelectorAll('.grid-cell.occupied');
        gridCells?.forEach((cell, idx) => {
          const y = parseInt(cell.dataset.y);
          const x = parseInt(cell.dataset.x);
          const cellData = channel.grid[y][x];
          if (!cellData) return;
          
          // Check if this is a NEW element (wasn't in old scene)
          const isNew = oldPositions.size > 0 && !oldPositions.has(cellData.id);
          const oldPos = oldPositions.get(cellData.id);
          const moved = oldPos && (oldPos.x !== x || oldPos.y !== y);
          
          setTimeout(() => {
            if (isNew) {
              // NEW element - dramatic entrance
              cell.style.animation = 'none';
              cell.style.transform = 'scale(0) rotate(-180deg)';
              cell.style.opacity = '0';
              
              // Show terminal status - color by element type
              const status = document.createElement('div');
              const typeColor = cellData.type === 'Entity' ? '#86efac' : 
                               cellData.type === 'Object' ? '#60a5fa' : 
                               cellData.type === 'Environment' ? '#c084fc' : '#fbbf24';
              status.style.cssText = `
                position: absolute;
                top: -8px;
                left: 50%;
                transform: translateX(-50%);
                font-size: 6px;
                font-family: 'Courier New', monospace;
                color: ${typeColor};
                letter-spacing: 0.15em;
                pointer-events: none;
                white-space: nowrap;
                text-shadow: 0 0 8px ${typeColor};
                animation: sparkle 3s ease-in-out infinite;
              `;
              status.textContent = '✨ NEW';
              cell.style.position = 'relative';
              cell.appendChild(status);
              
              setTimeout(() => {
                cell.style.transition = 'all 0.6s cubic-bezier(0.4, 0, 0.2, 1)';
                cell.style.transform = 'scale(1) rotate(0)';
                cell.style.opacity = '1';
                // Keep NEW label longer with sparkle
                setTimeout(() => status.remove(), 4000);
              }, 50);
            } else if (moved) {
              // MOVED element - pulse
              cell.style.animation = 'pulse 0.6s ease-in-out';
              
              // Show terminal status - color by element type
              const status = document.createElement('div');
              const typeColor = cellData.type === 'Entity' ? '#86efac' : 
                               cellData.type === 'Object' ? '#60a5fa' : 
                               cellData.type === 'Environment' ? '#c084fc' : '#fbbf24';
              status.style.cssText = `
                position: absolute;
                top: -8px;
                left: 50%;
                transform: translateX(-50%);
                font-size: 6px;
                font-family: 'Courier New', monospace;
                color: ${typeColor};
                letter-spacing: 0.15em;
                pointer-events: none;
                white-space: nowrap;
                text-shadow: 0 0 8px ${typeColor};
              `;
              status.textContent = '↔ MOVED';
              cell.style.position = 'relative';
              cell.appendChild(status);
              setTimeout(() => status.remove(), 2000);
            }
            
            // Ripple effect
            cell.classList.add('resonance-field');
            setTimeout(() => cell.classList.remove('resonance-field'), 1200);
          }, idx * 150); // Slower stagger for smoother appearance
        });
      }, 450); // Longer delay to show transitions
    }

    // Dice roll using entropy from random walks
    function rollDice(channel, sides = 6, count = 1) {
      if (!channel.entropy || channel.entropy.length === 0) {
        // Fallback to Math.random if no entropy
        return Array.from({ length: count }, () => Math.floor(Math.random() * sides) + 1);
      }
      
      const rolls = [];
      for (let i = 0; i < count; i++) {
        // Consume entropy from the random walk
        const entropyIdx = channel.entropy.shift();
        if (entropyIdx === undefined) {
          // Entropy depleted, use standard random
          rolls.push(Math.floor(Math.random() * sides) + 1);
        } else {
          // Use entropy value, map to dice range
          const roll = (entropyIdx % sides) + 1;
          rolls.push(roll);
        }
      }
      
      // Log the roll for narrative purposes
      const rollText = rolls.length === 1 ? `Rolled ${rolls[0]}` : `Rolled ${rolls.join(', ')}`;
      console.log(`[DICE] ${rollText} using entropy (${channel.entropy.length} remaining)`);
      
      return rolls;
    }
    
    function logCellEvent(channel, x, y, text) {
      const key = `${x},${y}`;
      if (!channel.cells[key]) channel.cells[key] = [];
      channel.cells[key].push({ text, timestamp: new Date().toISOString() });
    }

    function gatherNearbyCells(channel, x, y, radius = 2.5) {
      const results = [];
      channel.grid.forEach((row, yy) => {
        row.forEach((cell, xx) => {
          if (!cell || (xx === x && yy === y)) return;
          const dx = xx - x;
          const dy = yy - y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          if (distance <= radius) {
            results.push({ cell, x: xx, y: yy, distance });
          }
        });
      });
      return results.sort((a, b) => a.distance - b.distance);
    }

    function describeCellEnvironment(channel, x, y) {
      const cell = channel.grid[y]?.[x] || null;
      const neighbours = gatherNearbyCells(channel, x, y);
      const observer = channel.observer || {};
      const scorecard = channel.scorecard || {};
      const pieces = [];
      if (neighbours.length) {
        const sample = neighbours.slice(0, 3).map(item => {
          const label = item.cell.label || item.cell.type;
          return `${label} @ (${item.x},${item.y})`;
        }).join('; ');
        pieces.push(`Nearby signals: ${sample}.`);
      } else {
        pieces.push('Nearby signals: none detected within two cells.');
      }
      if (observer.tension != null) {
        pieces.push(`Scene tension ${Math.round((observer.tension || 0) * 100)}%.`);
      }
      if (observer.direction) {
        pieces.push(`Narrative drift ${observer.direction.toUpperCase()}.`);
      }
      if (scorecard.progress != null || scorecard.caution != null) {
        const progress = scorecard.progress != null ? (scorecard.progress * 100).toFixed(0) : '0';
        const caution = scorecard.caution != null ? (scorecard.caution * 100).toFixed(0) : '0';
        pieces.push(`Progress ${progress}%, caution ${caution}%.`);
      }
      if (!cell) {
        pieces.push('Cell is currently empty, awaiting placement.');
      }
      return pieces.join(' ');
    }

    function computeRelationshipScores(channel, x, y) {
      const source = channel.grid[y]?.[x];
      if (!source) return [];
      const relations = source.entity?.relations || [];
      const results = [];
      channel.grid.forEach((row, yy) => {
        row.forEach((cell, xx) => {
          if (!cell || (xx === x && yy === y)) return;
          const dx = xx - x;
          const dy = yy - y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          const proximity = 1 / (1 + distance);
          const typeBoost = cell.type === source.type ? 0.15 : 0;
          const relationBoost = relations.some(rel => rel.target === cell.id) ? 0.25 : 0;
          const score = Math.min(0.99, proximity + typeBoost + relationBoost);
          const label = sanitizeLabel(cell.label || `${cell.type} (${cell.symbol || '?'})`);
          results.push({
            label,
            type: cell.type,
            score,
            distance,
            relation: relationBoost > 0
          });
        });
      });
      return results.sort((a, b) => b.score - a.score).slice(0, 5);
    }

    function openCellOverlay(channel, x, y) {
      const cell = channel.grid[y][x];
      const logs = channel.cells[`${x},${y}`] || [];
      const content = document.getElementById('cellOverlayContent');
      content.innerHTML = '';
      const close = document.createElement('button');
      close.className = 'close-overlay';
      close.textContent = '×';
      close.addEventListener('click', () => document.getElementById('cellOverlay').classList.remove('active'));
      content.appendChild(close);

      const header = document.createElement('div');
      header.className = 'overlay-section';
      const label = document.createElement('div');
      label.className = 'overlay-label';
      label.textContent = `${channel.name} · CELL (${x}, ${y})`;
      const value = document.createElement('div');
      value.className = 'overlay-value';
      value.textContent = cell ? `${cell.type} · ${cell.label || '—'}` : 'Empty cell';
      header.appendChild(label);
      header.appendChild(value);
      content.appendChild(header);

      if (cell?.entity) {
        if (cell.entity.description) {
          const section = document.createElement('div');
          section.className = 'overlay-section';
          const l = document.createElement('div');
          l.className = 'overlay-label';
          l.textContent = 'Description';
          const v = document.createElement('div');
          v.className = 'overlay-value';
          v.textContent = cell.entity.description;
          section.appendChild(l);
          section.appendChild(v);
          content.appendChild(section);
        }
        if (cell.entity.relations?.length) {
          const section = document.createElement('div');
          section.className = 'overlay-section';
          const l = document.createElement('div');
          l.className = 'overlay-label';
          l.textContent = 'Relations';
          section.appendChild(l);
          cell.entity.relations.forEach(rel => {
            const v = document.createElement('div');
            v.className = 'overlay-value';
            v.textContent = `${rel.type}: ${rel.target}`;
            section.appendChild(v);
          });
          content.appendChild(section);
        }
      }

      // CULTURAL FRAMEWORK & BDI STATE DISPLAY
      if (channel.culturalAgents) {
        const key = `${x}_${y}`;
        const agent = channel.culturalAgents[key];
        
        if (agent) {
          const section = document.createElement('div');
          section.className = 'overlay-section';
          section.style.backgroundColor = 'rgba(100, 50, 200, 0.1)';
          section.style.border = '1px solid rgba(100, 50, 200, 0.3)';
          
          const l = document.createElement('div');
          l.className = 'overlay-label';
          const fw = channel.culturalParams?.framework || 'epstein';
          const frameworkEmoji = {
            'epstein': '⚡',
            'bdi': '🧠',
            'rebeland': '🏛️',
            'iruba': '⚔️',
            'ccim': '🌍',
            'axelrod': '🎭',
            'schelling': '🏘️'
          };
          l.textContent = `${frameworkEmoji[fw] || '◉'} Cultural State (${fw})`;
          section.appendChild(l);
          
          // Cultural type and symbolic role
          const typeVal = document.createElement('div');
          typeVal.className = 'overlay-value';
          const roleLabel = agent.legosCellRef?.entity?.symbolicRole || 'neutral';
          typeVal.textContent = `Type: ${agent.type} (${roleLabel})`;
          section.appendChild(typeVal);
          
          // Traits
          if (agent.traits) {
            const traitsVal = document.createElement('div');
            traitsVal.className = 'overlay-value';
            traitsVal.textContent = `Hardship: ${(agent.traits.hardship * 100).toFixed(0)}%, Risk Aversion: ${(agent.traits.riskAversion * 100).toFixed(0)}%`;
            section.appendChild(traitsVal);
          }
          
          // Fear/Energy
          const stateVal = document.createElement('div');
          stateVal.className = 'overlay-value';
          stateVal.textContent = `Fear: ${(agent.fear * 100).toFixed(0)}%, Energy: ${(agent.energy * 100).toFixed(0)}%`;
          section.appendChild(stateVal);
          
          // BDI STATE (if active)
          if (agent.bdiAgent && channel.culturalParams?.useBDI) {
            const bdiLabel = document.createElement('div');
            bdiLabel.className = 'overlay-label';
            bdiLabel.textContent = '🧠 BDI Reasoning';
            bdiLabel.style.marginTop = '8px';
            section.appendChild(bdiLabel);
            
            // Beliefs
            const beliefsVal = document.createElement('div');
            beliefsVal.className = 'overlay-value';
            beliefsVal.textContent = `Beliefs: ${agent.bdiAgent.beliefs.nearbyThreats.length} threats, ${agent.bdiAgent.beliefs.nearbyAllies.length} allies, legitimacy ${(agent.bdiAgent.beliefs.perceivedLegitimacy * 100).toFixed(0)}%`;
            section.appendChild(beliefsVal);
            
            // Desires
            if (agent.bdiAgent.desires.size > 0) {
              const desiresVal = document.createElement('div');
              desiresVal.className = 'overlay-value';
              desiresVal.textContent = `Desires: ${Array.from(agent.bdiAgent.desires).join(', ')}`;
              section.appendChild(desiresVal);
            }
            
            // Current Intention
            if (agent.bdiAgent.currentIntention) {
              const intentionVal = document.createElement('div');
              intentionVal.className = 'overlay-value';
              intentionVal.style.fontWeight = 'bold';
              intentionVal.textContent = `→ Intention: ${agent.bdiAgent.currentIntention.type} (priority ${agent.bdiAgent.currentIntention.priority})`;
              section.appendChild(intentionVal);
            }
          }
          
          content.appendChild(section);
        }
      }

      if (logs.length) {
        const section = document.createElement('div');
        section.className = 'overlay-section';
        const l = document.createElement('div');
        l.className = 'overlay-label';
        l.textContent = `Event History (last 10 of ${logs.length})`;
        section.appendChild(l);
        // Show only last 10 events
        logs.slice(-10).reverse().forEach(log => {
          const v = document.createElement('div');
          v.className = 'overlay-value';
          v.textContent = `${new Date(log.timestamp).toLocaleTimeString()} · ${log.text}`;
          section.appendChild(v);
        });
        content.appendChild(section);
      }

      if (channel.ledger.length) {
        const section = document.createElement('div');
        section.className = 'overlay-section';
        const label = document.createElement('div');
        label.className = 'overlay-label';
        label.textContent = 'Recent Scenes';
        section.appendChild(label);
        channel.ledger.slice(-3).reverse().forEach(scene => {
          const summary = (scene.sceneSummary || '').trim();
          const compact = summary.length > 160 ? `${summary.slice(0, 160)}…` : summary;
          const value = document.createElement('div');
          value.className = 'overlay-value';
          value.textContent = `${scene.sceneTitle || 'Scene'} — ${compact}`;
          section.appendChild(value);
        });
        content.appendChild(section);
      }

      const awareness = describeCellEnvironment(channel, x, y);
      if (awareness) {
        const section = document.createElement('div');
        section.className = 'overlay-section';
        const label = document.createElement('div');
        label.className = 'overlay-label';
        label.textContent = 'Local Awareness';
        const value = document.createElement('div');
        value.className = 'overlay-value';
        value.textContent = awareness;
        section.appendChild(label);
        section.appendChild(value);
        content.appendChild(section);
      }

      const relationshipScores = computeRelationshipScores(channel, x, y);
      if (relationshipScores.length) {
        const section = document.createElement('div');
        section.className = 'overlay-section';
        const label = document.createElement('div');
        label.className = 'overlay-label';
        label.textContent = 'Relational Probabilities';
        section.appendChild(label);
        relationshipScores.forEach(item => {
          const value = document.createElement('div');
          value.className = 'overlay-value';
          const percent = Math.round(item.score * 100);
          value.textContent = `${item.label} — ${percent}% resonance` + (item.relation ? ' (linked)' : '');
          section.appendChild(value);
        });
        content.appendChild(section);
      }

      // BUILD ACTION BUTTONS FIRST (will be placed at top)
      const actionRow = [];
      
      // Send to Chat button
      if (cell) {
        const sendToChatBtn = document.createElement('button');
        sendToChatBtn.className = 'primary-btn';
        sendToChatBtn.style.cssText = 'font-size: 10px; padding: 10px 16px; font-weight: 700;';
        sendToChatBtn.textContent = 'SEND TO CHAT';
        sendToChatBtn.addEventListener('click', () => {
          const cellContext = `Regarding ${cell.label || cell.type} at (${x},${y}): `;
          if (channel.dom?.input) {
            channel.dom.input.value = cellContext;
            channel.dom.input.focus();
          }
          document.getElementById('cellOverlay').classList.remove('active');
        });
        actionRow.push(sendToChatBtn);
      }
      
      const spawnBtn = document.createElement('button');
      spawnBtn.className = 'primary-btn';
      spawnBtn.style.cssText = 'font-size: 10px; padding: 10px 16px; font-weight: 700;';
      spawnBtn.textContent = 'SPAWN POV CHANNEL';
      spawnBtn.addEventListener('click', () => {
        document.getElementById('cellOverlay').classList.remove('active');
        spawnCellPerspectiveChannel(channel, x, y, cell);
      });
      actionRow.push(spawnBtn);

      if (cell) {
        const canRunPerspective = Boolean(appState.apiKey);
        const perspectiveBtn = document.createElement('button');
        perspectiveBtn.className = 'primary-btn';
        perspectiveBtn.style.cssText = 'font-size: 10px; padding: 12px 18px; font-weight: 700; background: var(--accent); color: var(--bg);';
        perspectiveBtn.textContent = 'RUN ELEMENT PERSPECTIVE';
        perspectiveBtn.disabled = !canRunPerspective;
        if (canRunPerspective) {
          perspectiveBtn.addEventListener('click', () => {
            // Animate grid before closing
            const gridCells = channel.dom.gridEl?.querySelectorAll('.grid-cell');
            gridCells?.forEach((gridCell, idx) => {
              gridCell.style.animation = 'pulse 0.8s ease-in-out';
              gridCell.style.animationDelay = `${(idx * 0.02) % 0.3}s`;
            });
            setTimeout(() => {
              gridCells?.forEach(gridCell => { gridCell.style.animation = ''; });
            }, 1000);
            
            playComposingTick();
            document.getElementById('cellOverlay').classList.remove('active');
            showEntityPerspective(channel, x, y, cell);
          });
        } else {
          perspectiveBtn.title = 'Store an API key to analyze this element POV.';
        }
        actionRow.push(perspectiveBtn);
        
        // Add Tetrad Intervention button (make it HUGE and prominent)
        const tetradBtn = document.createElement('button');
        tetradBtn.className = 'primary-btn tetrad-intervention-btn';
        tetradBtn.style.cssText = 'font-size: 10px; padding: 12px 18px; font-weight: 700; background: linear-gradient(135deg, #ff3d4e, #ff6d7a); color: var(--bg);';
        tetradBtn.innerHTML = '⋔ TETRAD INTERVENTION';
        tetradBtn.disabled = !canRunPerspective;
        
        // Glowing effect when API ready
        if (canRunPerspective) {
          tetradBtn.classList.add('glow-active');
          tetradBtn.addEventListener('click', async () => {
            tetradBtn.disabled = true;
            tetradBtn.textContent = '⋔ GENERATING...';
            tetradBtn.classList.add('glow-processing');
            
            // Animate the grid cells during generation
            const gridCells = channel.dom.gridEl?.querySelectorAll('.grid-cell');
            gridCells?.forEach((gridCell, idx) => {
              gridCell.style.animation = 'pulse 1.5s ease-in-out infinite';
              gridCell.style.animationDelay = `${(idx * 0.03) % 0.5}s`;
            });
            
            // Play generation sound
            playComposingTick();
            
            try {
              const tetrad = await callOpenAI('TetradGenerator', {
                scenario: scenarios[channel.scenario],
                scene: channel.lastScene,
                history: channel.messages.slice(-2).map(m => ({ role: m.role, text: m.text })),
                perspective: cell.label,
                elementContext: {
                  type: cell.type,
                  position: {x, y},
                  environment: describeCellEnvironment(channel, x, y)
                }
              });
              
              // Stop animations
              gridCells?.forEach(gridCell => {
                gridCell.style.animation = '';
              });
              
              channel.tetrad = tetrad;
              channel.tetradPerspective = cell.label;
              persistState();
              renderTetradPanel(channel);
              
              // Success feedback
              tetradBtn.textContent = '✓ TETRAD GENERATED';
              tetradBtn.classList.remove('glow-processing');
              tetradBtn.classList.add('glow-success');
              playRevealChime();
              
              setTimeout(() => {
                document.getElementById('cellOverlay').classList.remove('active');
              }, 1000);
            } catch (err) {
              // Stop animations on error
              gridCells?.forEach(gridCell => {
                gridCell.style.animation = '';
              });
              
              tetradBtn.textContent = '✗ GENERATION FAILED';
              tetradBtn.classList.remove('glow-processing');
              tetradBtn.disabled = false;
            }
          });
        } else {
          tetradBtn.title = 'Store an API key to generate tetrad for this element.';
        }
        
        actionRow.push(tetradBtn);
      }

      // INSERT BUTTONS AT TOP (after close button)
      if (actionRow.length) {
        const actions = document.createElement('div');
        actions.className = 'overlay-action-row';
        actions.style.cssText = 'order: -1; position: sticky; top: 0; background: var(--panel); z-index: 10; padding-bottom: 12px; border-bottom: 2px solid var(--accent);';
        actionRow.forEach(btn => actions.appendChild(btn));
        content.appendChild(actions);
      }

      document.getElementById('cellOverlay').classList.add('active');
    }

    async function showEntityPerspective(channel, x, y, cell) {
      const panel = document.getElementById('perspectiveOverlayContent');
      panel.innerHTML = '';
      const close = document.createElement('button');
      close.className = 'close-overlay';
      close.textContent = '×';
      close.addEventListener('click', () => document.getElementById('perspectiveOverlay').classList.remove('active'));
      panel.appendChild(close);

      // Show loading screen
      const loadingScreen = document.createElement('div');
      loadingScreen.style.cssText = `
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 40px 20px;
        gap: 16px;
      `;
      
      const loadingText = document.createElement('div');
      loadingText.style.cssText = `
        font-size: 12px;
        font-weight: 700;
        letter-spacing: 0.15em;
        color: var(--accent);
        text-transform: uppercase;
        text-align: center;
      `;
      loadingText.textContent = `Analyzing ${cell.label || cell.type}'s Perspective...`;
      
      const loadingSubtext = document.createElement('div');
      loadingSubtext.style.cssText = `
        font-size: 9px;
        color: var(--text-muted);
        text-align: center;
        max-width: 300px;
      `;
      loadingSubtext.textContent = 'Consulting current scene and relationships...';
      
      loadingScreen.appendChild(loadingText);
      loadingScreen.appendChild(loadingSubtext);
      panel.appendChild(loadingScreen);
      
      // Show message history dots for this cell
      const cellLogs = channel.cells[`${x},${y}`] || [];
      if (cellLogs.length) {
        const historySection = document.createElement('div');
        historySection.className = 'overlay-section';
        historySection.style.cssText = 'display: flex; gap: 6px; align-items: center; padding: 8px 0;';
        
        const historyLabel = document.createElement('div');
        historyLabel.className = 'overlay-label';
        historyLabel.textContent = 'Modified by:';
        historyLabel.style.marginBottom = '0';
        historySection.appendChild(historyLabel);
        
        const dotRow = document.createElement('div');
        dotRow.style.cssText = 'display: flex; gap: 4px; flex-wrap: wrap;';
        
        cellLogs.slice(-5).forEach((log, idx) => {
          const dot = document.createElement('span');
          dot.style.cssText = `
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: ${channel.channelColor};
            border: 2px solid ${idx === cellLogs.length - 1 ? 'var(--accent)' : 'var(--border)'};
            display: inline-block;
            flex-shrink: 0;
            box-shadow: 0 0 8px ${channel.channelColor};
          `;
          dot.title = `${new Date(log.timestamp).toLocaleTimeString()}: ${log.text}`;
          dotRow.appendChild(dot);
        });
        
        historySection.appendChild(dotRow);
        panel.appendChild(historySection);
      }
      
      document.getElementById('perspectiveOverlay').classList.add('active');
      
      // Animate grid cells during perspective analysis
      const gridCells = channel.dom.gridEl?.querySelectorAll('.grid-cell');
      gridCells?.forEach((gridCell, idx) => {
        gridCell.style.animation = 'pulse 1.8s ease-in-out infinite';
        gridCell.style.animationDelay = `${(idx * 0.04) % 0.6}s`;
      });
      
      // Play analysis sound
      playComposingTick();

      const entityPayload = cell?.entity ? { ...cell.entity } : {
        name: cell?.label || `${cell?.type || 'Cell'} (${x},${y})`,
        type: cell?.type || 'Unknown',
        relations: []
      };
      if (!entityPayload.relations) {
        entityPayload.relations = [];
      }
      const environmentSummary = describeCellEnvironment(channel, x, y);
      const relationshipScores = computeRelationshipScores(channel, x, y);

      try {
        console.log('[PERSPECTIVE API] Starting perspective analysis for:', cell.label || cell.type);
        console.log('[PERSPECTIVE API] Scene context:', channel.lastScene?.sceneTitle);
        
        // Always generate single standard perspective
        // Tetrad mode handled separately through tetrad chips
        let analyses = [];
        let analysis = null; // Define at function scope
        
        if (false) { // Disabled tetrad mode in perspective
          // Generate 4 defractive perspectives through tetrad lenses
          const tetradLenses = [
            {key: 'enhance', label: 'ENHANCE', prompt: 'amplifying and intensifying their current situation', icon: '▲'},
            {key: 'reverse', label: 'REVERSE', prompt: 'reversing or inverting their current trajectory', icon: '⇄'},
            {key: 'retrieve', label: 'RETRIEVE', prompt: 'retrieving past elements and memories', icon: '↺'},
            {key: 'obsolesce', label: 'OBSOLESCE', prompt: 'elements becoming obsolete or fading away', icon: '▼'}
          ];
          
          // Generate all 4 perspectives in parallel
          const promises = tetradLenses.map(lens => 
            fetch('https://api.openai.com/v1/chat/completions', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${appState.apiKey}`
              },
              body: JSON.stringify({
                model: 'gpt-4o-mini',
                temperature: 0.7,
                messages: [
                  {
                    role: 'system',
                    content: `You analyze an entity's perspective through the tetrad lens of "${lens.label}" (${lens.prompt}). Return JSON with perspective, emotionalState, plotImpact, nextMove, all filtered through this ${lens.label} lens. Keep each field under 60 words.`
                  },
                  {
                    role: 'user',
                    content: JSON.stringify({
                      scenario: scenarios[channel.scenario],
                      currentScene: channel.lastScene,
                      entity: entityPayload,
                      cellType: cell?.type || 'Unknown',
                      cellPosition: { x, y },
                      plot: channel.observer.plot,
                      environment: environmentSummary,
                      tetradLens: lens.label
                    })
                  }
                ],
                max_tokens: 400,
                response_format: { type: 'json_object' }
              })
            }).then(r => r.ok ? r.json() : Promise.reject(`HTTP ${r.status}`))
              .then(data => ({
                ...JSON.parse(data.choices?.[0]?.message?.content || '{}'),
                lens: lens
              }))
          );
          
          analyses = await Promise.all(promises);
        } else {
          // Standard single perspective
          console.log('[PERSPECTIVE API] Generating standard perspective');
          console.log('[PERSPECTIVE API] Entity:', entityPayload.name);
          console.log('[PERSPECTIVE API] Environment:', environmentSummary);
          
          const response = await fetch('https://api.openai.com/v1/chat/completions', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${appState.apiKey}`
            },
            body: JSON.stringify({
              model: 'gpt-4o-mini',
              temperature: 0.7,
              messages: [
                {
                  role: 'system',
                  content: 'You analyze an entity perspective in a LEGOS grid. Return JSON with perspective, emotionalState, plotImpact, nextMove.'
                },
                {
                  role: 'user',
                  content: JSON.stringify({
                    scenario: scenarios[channel.scenario],
                    currentScene: channel.lastScene,
                    entity: entityPayload,
                    cellType: cell?.type || 'Unknown',
                    cellPosition: { x, y },
                    plot: channel.observer.plot,
                    environment: environmentSummary
                  })
                }
              ],
              max_tokens: 500,
              response_format: { type: 'json_object' }
            })
          });
          if (!response.ok) {
            console.error('[PERSPECTIVE API] HTTP error:', response.status);
            throw new Error(`HTTP ${response.status}`);
          }
          const data = await response.json();
          console.log('[PERSPECTIVE API] Response received');
          console.log('[PERSPECTIVE API] Usage:', data.usage);
          
          const rawContent = data.choices?.[0]?.message?.content || '{}';
          console.log('[PERSPECTIVE API] Raw content:', rawContent.substring(0, 200));
          
          analysis = JSON.parse(rawContent);
          console.log('[PERSPECTIVE API] Parsed analysis:', analysis);
          analyses = [analysis];
        }

        console.log('[PERSPECTIVE] Total analyses:', analyses.length);
        console.log('[PERSPECTIVE] First analysis:', analyses[0]);
        
        // Stop grid animations
        gridCells?.forEach(gridCell => {
          gridCell.style.animation = '';
        });
        
        // Play success chime
        playRevealChime();

        panel.innerHTML = '';
        const closeBtn = document.createElement('button');
        closeBtn.className = 'close-overlay';
        closeBtn.textContent = '×';
        closeBtn.addEventListener('click', () => document.getElementById('perspectiveOverlay').classList.remove('active'));
        panel.appendChild(closeBtn);

        // Always use standard mode display (never tetrad cards)
        if (false && analyses.length > 1) {
          // Tetrad mode: Show 4 defractive perspectives as cards
          const header = document.createElement('div');
          header.style.cssText = 'font-size: 12px; font-weight: 700; letter-spacing: 0.15em; color: var(--accent); margin-bottom: 16px; text-transform: uppercase; text-align: center;';
          header.textContent = `${cell.label || cell.type} · DEFRACTIVE PERSPECTIVES`;
          panel.appendChild(header);
          
          const subheader = document.createElement('div');
          subheader.style.cssText = 'font-size: 9px; color: var(--text-muted); margin-bottom: 16px; text-align: center;';
          subheader.textContent = 'Four perspectives through tetrad lenses — Click any to add to chat';
          panel.appendChild(subheader);
          
          const cardsContainer = document.createElement('div');
          cardsContainer.style.cssText = 'display: grid; grid-template-columns: repeat(2, 1fr); gap: 12px;';
          
          analyses.forEach(analysis => {
            const card = document.createElement('div');
            card.style.cssText = `
              background: var(--panel-dark);
              border: 2px solid var(--border);
              border-radius: 8px;
              padding: 12px;
              cursor: pointer;
              transition: all 0.2s;
            `;
            
            const cardHeader = document.createElement('div');
            cardHeader.style.cssText = 'display: flex; align-items: center; gap: 6px; margin-bottom: 8px;';
            cardHeader.innerHTML = `
              <span style="font-size: 18px;">${analysis.lens.icon}</span>
              <span style="font-size: 9px; font-weight: 700; letter-spacing: 0.1em; color: var(--accent);">${analysis.lens.label}</span>
            `;
            card.appendChild(cardHeader);
            
            ['perspective', 'emotionalState', 'nextMove'].forEach(key => {
              if (!analysis[key]) return;
              const field = document.createElement('div');
              field.style.cssText = 'margin-bottom: 8px;';
              field.title = analysis[key]; // Hover tooltip
              const label = key === 'nextMove' ? 'NEXT ACTION' : key.replace(/([A-Z])/g, ' $1').trim();
              field.innerHTML = `
                <div style="font-size: 7px; text-transform: uppercase; color: var(--text-muted); margin-bottom: 2px; letter-spacing: 0.1em;">${label}</div>
                <div style="font-size: 9px; line-height: 1.4; color: var(--text);">${analysis[key]}</div>
              `;
              card.appendChild(field);
            });
            
            // Add copy button to card
            const copyBtn = document.createElement('button');
            copyBtn.style.cssText = `
              margin-top: 8px;
              padding: 4px 8px;
              background: var(--accent);
              color: var(--bg);
              border: none;
              border-radius: 4px;
              cursor: pointer;
              font-size: 8px;
              font-weight: 700;
              text-transform: uppercase;
              width: 100%;
            `;
            copyBtn.textContent = '📋 COPY TO CHAT';
            copyBtn.addEventListener('click', (e) => {
              e.stopPropagation();
              const textarea = channel.dom?.input;
              if (textarea) {
                const text = `${analysis.lens.icon} ${analysis.lens.label}:\n${analysis.perspective}\n\nNext Move: ${analysis.nextMove}`;
                textarea.value = text;
                textarea.focus();
                textarea.style.height = 'auto';
                textarea.style.height = textarea.scrollHeight + 'px';
                copyBtn.textContent = '✓ COPIED';
                setTimeout(() => copyBtn.textContent = '📋 COPY TO CHAT', 1500);
              }
            });
            card.appendChild(copyBtn);
            
            card.addEventListener('mouseenter', () => {
              card.style.borderColor = 'var(--accent)';
              card.style.transform = 'scale(1.02)';
            });
            
            card.addEventListener('mouseleave', () => {
              card.style.borderColor = 'var(--border)';
              card.style.transform = '';
            });
            
            cardsContainer.appendChild(card);
          });
          
          panel.appendChild(cardsContainer);
        } else {
          // Standard mode: Show single perspective
          const analysis = analyses[0];
          const heading = document.createElement('div');
          heading.className = 'overlay-section clickable';
          heading.title = 'Click to send to chat';
          const heLabel = document.createElement('div');
          heLabel.className = 'overlay-label';
          heLabel.textContent = `${cell.label || cell.type} · Perspective`;
          const heVal = document.createElement('div');
          heVal.className = 'overlay-value';
          heVal.textContent = analysis.perspective || '—';
          heading.appendChild(heLabel);
          heading.appendChild(heVal);
          
          // Make section selectable - button appears on selection
          heading.style.position = 'relative';
          heading.style.cursor = 'pointer';
          heading.style.transition = 'all 0.2s';
          
          // Add red ball send button (hidden by default)
          const sendBtn = document.createElement('button');
          sendBtn.style.cssText = `
            position: absolute;
            top: 50%;
            right: 12px;
            transform: translateY(-50%) scale(0);
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background: linear-gradient(135deg, #f87171, #dc2626);
            border: 2px solid #991b1b;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            box-shadow: 0 4px 12px rgba(248, 113, 113, 0.6);
            z-index: 10;
            opacity: 0;
          `;
          sendBtn.textContent = '→';
          sendBtn.title = 'Send to input';
          
          // Click section to select and show button
          heading.addEventListener('click', (e) => {
            if (e.target === sendBtn) return; // Don't trigger if clicking button
            
            // Deselect all other sections
            panel.querySelectorAll('.overlay-section').forEach(s => {
              s.style.background = '';
              const btn = s.querySelector('button');
              if (btn) {
                btn.style.transform = 'translateY(-50%) scale(0)';
                btn.style.opacity = '0';
              }
            });
            
            // Select this section
            heading.style.background = 'var(--accent-soft)';
            sendBtn.style.transform = 'translateY(-50%) scale(1)';
            sendBtn.style.opacity = '1';
          });
          
          sendBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            const textarea = channel.dom?.input;
            if (textarea) {
              textarea.value = heVal.textContent;
              textarea.focus();
              textarea.style.height = 'auto';
              textarea.style.height = textarea.scrollHeight + 'px';
              
              // Flash and close
              heading.style.background = 'var(--accent)';
              sendBtn.style.transform = 'translateY(-50%) scale(1.2)';
              
              setTimeout(() => {
                // Close the modal
                document.getElementById('perspectiveOverlay').classList.remove('active');
              }, 300);
            }
          });
          heading.appendChild(sendBtn);
          panel.appendChild(heading);

          ['emotionalState', 'plotImpact', 'nextMove'].forEach(key => {
            if (!analysis[key]) return;
            const section = document.createElement('div');
            section.className = 'overlay-section';
            section.style.position = 'relative';
            section.style.cursor = 'pointer';
            section.style.transition = 'all 0.2s';
            
            const l2 = document.createElement('div');
            l2.className = 'overlay-label';
            const labelText = key === 'nextMove' ? 'NEXT ACTION' : key.replace(/([A-Z])/g, ' $1').toUpperCase();
            l2.textContent = labelText;
            const v2 = document.createElement('div');
            v2.className = 'overlay-value';
            v2.textContent = analysis[key];
            section.appendChild(l2);
            section.appendChild(v2);
            
            // Add red ball send button (hidden by default)
            const fieldSendBtn = document.createElement('button');
            fieldSendBtn.style.cssText = `
              position: absolute;
              top: 50%;
              right: 12px;
              transform: translateY(-50%) scale(0);
              width: 40px;
              height: 40px;
              border-radius: 50%;
              background: linear-gradient(135deg, #f87171, #dc2626);
              border: 2px solid #991b1b;
              cursor: pointer;
              display: flex;
              align-items: center;
              justify-content: center;
              font-size: 18px;
              transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
              box-shadow: 0 4px 12px rgba(248, 113, 113, 0.6);
              z-index: 10;
              opacity: 0;
            `;
            fieldSendBtn.textContent = '→';
            fieldSendBtn.title = 'Send to input';
            
            // Click section to select and show button
            section.addEventListener('click', (e) => {
              if (e.target === fieldSendBtn) return;
              
              // Deselect all other sections
              panel.querySelectorAll('.overlay-section').forEach(s => {
                s.style.background = '';
                const btn = s.querySelector('button');
                if (btn) {
                  btn.style.transform = 'translateY(-50%) scale(0)';
                  btn.style.opacity = '0';
                }
              });
              
              // Select this section
              section.style.background = 'var(--accent-soft)';
              fieldSendBtn.style.transform = 'translateY(-50%) scale(1)';
              fieldSendBtn.style.opacity = '1';
            });
            
            fieldSendBtn.addEventListener('click', (e) => {
              e.stopPropagation();
              const textarea = channel.dom?.input;
              if (textarea) {
                textarea.value = v2.textContent;
                textarea.focus();
                textarea.style.height = 'auto';
                textarea.style.height = textarea.scrollHeight + 'px';
                
                // Flash and close
                section.style.background = 'var(--accent)';
                fieldSendBtn.style.transform = 'translateY(-50%) scale(1.2)';
                
                setTimeout(() => {
                  // Close the modal
                  document.getElementById('perspectiveOverlay').classList.remove('active');
                }, 300);
              }
            });
            
            section.appendChild(fieldSendBtn);
            panel.appendChild(section);
          });
        }
        
        // Log perspective to ring memory for narrative depth
        const firstAnalysis = analyses[0];
        const perspectiveSummary = `${cell.label || cell.type}: ${firstAnalysis.perspective ? firstAnalysis.perspective.substring(0, 100) : 'analyzed'}`;
        logRingEntry({
          type: 'perspective',
          channelId: channel.id,
          channelName: channel.name,
          symbol: `${cell.symbol || cell.type[0]}@(${x},${y})`,
          headline: `Perspective: ${cell.label || cell.type}`,
          summary: perspectiveSummary,
          metadata: {
            cellPosition: { x, y },
            cellType: cell.type,
            analysis: analysis
          }
        });

        if (environmentSummary) {
          const section = document.createElement('div');
          section.className = 'overlay-section clickable';
          section.title = 'Click to send to chat';
          const lEnv = document.createElement('div');
          lEnv.className = 'overlay-label';
          lEnv.textContent = 'Local Awareness';
          const vEnv = document.createElement('div');
          vEnv.className = 'overlay-value';
          vEnv.textContent = environmentSummary;
          section.appendChild(lEnv);
          section.appendChild(vEnv);
          section.addEventListener('click', () => {
            const text = `${lEnv.textContent}: ${vEnv.textContent}`;
            sendPerspectiveToChat(channel, text);
          });
          panel.appendChild(section);
        }

        if (relationshipScores.length) {
          const section = document.createElement('div');
          section.className = 'overlay-section clickable';
          section.title = 'Click to send to chat';
          const lRel = document.createElement('div');
          lRel.className = 'overlay-label';
          lRel.textContent = 'Relational Probabilities';
          section.appendChild(lRel);
          const relationsText = relationshipScores.map(item => {
            const percent = Math.round(item.score * 100);
            return `${item.label} — ${percent}% resonance` + (item.relation ? ' (linked)' : '');
          }).join('; ');
          relationshipScores.forEach(item => {
            const value = document.createElement('div');
            value.className = 'overlay-value';
            const percent = Math.round(item.score * 100);
            value.textContent = `${item.label} — ${percent}% resonance` + (item.relation ? ' (linked)' : '');
            section.appendChild(value);
          });
          section.addEventListener('click', () => {
            const text = `${lRel.textContent}: ${relationsText}`;
            sendPerspectiveToChat(channel, text);

          });
          panel.appendChild(section);
        }

        // Tetrad button - generate tetrad options from this perspective
        const tetradFromPerspectiveBtn = document.createElement('button');
        tetradFromPerspectiveBtn.className = 'primary-btn';
        tetradFromPerspectiveBtn.style.cssText = 'font-size: 10px; padding: 12px 18px; font-weight: 700; background: linear-gradient(135deg, #ff3d4e, #ff6d7a); color: var(--bg); width: 100%;';
        tetradFromPerspectiveBtn.textContent = '⋔ GENERATE TETRAD FROM PERSPECTIVE';
        tetradFromPerspectiveBtn.addEventListener('click', async () => {
          const originalText = tetradFromPerspectiveBtn.textContent;
          tetradFromPerspectiveBtn.disabled = true;
          tetradFromPerspectiveBtn.textContent = '⋔ GENERATING TETRAD...';
          
          // Animate grid
          const perspGridCells = channel.dom.gridEl?.querySelectorAll('.grid-cell');
          perspGridCells?.forEach((gridCell, idx) => {
            gridCell.style.animation = 'pulse 1.5s ease-in-out infinite';
            gridCell.style.animationDelay = `${(idx * 0.03) % 0.5}s`;
          });
          
          playComposingTick();
          
          try {
            // Generate tetrad based on ACTIONS from the perspective analysis
            const perspectiveTetrad = await callOpenAI('TetradGenerator', {
              scenario: scenarios[channel.scenario],
              scene: channel.lastScene,
              history: channel.messages.slice(-2).map(m => ({ role: m.role, text: m.text })),
              perspective: cell.label,
              perspectiveAnalysis: analysis, // Pass the perspective data
              focusOnActions: true, // Signal to generate tetrad for potential ACTIONS
              nextMove: analysis.nextMove || analysis.plotImpact // What they might do next
            });
            
            // Stop animations
            perspGridCells?.forEach(gridCell => {
              gridCell.style.animation = '';
            });
            
            playRevealChime();
            
            // Display tetrad options inline
            const tetradSection = document.createElement('div');
            tetradSection.style.cssText = `
              margin-top: 16px;
              padding: 16px;
              background: rgba(255, 61, 78, 0.1);
              border: 2px solid #ff3d4e;
              border-radius: 6px;
            `;
            
            const tetradHeader = document.createElement('div');
            tetradHeader.style.cssText = 'font-size: 11px; font-weight: 700; letter-spacing: 0.15em; color: #ff3d4e; margin-bottom: 12px; text-transform: uppercase;';
            tetradHeader.textContent = '⋔ TETRAD OPTIONS FROM PERSPECTIVE';
            tetradSection.appendChild(tetradHeader);
            
            // Render tetrad options
            const tetradMap = [
              { key: 'enhance', icon: '▲', label: 'ENHANCE', color: '#56ff9f' },
              { key: 'reverse', icon: '⇄', label: 'REVERSE', color: '#ff5c7c' },
              { key: 'retrieve', icon: '↺', label: 'RETRIEVE', color: '#60a5fa' },
              { key: 'obsolesce', icon: '▼', label: 'OBSOLESCE', color: '#f59e0b' }
            ];
            
            tetradMap.forEach(mapping => {
              const entry = perspectiveTetrad[mapping.key];
              if (!entry) return;
              
              const optionDiv = document.createElement('div');
              optionDiv.style.cssText = `
                padding: 10px 12px;
                margin-bottom: 8px;
                border-left: 3px solid ${mapping.color};
                background: var(--panel-dark);
                border-radius: 4px;
                transition: all 0.2s;
                display: flex;
                align-items: flex-start;
                gap: 10px;
              `;
              
              const contentDiv = document.createElement('div');
              contentDiv.style.cssText = 'flex: 1; cursor: pointer;';
              
              contentDiv.addEventListener('mouseenter', () => {
                optionDiv.style.background = 'var(--accent-soft)';
                optionDiv.style.transform = 'translateX(4px)';
              });
              
              contentDiv.addEventListener('mouseleave', () => {
                optionDiv.style.background = 'var(--panel-dark)';
                optionDiv.style.transform = 'translateX(0)';
              });
              
              const optionHeader = document.createElement('div');
              optionHeader.style.cssText = `
                font-size: 9px;
                font-weight: 700;
                letter-spacing: 0.12em;
                color: ${mapping.color};
                margin-bottom: 4px;
              `;
              optionHeader.textContent = `${mapping.icon} ${mapping.label}`;
              
              const optionText = document.createElement('div');
              optionText.style.cssText = 'font-size: 10px; line-height: 1.5; color: var(--text);';
              optionText.textContent = entry.text;
              
              contentDiv.appendChild(optionHeader);
              contentDiv.appendChild(optionText);
              
              // Multiple steering buttons (light touch)
              const btnContainer = document.createElement('div');
              btnContainer.style.cssText = `
                display: flex;
                flex-direction: column;
                gap: 4px;
                flex-shrink: 0;
              `;
              
              const channelColor = channel.channelColor || 'var(--accent)';
              
              // Create steering buttons with different actions
              const steeringActions = [
                { icon: '→', label: 'Continue', prefix: '' },
                { icon: '↗', label: 'Explore deeper', prefix: 'Explore deeper: ' },
                { icon: '↔', label: 'Compare', prefix: 'Compare with alternatives: ' },
                { icon: '⋔', label: 'Re-tetrad', prefix: 'Generate tetrad for: ' }
              ];
              
              steeringActions.forEach((action, actionIdx) => {
                const btn = document.createElement('button');
                btn.style.cssText = `
                  width: 28px;
                  height: 28px;
                  border-radius: 50%;
                  background: ${channelColor};
                  border: 2px solid ${channelColor};
                  color: var(--bg);
                  cursor: pointer;
                  display: flex;
                  align-items: center;
                  justify-content: center;
                  font-size: 14px;
                  font-weight: 700;
                  transition: all 0.2s;
                  box-shadow: 0 2px 6px ${channelColor}22;
                  opacity: ${actionIdx === 0 ? '1' : '0.7'};
                `;
                btn.textContent = action.icon;
                btn.title = action.label;
                
                btn.addEventListener('mouseenter', () => {
                  btn.style.transform = 'scale(1.15)';
                  btn.style.opacity = '1';
                  btn.style.boxShadow = `0 4px 12px ${channelColor}66`;
                });
                
                btn.addEventListener('mouseleave', () => {
                  btn.style.transform = 'scale(1)';
                  btn.style.opacity = actionIdx === 0 ? '1' : '0.7';
                  btn.style.boxShadow = `0 2px 6px ${channelColor}22`;
                });
                
                btn.addEventListener('click', (e) => {
                  e.stopPropagation();
                  if (channel.dom?.input) {
                    const followUpText = action.prefix + `${mapping.label}: ${entry.text}`;
                    channel.dom.input.value = followUpText;
                    channel.dom.input.focus();
                  }
                  document.getElementById('perspectiveOverlay').classList.remove('active');
                  
                  // Animate the button
                  btn.style.transform = 'scale(0.8)';
                  btn.style.opacity = '0.5';
                  setTimeout(() => {
                    btn.style.transform = 'scale(1)';
                    btn.style.opacity = actionIdx === 0 ? '1' : '0.7';
                  }, 200);
                });
                
                btnContainer.appendChild(btn);
              });
              
              optionDiv.appendChild(contentDiv);
              optionDiv.appendChild(btnContainer);
              tetradSection.appendChild(optionDiv);
            });
            
            // Insert tetrad section before control row
            panel.insertBefore(tetradSection, panel.querySelector('.overlay-action-row'));
            
            tetradFromPerspectiveBtn.textContent = '✓ TETRAD GENERATED';
            tetradFromPerspectiveBtn.style.background = '#4ade80';
            
          } catch (err) {
            perspGridCells?.forEach(gridCell => {
              gridCell.style.animation = '';
            });
            tetradFromPerspectiveBtn.textContent = '✗ TETRAD FAILED';
            tetradFromPerspectiveBtn.disabled = false;
            setTimeout(() => {
              tetradFromPerspectiveBtn.textContent = originalText;
            }, 2000);
          }
        });
        
        panel.appendChild(tetradFromPerspectiveBtn);
        
        const sendToChatBtn = document.createElement('button');
        sendToChatBtn.className = 'primary-btn';
        sendToChatBtn.style.cssText = 'margin-top: 12px;';
        sendToChatBtn.textContent = 'SEND TO CHAT';
        sendToChatBtn.addEventListener('click', () => {
          const summary = `${cell.label || cell.type} perspective: ${analysis.perspective || ''}`;
          if (channel.dom?.input) {
            channel.dom.input.value = summary;
            channel.dom.input.focus();
          }
          document.getElementById('perspectiveOverlay').classList.remove('active');
        });
        
        const forkBtn = document.createElement('button');
        forkBtn.className = 'secondary-btn';
        forkBtn.textContent = 'FORK POV CHANNEL';
        forkBtn.addEventListener('click', () => {
          document.getElementById('perspectiveOverlay').classList.remove('active');
          spawnCellPerspectiveChannel(channel, x, y, cell);
        });
        
        const controlRow = document.createElement('div');
        controlRow.className = 'overlay-action-row';
        controlRow.style.cssText = 'margin-top: 12px;';
        controlRow.appendChild(sendToChatBtn);
        controlRow.appendChild(forkBtn);
        panel.appendChild(controlRow);
      } catch (err) {
        // Stop grid animations on error
        gridCells?.forEach(gridCell => {
          gridCell.style.animation = '';
        });
        
        panel.innerHTML = '';
        const closeBtn = document.createElement('button');
        closeBtn.className = 'close-overlay';
        closeBtn.textContent = '×';
        closeBtn.addEventListener('click', () => document.getElementById('perspectiveOverlay').classList.remove('active'));
        panel.appendChild(closeBtn);

        const fail = document.createElement('div');
        fail.className = 'overlay-section';
        const l = document.createElement('div');
        l.className = 'overlay-label';
        l.textContent = 'Perspective Failed';
        const v = document.createElement('div');
        v.className = 'overlay-value';
        v.textContent = err.message;
        fail.appendChild(l);
        fail.appendChild(v);
        panel.appendChild(fail);
      }
    }

    function spawnCellPerspectiveChannel(sourceChannel, x, y, cell) {
      const labelRoot = cell?.label || cell?.type || `Cell (${x},${y})`;
      const safeLabel = labelRoot.replace(/\s+/g, ' ').trim() || `Cell (${x},${y})`;
      const shortLabel = `${safeLabel}`.toUpperCase().slice(0, 16);
      const systemInstruction = [
        sourceChannel.systemInstruction,
        `Stay in viewpoint as ${safeLabel}. Anchor narrative to grid cell (${x},${y}) and reference its event history when relevant.`
      ].join('\n');

      const newChannel = createChannel({
        name: `${sourceChannel.name} • ${shortLabel} POV`,
        scenario: sourceChannel.scenario,
        systemInstruction,
        parentChannelId: sourceChannel.id,
        forkPoint: {
          mode: 'cell-perspective',
          coordinates: { x, y },
          cellId: cell?.id || null
        },
        grid: deepClone(sourceChannel.grid),
        cells: deepClone(sourceChannel.cells),
        observer: deepClone(sourceChannel.observer),
        scorecard: deepClone(sourceChannel.scorecard),
        tetrad: {},
        lastScene: deepClone(sourceChannel.lastScene),
        messages: []
      });

      addMessageToChannel(newChannel, 'system', `POV channel launched for ${safeLabel} at (${x},${y}).`);
      if (sourceChannel.lastScene?.sceneSummary) {
        const title = sourceChannel.lastScene.sceneTitle || 'Latest Scene';
        addMessageToChannel(
          newChannel,
          'system',
          `${title} — ${sourceChannel.lastScene.sceneSummary}`,
          { autoCollapse: true }
        );
      }
      if (newChannel.dom?.input) {
        newChannel.dom.input.value = `From ${safeLabel}'s perspective, ...`;
        newChannel.dom.input.focus();
      }
      showHelpBanner(`POV channel launched for ${safeLabel}.`);
      focusChannel(newChannel.id);
    }

    function routeMessage(sourceChannel, targetChannel, message) {
      addMessageToChannel(targetChannel, 'user', message.text, { fromChannel: sourceChannel.name });
      focusChannel(targetChannel.id);
      showHelpBanner(`Routed message to ${targetChannel.name}`);
    }

    function forkChannel(channel, message, mode, options = {}) {
      const messageId = message?.id ?? null;
      const idx = channel.messages.findIndex(m => m.id === messageId);
      const history = idx >= 0 ? channel.messages.slice(0, idx + 1) : channel.messages.slice();
      const label = forkLabels[mode] || 'Fork';
      const baseName = sanitizeHandle(`${channel.name}-${label}`, label);
      let newChannelConfig;

      if (mode === 'blank') {
        newChannelConfig = {
          name: baseName,
          scenario: channel.scenario,
          parentChannelId: channel.id,
          forkPoint: { messageId, mode },
          ringBinding: channel.ringBinding || null
        };
      } else if (mode === 'snapshot') {
        const snapshotId = options.snapshotId || window.prompt('Snapshot ID or name?');
        const snapshot = channel.snapshots.find(s => s.id === snapshotId || s.name === snapshotId);
        if (!snapshot) {
          showHelpBanner('Snapshot not found.');
          return;
        }
        newChannelConfig = {
          name: baseName,
          scenario: channel.scenario,
          parentChannelId: channel.id,
          forkPoint: { messageId, mode, snapshotId: snapshot.id },
          grid: deepClone(snapshot.grid),
          cells: deepClone(snapshot.cells),
          observer: deepClone(snapshot.observer),
          scorecard: deepClone(snapshot.scorecard),
          tetrad: deepClone(snapshot.tetrad),
          lastScene: deepClone(snapshot.lastScene),
          messages: deepClone(history),
          ringBinding: channel.ringBinding || null
        };
      } else if (mode === 'perspective') {
        const entityName = window.prompt('Which entity perspective?');
        const systemInstruction = `${channel.systemInstruction}
Focus entirely on the perspective of ${entityName || 'the selected entity'}. Provide POV insights per turn.`;
        newChannelConfig = {
          name: sanitizeHandle(`${channel.name}-POV`, baseName),
          scenario: channel.scenario,
          parentChannelId: channel.id,
          systemInstruction,
          forkPoint: { messageId, mode, entity: entityName },
          grid: deepClone(channel.grid),
          cells: deepClone(channel.cells),
          observer: deepClone(channel.observer),
          scorecard: deepClone(channel.scorecard),
          tetrad: {},
          lastScene: deepClone(channel.lastScene),
          messages: deepClone(history),
          ringBinding: channel.ringBinding || null
        };
      } else if (['continue', 'enhance', 'reverse', 'retrieve', 'obsolesce'].includes(mode)) {
        newChannelConfig = {
          name: baseName,
          scenario: channel.scenario,
          systemInstruction: channel.systemInstruction,
          parentChannelId: channel.id,
          forkPoint: { messageId, mode },
          grid: deepClone(channel.grid),
          cells: deepClone(channel.cells),
          observer: deepClone(channel.observer),
          scorecard: deepClone(channel.scorecard),
          tetrad: {},
          lastScene: deepClone(channel.lastScene),
          messages: deepClone(history),
          ringBinding: channel.ringBinding || null
        };
      } else {
        newChannelConfig = {
          name: baseName,
          scenario: channel.scenario,
          parentChannelId: channel.id,
          forkPoint: { messageId, mode },
          ringBinding: channel.ringBinding || null
        };
      }

      if (options.ringEntryId) {
        newChannelConfig.ringBinding = options.ringEntryId;
      }

      const forked = createChannel(newChannelConfig);
      if (mode !== 'blank') {
        if (['enhance', 'reverse', 'retrieve', 'obsolesce'].includes(mode) && channel.tetrad?.[mode]?.text) {
          addMessageToChannel(forked, 'system', `Forked via ${mode.toUpperCase()} tetrad option.`);
          addMessageToChannel(forked, 'user', channel.tetrad[mode].text, { forkLabel: mode.toUpperCase() });
        } else {
          addMessageToChannel(forked, 'system', `Forked from ${channel.name} @ message ${messageId ?? '—'} (${label}).`);
        }
      } else {
        addMessageToChannel(forked, 'system', 'Blank fork created. Describe a new trajectory.');
      }
      const forkEntry = logRingEntry({
        type: 'fork',
        channelId: forked.id,
        channelName: forked.name,
        symbol: forked.name,
        headline: `Forked via ${label}`,
        summary: message?.text || ''
      });
      forked.ringBinding = forkEntry.id;
      renderChannel(forked);
      
      // Animate colored ball moving to new forked channel
      setTimeout(() => animateChannelTransition(channel, forked), 100);
      
      renderTimeline();
      focusChannel(forked.id);
      persistState();
    }

    function setChannelScenario(channel, scenarioId) {
      if (!scenarios[scenarioId]) return;
      const previousDefault = resolveChannelName('', channel.scenario, channel.symbolicId);
      channel.scenario = scenarioId;
      if (channel.name === previousDefault) {
        channel.name = resolveChannelName('', scenarioId, channel.symbolicId);
      }
      channel.systemInstruction = scenarios[scenarioId].systemInstruction;
      channel.resetState();
      if (snapshotOverlayChannel === channel) {
        snapshotOverlayChannel = null;
        const overlay = document.getElementById('snapshotOverlay');
        if (overlay) overlay.classList.remove('active');
      }
      addMessageToChannel(channel, 'system', `${scenarios[scenarioId].name} scenario primed. ${scenarios[scenarioId].intro}`);
      if (scenarios[scenarioId].initialPrompt) {
        channel.dom.input.value = scenarios[scenarioId].initialPrompt;
      }
      renderChannel(channel);
      persistState();
    }

    function exportState() {
      const overlay = document.getElementById('exportOverlay');
      overlay.classList.remove('active');
      const payload = {
        exportedAt: new Date().toISOString(),
        theme: appState.theme,
        channels: appState.channels.map(ch => ch.serialize()),
        ring: {
          entries: ringMemory.entries,
          mainline: ringMemory.mainline,
          contextMode: ringMemory.contextMode,
          contextAnchor: ringMemory.contextAnchor,
          counter: ringEntryCounter
        }
      };
      const blob = new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `legos-multi-channel-${Date.now()}.json`;
      a.click();
      URL.revokeObjectURL(url);
      showHelpBanner('Exported multi-channel state.');
    }

    function handleImportFile(event) {
      const file = event.target.files?.[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const data = JSON.parse(e.target.result);
          restoreFromImport(data);
          showHelpBanner('Imported multi-channel session.');
        } catch (err) {
          console.error(err);
          showHelpBanner('Import failed. Invalid file.');
        }
      };
      reader.readAsText(file);
      event.target.value = '';
    }

    function restoreFromImport(data) {
      const snapshotOverlay = document.getElementById('snapshotOverlay');
      if (snapshotOverlay) snapshotOverlay.classList.remove('active');
      snapshotOverlayChannel = null;
      document.getElementById('channelScroller').innerHTML = '';
      appState.channels = [];
      channelMap.clear();
      (data.channels || []).forEach(cfg => {
        const channel = new Channel(cfg);
        channelMap.set(channel.id, channel);
        appState.channels.push(channel);
        mountChannel(channel);
        const numeric = parseInt((channel.symbolicId || '').replace(/[^0-9]/g, ''), 10);
        if (!Number.isNaN(numeric)) {
          channelSequence = Math.max(channelSequence, numeric + 1);
        }
      });
      appState.currentChannelId = appState.channels[0]?.id || null;
      if (data.theme) {
        applyTheme(data.theme);
      } else {
        applyTheme(appState.theme);
      }
      ringMemory.entries = [];
      ringMemory.mainline = null;
      ringMemory.contextMode = 'all';
      ringMemory.contextAnchor = null;
      ringEntryCounter = 1;
      if (data.ring) {
        const restoredEntries = (data.ring.entries || []).map(entry => ({
          ...entry,
          channelName: sanitizeHandle(entry.channelName || 'GLOBAL', 'GLOBAL'),
          symbol: sanitizeHandle(entry.symbol || entry.channelName || 'ENTRY', 'ENTRY'),
          type: sanitizeHandle(entry.type || 'NOTE', 'NOTE')
        }));
        ringMemory.entries = restoredEntries.slice(-ringMemory.capacity);
        ringMemory.mainline = data.ring.mainline || null;
        ringMemory.contextMode = data.ring.contextMode || 'all';
        ringMemory.contextAnchor = data.ring.contextAnchor
          || ringMemory.entries[ringMemory.entries.length - 1]?.id
          || null;
        const storedCounter = parseInt(data.ring.counter, 10);
        if (Number.isFinite(storedCounter) && storedCounter > ringEntryCounter) {
          ringEntryCounter = storedCounter;
        } else if (ringMemory.entries.length && !storedCounter) {
          const numeric = ringMemory.entries
            .map(entry => parseInt(String(entry.id).replace(/[^0-9]/g, ''), 10))
            .filter(Number.isFinite);
          if (numeric.length) {
            ringEntryCounter = Math.max(...numeric) + 1;
          }
        }
      }
      renderTimeline();
      renderRingBar();
      renderRingContext();
      syncRingContextButtons();
      persistState();
    }

    // Sound system
    let soundInitialized = false;
    let synth = null;

    async function initSound() {
      if (soundInitialized || typeof Tone === 'undefined') return;
      try {
        await Tone.start();
        synth = new Tone.Synth({
          oscillator: { type: 'sine' },
          envelope: { attack: 0.02, decay: 0.1, sustain: 0, release: 0.2 }
        }).toDestination();
        synth.volume.value = -24;
        soundInitialized = true;
      } catch (e) {
        console.warn('Sound init failed:', e);
      }
    }

    function playComposingTick() {
      if (!soundInitialized || !synth) return;
      try {
        synth.triggerAttackRelease('C5', '0.05');
      } catch (e) {
        console.warn('Sound play failed:', e);
      }
    }

    function playRevealChime() {
      if (!soundInitialized || !synth) return;
      try {
        synth.triggerAttackRelease('E5', '0.1');
        setTimeout(() => synth.triggerAttackRelease('G5', '0.1'), 100);
      } catch (e) {
        console.warn('Sound play failed:', e);
      }
    }

    document.addEventListener('click', async (event) => {
      if (!soundInitialized) await initSound();
      if (!event.target.closest('.message')) {
        closeAllMenus();
      }
    });

    window.addEventListener('beforeunload', persistState);

    document.addEventListener('DOMContentLoaded', initApp);
  </script>
  
  <!-- Tutorial System - Draws LEGOS on grid -->
  <script src="tutorial-system.js"></script>
</body>
</html>
