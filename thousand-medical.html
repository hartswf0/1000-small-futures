<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>LEGOS Medical Training Engine</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='75' font-size='80'>✦</text></svg>">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }

    :root {
      --transition: cubic-bezier(0.4, 0, 0.2, 1);
      --column-width: min(100vw, 420px);
    }

    body {
      --bg: #03180c;
      --panel: #052010;
      --panel-dark: #03140d;
      --border: #0c3a23;
      --border-light: #1b6e3e;
      --text: #aef3c1;
      --text-muted: #5ea275;
      --accent: #56ff9f;
      --accent-soft: rgba(86, 255, 159, 0.12);
      --accent-glow: rgba(86, 255, 159, 0.32);
      --danger: #ff5c7c;
      --success: #56ff9f;
      --grid-highlight: rgba(86, 255, 159, 0.08);
      --shadow: rgba(0, 0, 0, 0.45);
      --overlay-backdrop: rgba(4, 20, 12, 0.88);
      font-family: 'Courier New', monospace;
      font-size: clamp(11px, 2.4vw, 13px);
      background: var(--bg);
      color: var(--text);
      overflow: hidden;
      min-height: 100vh;
      min-height: 100dvh;
    }

    body.theme-crt {
      --bg: #03180c;
      --panel: #052010;
      --panel-dark: #03140d;
      --border: #0c3a23;
      --border-light: #1b6e3e;
      --text: #aef3c1;
      --text-muted: #5ea275;
      --accent: #56ff9f;
      --accent-soft: rgba(86, 255, 159, 0.12);
      --accent-glow: rgba(86, 255, 159, 0.32);
      --danger: #ff5c7c;
      --success: #56ff9f;
      --grid-highlight: rgba(86, 255, 159, 0.08);
      --overlay-backdrop: rgba(4, 20, 12, 0.88);
      --shadow: rgba(0, 0, 0, 0.45);
    }

    body.theme-parchment {
      --bg: #f6efdd;
      --panel: #efe4c8;
      --panel-dark: #e4d3b0;
      --border: #cdb181;
      --border-light: #b99158;
      --text: #3b3322;
      --text-muted: #7b6d4d;
      --accent: #d17b24;
      --accent-soft: rgba(209, 123, 36, 0.14);
      --accent-glow: rgba(209, 123, 36, 0.32);
      --danger: #c2463b;
      --success: #2e8f4d;
      --grid-highlight: rgba(209, 123, 36, 0.16);
      --overlay-backdrop: rgba(247, 240, 222, 0.92);
      --shadow: rgba(74, 58, 32, 0.28);
    }

    body.theme-thousand {
      --bg: #050507;
      --panel: rgba(28, 12, 18, 0.92);
      --panel-dark: rgba(18, 8, 12, 0.92);
      --border: #2f121a;
      --border-light: #812934;
      --text: #f6f2ef;
      --text-muted: #d3cdc9;
      --accent: #ff3d4e;
      --accent-soft: rgba(255, 61, 78, 0.18);
      --accent-glow: rgba(255, 61, 78, 0.35);
      --danger: #ff6d7a;
      --success: #f8d66a;
      --grid-highlight: rgba(255, 61, 78, 0.14);
      --overlay-backdrop: rgba(12, 6, 12, 0.88);
      --shadow: rgba(0, 0, 0, 0.6);
    }

    .app-shell {
      position: relative;
      width: 100vw;
      height: 100vh;
      height: 100dvh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
    }

    .scroll-container {
      .channel-scroller {
        display: flex;
        overflow-x: auto;
        overflow-y: hidden;
        gap: 0;
        scroll-snap-type: x mandatory;
        scroll-behavior: smooth;
        -webkit-overflow-scrolling: touch;
        position: relative;
      }
      
      .channel-scroller::-webkit-scrollbar {
        height: 6px;
      }
      
      .channel-scroller::-webkit-scrollbar-track {
        background: var(--panel-dark);
      }
      
      .channel-scroller::-webkit-scrollbar-thumb {
        background: var(--accent);
        border-radius: 3px;
      }
      flex: 1;
      display: flex;
      overflow-x: auto;
      overflow-y: hidden;
      scroll-snap-type: x mandatory;
      scroll-behavior: smooth;
      -webkit-overflow-scrolling: touch;
      background: var(--bg);
      gap: 1px;
      border-top: 1px solid var(--border);
    }

    .channel-column {
      position: relative;
      flex: 0 0 var(--column-width);
      max-width: var(--column-width);
      height: calc(100vh - env(safe-area-inset-top) - env(safe-area-inset-bottom));
      height: calc(100dvh - env(safe-area-inset-top) - env(safe-area-inset-bottom));
      background: var(--panel-dark);
      border-right: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      scroll-snap-align: start;
      transition: transform 0.45s var(--transition), opacity 0.45s var(--transition);
      padding: 0 16px;
      box-sizing: border-box;
    }

    .channel-column.collapsed {
      flex: 0 0 52px;
      max-width: 52px;
      min-width: 52px;
      border-right: 1px solid var(--border);
      box-shadow: 2px 0 8px var(--shadow);
      overflow: visible;
      position: relative;
    }

    .channel-head {
      display: flex;
      flex-direction: column;
      gap: 12px;
      align-items: stretch;
      padding: 12px 16px;
      border-bottom: 1px solid var(--border);
      background: var(--panel);
      transition: opacity 0.3s var(--transition);
    }

    .channel-column.collapsed .channel-head,
    .channel-column.collapsed .channel-body {
      opacity: 0;
      pointer-events: none;
    }

    .channel-meta {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
      text-align: center;
    }

    .channel-name {
      display: none !important;
    }

    .channel-lineage {
      font-size: 7.5px;
      color: var(--text-muted);
      letter-spacing: 0.18em;
      text-transform: uppercase;
    }

    .channel-actions {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }

    .channel-head select,
    .channel-head button {
      touch-action: manipulation;
    }

    .channel-number-rail {
      display: flex;
      flex-direction: column;
      gap: 12px;
      align-items: center;
      justify-content: flex-start;
      width: 32px;
      flex-shrink: 0;
      overflow-y: auto;
      overflow-x: hidden;
      padding: 12px 0;
      position: sticky;
      top: 0;
      max-height: 100%;
      z-index: 2;
    }
    
    .channel-number-rail::-webkit-scrollbar {
      width: 4px;
    }
    
    .channel-number-rail::-webkit-scrollbar-thumb {
      background: var(--border);
      border-radius: 2px;
    }

    .channel-number {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      border: 2px solid var(--border);
      background: var(--panel-dark);
      color: var(--text-muted);
      font-size: 9px;
      font-weight: 700;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.2s var(--transition);
      flex-shrink: 0;
    }

    .channel-number.active {
      background: var(--accent);
      color: var(--bg);
      border-color: var(--accent);
      box-shadow: 0 0 12px var(--accent-glow);
    }

    .channel-number.add {
      border-style: dashed;
    }

    select.channel-scenario {
      background: var(--panel-dark);
      border: 1px solid var(--border);
      color: var(--text-muted);
      font-size: 9px;
      letter-spacing: 0.18em;
      padding: 6px 10px;
      border-radius: 3px;
      cursor: pointer;
      position: relative;
      z-index: 100;
    }

    .channel-btn {
      width: 30px;
      height: 30px;
      border-radius: 50%;
      background: var(--panel-dark);
      border: 1px solid var(--border);
      color: var(--text-muted);
      font-size: 12px;
      cursor: pointer;
      transition: all 0.25s var(--transition);
    }

    .channel-btn:active {
      transform: scale(0.9);
      color: var(--text);
      background: var(--panel);
    }

    .channel-head {
      margin-top: 0;
      border-radius: 0;
    }

    .channel-body {
      flex: 1;
      display: flex;
      flex-direction: column;
      min-height: 0;
      margin-bottom: clamp(44px, 10vw, 64px);
      gap: 8px;
    }

    .channel-column.collapsed .channel-body {
      margin-bottom: 0;
    }
    
    .channel-column:not([data-channel-id]) {
      opacity: 0.5;
      filter: grayscale(0.3);
    }
    
    .channel-column.inactive {
      opacity: 0.4;
      filter: saturate(0.5);
      transition: opacity 0.3s var(--transition), filter 0.3s var(--transition);
    }
    
    .channel-column.channel-active {
      box-shadow: 0 0 0 3px var(--accent), 0 0 30px var(--accent-glow);
      position: relative;
      z-index: 10;
      opacity: 1 !important;
    }
    
    .channel-column.channel-active::before {
      content: '';
      position: absolute;
      top: -2px;
      left: -2px;
      right: -2px;
      bottom: -2px;
      border: 3px solid var(--accent);
      border-radius: 8px;
      pointer-events: none;
      animation: pulse-border 1.5s ease-in-out infinite;
      opacity: 0.9;
    }
    
    @keyframes pulse-border {
      0%, 100% { opacity: 0.7; transform: scale(1); }
      50% { opacity: 1; transform: scale(1.005); }
    }
    
    @keyframes sparkle {
      0%, 100% { opacity: 1; text-shadow: 0 0 8px currentColor; }
      50% { opacity: 0.6; text-shadow: 0 0 16px currentColor, 0 0 24px currentColor; }
    }
    
    /* Channel color theming */
    .channel-column .channel-btn:hover {
      background: var(--channel-color, var(--accent)) !important;
      color: var(--bg) !important;
      border-color: var(--channel-color, var(--accent)) !important;
    }
    
    .channel-column .send-btn {
      background: var(--channel-color, var(--accent));
      border-color: var(--channel-color, var(--accent));
    }
    
    .channel-column .grid-cell.occupied {
      border-color: var(--channel-color, var(--accent));
    }
    
    .channel-column .message-dot {
      color: var(--channel-color, var(--accent));
      border-color: var(--channel-color, var(--accent));
    }
    
    .channel-column .channel-head {
      border-bottom-color: var(--channel-color, var(--border));
    }
    
    .channel-column .channel-footer {
      border-top-color: var(--channel-color, var(--border));
    }
    
    .channel-column .channel-scenario:hover,
    .channel-column .channel-scenario:focus {
      border-color: var(--channel-color, var(--accent));
    }

    .overlay-section {
      padding: 12px 0;
      border-bottom: 1px solid var(--border);
    }
    
    .overlay-section.clickable {
      cursor: pointer;
      transition: all 0.2s var(--transition);
      padding: 12px 8px;
      margin: 0 -8px;
      border-radius: 4px;
    }
    
    .overlay-section.clickable:hover {
      background: var(--panel-dark);
      border-color: var(--accent);
    }
    
    .overlay-section.clickable .overlay-value {
      position: relative;
    }
    
    .overlay-section.clickable:hover .overlay-value::after {
      content: '→ Send to chat';
      position: absolute;
      right: 0;
      top: 0;
      font-size: 8px;
      color: var(--accent);
      opacity: 0.7;
      letter-spacing: 0.1em;
    }

    .resize-bar {
      height: 6px;
      background: var(--border);
      cursor: row-resize;
      flex-shrink: 0;
      transition: background 0.2s;
      position: relative;
      touch-action: none;
    }
    
    .resize-bar:hover,
    .resize-bar:active {
      background: var(--accent);
    }
    
    .resize-bar::before {
      content: '';
      position: absolute;
      top: -12px;
      bottom: -12px;
      left: 0;
      right: 0;
    }
    
    .grid-section {
      flex: 0 0 50vh;
      height: 50vh;
      display: flex;
      flex-direction: column;
      min-width: 0;
      position: relative;
    }

    .grid-section.collapsed {
      max-height: 0;
      padding: 0;
      overflow: hidden;
      opacity: 0;
      border: none;
    }

    .grid-area {
      display: flex;
      align-items: stretch;
      gap: 10px;
    }

    .grid-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
    }

    .grid-title {
      font-size: 8px;
      letter-spacing: 0.2em;
      color: var(--text-muted);
    }

    .grid-toggle {
      font-size: 11px;
      cursor: pointer;
      color: var(--text-muted);
    }

    .grid-wrapper {
      border: 1px solid var(--border);
      background: var(--panel);
      padding: 8px;
      border-radius: 4px;
      transition: max-height 0.3s var(--transition), opacity 0.3s var(--transition);
      flex: 1;
      display: flex;
    }

    .grid-wrapper.collapsed {
      max-height: 0;
      opacity: 0;
      padding: 0;
      overflow: hidden;
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(9, 1fr);
      grid-template-rows: repeat(9, 1fr);
      gap: 2px;
      aspect-ratio: 1;
      width: 100%;
      height: 100%;
      max-width: min(100%, calc(50vh - 80px));
      max-height: min(100%, calc(50vh - 80px));
    }

    .grid-cell {
      position: relative;
      background: var(--panel);
      border: 1px solid var(--border);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: clamp(12px, 2.5vw, 18px);
      font-weight: 700;
      color: var(--text-muted);
      cursor: pointer;
      transition: all 0.5s ease-in-out; /* Smooth cultural movement and color changes */
    }

    .grid-cell:hover {
      border-color: var(--accent);
      transform: scale(1.05);
      z-index: 10;
      box-shadow: 0 0 12px var(--accent-soft);
    }

    .grid-cell.resonance-field::after {
      content: '';
      position: absolute;
      inset: -1px;
      background: radial-gradient(circle, var(--accent-soft) 0%, transparent 70%);
      opacity: 0;
      animation: resonancePulse 2s ease-in-out infinite;
      pointer-events: none;
      z-index: 1;
    }

    .grid-cell.loading {
      animation: cellularAutomata 0.8s ease-in-out infinite;
      border-color: var(--accent);
    }
    
    @keyframes cellularAutomata {
      0% {
        background: var(--panel);
        box-shadow: inset 0 0 8px transparent;
      }
      25% {
        background: linear-gradient(135deg, var(--panel) 0%, var(--accent-soft) 50%, var(--panel) 100%);
        box-shadow: inset 0 0 12px var(--accent-soft);
      }
      50% {
        background: var(--accent-soft);
        box-shadow: inset 0 0 16px var(--accent-glow);
      }
      75% {
        background: linear-gradient(225deg, var(--panel) 0%, var(--accent-soft) 50%, var(--panel) 100%);
        box-shadow: inset 0 0 12px var(--accent-soft);
      }
      100% {
        background: var(--panel);
        box-shadow: inset 0 0 8px transparent;
      }
    }

    .grid-cell.occupied {
      color: var(--text);
      border-color: var(--accent);
      background: linear-gradient(135deg, var(--grid-highlight) 0%, var(--panel) 100%);
      box-shadow: 0 0 0 1px var(--accent-soft) inset, 0 2px 4px rgba(0,0,0,0.2);
      font-weight: 900;
      text-shadow: 0 1px 2px rgba(0,0,0,0.3);
    }

    .grid-cell.occupied[data-cell-type="Entity"] {
      animation: entityPulse 3s ease-in-out infinite;
    }

    .grid-cell.occupied[data-cell-type="Goal"] {
      animation: goalBeacon 2.5s ease-in-out infinite;
    }

    @keyframes entityPulse {
      0%, 100% { box-shadow: 0 0 0 1px var(--accent-soft) inset, 0 2px 4px rgba(0,0,0,0.2), 0 0 8px var(--accent-soft); }
      50% { box-shadow: 0 0 0 1px var(--accent-soft) inset, 0 2px 4px rgba(0,0,0,0.2), 0 0 16px var(--accent-glow); }
    }

    @keyframes goalBeacon {
      0%, 100% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.03); opacity: 0.95; }
    }
    
    @keyframes slideInRight {
      from {
        transform: translateX(100%);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }
    
    @keyframes rippleOut {
      0% {
        box-shadow: 0 0 0 0 var(--accent),
                    0 0 0 0 var(--accent-soft),
                    inset 0 0 20px var(--accent-glow);
        transform: scale(1);
      }
      50% {
        box-shadow: 0 0 0 8px transparent,
                    0 0 0 16px transparent,
                    inset 0 0 30px var(--accent-glow);
        transform: scale(1.1);
      }
      100% {
        box-shadow: 0 0 0 0 transparent,
                    0 0 0 0 transparent,
                    inset 0 0 0 transparent;
        transform: scale(1);
      }
    }
    
    .grid-cell.ripple {
      animation: rippleOut 0.8s cubic-bezier(0.4, 0, 0.2, 1) forwards;
    }
    
    .name-flash {
      position: absolute;
      font-size: 11px;
      font-weight: 900;
      letter-spacing: 0.2em;
      color: var(--accent);
      text-shadow: 0 0 15px var(--accent-glow), 0 0 30px var(--accent-glow);
      opacity: 0;
      animation: nameFlashSmooth 4s ease-in-out forwards;
      pointer-events: none;
      z-index: 1000;
      white-space: nowrap;
      padding: 6px 10px;
      background: rgba(0, 0, 0, 0.95);
      border-radius: 4px;
      border: 2px solid currentColor;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.9);
    }
    
    .name-flash.new {
      color: #4ade80;
      text-shadow: 0 0 15px #4ade80, 0 0 30px #4ade80;
      border-color: #4ade80;
    }
    
    .name-flash.moved {
      color: #60a5fa;
      text-shadow: 0 0 15px #60a5fa, 0 0 30px #60a5fa;
      border-color: #60a5fa;
    }
    
    .name-flash.disappeared {
      color: #f87171;
      text-shadow: 0 0 15px #f87171, 0 0 30px #f87171;
      border-color: #f87171;
    }
    
    @keyframes nameFlashSmooth {
      0% {
        opacity: 0;
        transform: scale(0.8) translateY(-10px);
      }
      15% {
        opacity: 1;
        transform: scale(1) translateY(0);
      }
      85% {
        opacity: 1;
        transform: scale(1) translateY(0);
      }
      100% {
        opacity: 0;
        transform: scale(0.9) translateY(5px);
      }
    }
    
    .grid-cell.composing-active::before {
      content: attr(data-compose-letter);
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 14px;
      font-weight: 900;
      color: var(--accent);
      text-shadow: 0 0 12px var(--accent-glow);
      animation: letterDance 0.6s ease-in-out infinite;
      z-index: 0;
      opacity: 0.7;
    }
    
    @keyframes letterDance {
      0%, 100% {
        transform: translate(-50%, -50%) rotate(-5deg) scale(1);
      }
      50% {
        transform: translate(-50%, -50%) rotate(5deg) scale(1.15);
      }
    }

    .grid-label {
      position: absolute;
      bottom: 2px;
      left: 2px;
      right: 2px;
      font-size: 6px;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      padding: 1px 2px;
      border-radius: 2px;
      backdrop-filter: blur(2px);
      text-shadow: none;
      font-weight: 700;
      line-height: 1;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: calc(100% - 4px);
    }
    
    .grid-label.dark-text {
      color: rgba(0, 0, 0, 0.85);
      background: rgba(255, 255, 255, 0.7);
    }
    
    .grid-label.light-text {
      color: rgba(255, 255, 255, 0.95);
      background: rgba(0, 0, 0, 0.6);
    }
    
    .grid-cell:hover .grid-label {
      font-size: 8px;
      padding: 2px 4px;
      opacity: 1;
      z-index: 100;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.8);
    }

    .grid-collapse-btn {
      width: 24px;
      height: 24px;
      border-radius: 4px;
      border: 1px solid var(--border);
      background: var(--panel);
      color: var(--text-muted);
      font-size: 12px;
      cursor: pointer;
      transition: all 0.2s var(--transition);
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .grid-collapse-btn:hover {
      background: var(--accent);
      color: var(--bg);
      border-color: var(--accent);
    }

    .chat-section {
      flex: 1;
      display: flex;
      flex-direction: column;
      background: var(--panel);
      min-height: 0;
      overflow: hidden;
      transition: flex 0.3s var(--transition);
      position: relative;
      padding-top: 12px;
      gap: 12px;
    }

    .channel-body.grid-collapsed .grid-section.collapsed ~ .chat-section {
      flex: 2;
    }

    .message-list {
      flex: 1;
      overflow-y: auto;
      padding: 0;
      display: flex;
      flex-direction: column;
      gap: 8px;
      min-height: 0;
    }

    .message {
      display: flex;
      flex-direction: column;
      gap: 6px;
      background: var(--panel);
      border: 1px solid var(--border);
      padding: 12px 14px;
      border-radius: 4px;
      position: relative;
      transition: transform 0.2s var(--transition);
    }

    .message.active {
      border-color: var(--accent);
      box-shadow: 0 0 12px var(--accent-soft);
    }

    .message.user {
      border-left: 2px solid var(--success);
      cursor: pointer;
    }

    .message.assistant {
      border-left: 2px solid var(--accent);
      cursor: pointer;
    }

    .message.system {
      border-left: 2px solid var(--text-muted);
      background: var(--panel-dark);
      opacity: 0.85;
    }

    .message.collapsed .message-body {
      max-height: 0;
      opacity: 0.2;
      overflow: hidden;
    }
    
    .message.collapsed .tetrad-chips-inline {
      display: flex !important;
      opacity: 1 !important;
      max-height: none !important;
    }

    .message.collapsed .message-preview {
      opacity: 1;
    }

    .message-header {
      display: flex;
      gap: 8px;
      align-items: center;
      font-size: 8px;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      color: var(--text-muted);
    }

    .ring-indicator {
      font-size: 12px;
      filter: drop-shadow(0 0 8px currentColor);
      animation: ringPulse 2s ease-in-out infinite;
      cursor: help;
    }

    @keyframes ringPulse {
      0%, 100% { opacity: 0.6; }
      50% { opacity: 1; }
    }

    .message-color-dot {
      font-size: 10px;
      line-height: 1;
      filter: drop-shadow(0 0 6px currentColor);
      flex-shrink: 0;
      font-weight: bold;
    }

    .message-color-dot.parent-dot {
      opacity: 0.6;
      font-size: 8px;
      margin-right: -4px;
    }

    .message-dot.forked-dot {
      position: relative;
    }

    .message-dot.forked-dot::after {
      content: '';
      position: absolute;
      top: -2px;
      left: -2px;
      right: -2px;
      bottom: -2px;
      border-radius: 50%;
      border: 2px solid currentColor;
      pointer-events: none;
    }

    .message-preview {
      font-size: 9px;
      letter-spacing: 0.12em;
      color: var(--text-muted);
      display: none;
    }

    .message.collapsed .message-preview {
      display: block;
    }

    .message-body {
      color: var(--text);
      line-height: 1.6;
      white-space: pre-wrap;
      transition: opacity 0.2s var(--transition);
    }

    .message-actions {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: var(--panel);
      border: 1px solid var(--accent);
      border-radius: 6px;
      display: none;
      flex-direction: column;
      min-width: 240px;
      max-width: 90vw;
      z-index: 200;
      box-shadow: 0 12px 48px var(--shadow);
    }

    .message-actions.active {
      display: flex;
    }

    .message-actions::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.7);
      z-index: -1;
      backdrop-filter: blur(6px);
    }

    .message-action-close {
      position: absolute;
      top: 8px;
      right: 8px;
      width: 28px;
      height: 28px;
      border-radius: 50%;
      border: 1px solid var(--border);
      background: var(--panel-dark);
      color: var(--text-muted);
      font-size: 14px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s var(--transition);
      z-index: 10;
    }

    .message-action-close:hover {
      background: var(--accent);
      color: var(--bg);
      border-color: var(--accent);
      transform: rotate(90deg);
    }

    .message-action {
      padding: 14px 18px;
      font-size: 10px;
      letter-spacing: 0.2em;
      color: var(--text-muted);
      border-bottom: 1px solid var(--border);
      cursor: pointer;
      transition: all 0.2s var(--transition);
    }

    .message-action.disabled {
      opacity: 0.55;
      cursor: default;
      pointer-events: none;
      font-style: italic;
      color: var(--text-muted);
    }

    .message-action:last-child {
      border-bottom: none;
    }

    .message-action:active {
      background: var(--panel-dark);
      color: var(--text);
    }

    .message.fork-origin {
      border-style: dashed;
      border-color: var(--accent);
    }

    .input-section {
      padding: 12px 0 0 0;
      border-top: 1px solid var(--border);
      background: var(--panel);
      flex-shrink: 0;
      margin-top: 8px;
      position: sticky;
      bottom: 0;
      z-index: 100;
    }
    
    /* Mobile keyboard compensation */
    @supports (height: 100dvh) {
      .channel-column {
        height: 100dvh;
      }
    }

    .input-wrapper {
      display: flex;
      gap: 8px;
      align-items: stretch;
    }

    textarea.message-input {
      flex: 1;
      background: var(--panel-dark);
      border: 1px solid var(--border);
      color: var(--text);
      padding: 8px 10px;
      border-radius: 4px;
      font-size: 10px;
      line-height: 1.4;
      resize: none;
      min-height: 36px;
      max-height: 80px;
      transition: all 0.3s var(--transition);
    }
    
    textarea.message-input:focus {
      outline: none;
      border-color: var(--accent);
      background: var(--panel);
      box-shadow: 0 0 12px var(--accent-glow);
    }
    
    .channel-column.channel-active textarea.message-input {
      border-color: var(--accent);
      box-shadow: 0 0 8px rgba(86, 255, 159, 0.2);
    }

    .footer-btn {
      transition: all 0.2s var(--transition);
    }
    
    .footer-btn:hover {
      background: var(--accent) !important;
      color: var(--bg) !important;
      border-color: var(--accent) !important;
      transform: scale(1.05);
    }
    
    .footer-btn:active {
      transform: scale(0.95);
    }
    
    .tetrad-footer-btn {
      font-size: 16px;
    }

    textarea.message-input:focus {
      outline: none;
      border-color: var(--border-light);
    }

    .send-btn {
      padding: 12px 18px;
      background: var(--panel-dark);
      border: 1px solid var(--border);
      color: var(--text-muted);
      font-size: 9px;
      letter-spacing: 0.2em;
      cursor: pointer;
      transition: all 0.25s var(--transition);
      border-radius: 4px;
    }

    .send-btn:disabled {
      opacity: 0.35;
      cursor: not-allowed;
    }

    .send-btn:active:not(:disabled) {
      transform: scale(0.95);
      color: var(--text);
    }

    .tetrad-chip {
      padding: 12px 16px;
      background: var(--panel);
      border: 3px solid var(--border);
      border-radius: 8px;
      font-size: 9px;
      letter-spacing: 0.2em;
      color: var(--text);
      cursor: pointer;
      transition: all 0.15s var(--transition);
      text-align: center;
      font-weight: bold;
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      text-transform: uppercase;
      white-space: nowrap;
      min-height: 52px;
      box-shadow: 0 2px 0 var(--border), inset 0 1px 0 rgba(255,255,255,0.1);
    }

    .tetrad-chip-text {
      flex: 1;
      text-align: center;
    }

    .tetrad-chip::before {
      content: '▲';
      font-size: 18px;
      color: var(--accent);
      transition: all 0.3s var(--transition);
      position: absolute;
      left: 12px;
    }

    .tetrad-chip.enhance::before { content: '▲'; }
    .tetrad-chip.reverse::before { content: '⇄'; }
    .tetrad-chip.retrieve::before { content: '↺'; }
    .tetrad-chip.obsolesce::before { content: '▼'; }

    .tetrad-chip:hover {
      border-color: var(--accent);
      background: var(--accent);
      color: var(--bg);
      transform: scale(1.02);
    }

    .tetrad-chip:hover::before {
      color: var(--bg);
      transform: scale(1.15);
      filter: drop-shadow(0 0 12px var(--accent-glow));
    }

    .tetrad-chip:active {
      transform: scale(0.95) translateY(2px);
      box-shadow: 0 0 0 var(--border), inset 0 1px 0 rgba(255,255,255,0.1);
    }

    .tetrad-refresh-btn {
      padding: 6px 12px;
      font-size: 8px;
      letter-spacing: 0.18em;
      background: var(--panel);
      color: var(--text-muted);
      border: 1px solid var(--border);
      border-radius: 999px;
      cursor: pointer;
      transition: all 0.2s var(--transition);
    }

    .tetrad-refresh-btn:active:not(:disabled) {
      transform: scale(0.96);
      color: var(--text);
      border-color: var(--accent);
    }

    .tetrad-refresh-btn:disabled {
      opacity: 0.45;
      cursor: not-allowed;
    }

    .corner-btn {
      position: fixed;
      width: 48px;
      height: 48px;
      border-radius: 50%;
      border: 1px solid var(--border);
      background: var(--panel);
      color: var(--text);
      font-size: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 12;
      box-shadow: 0 8px 24px var(--shadow);
      transition: transform 0.2s var(--transition), box-shadow 0.2s var(--transition);
    }

    .corner-btn:active {
      transform: scale(0.92);
      box-shadow: 0 4px 16px var(--accent-soft);
      color: var(--accent);
      border-color: var(--accent);
    }

    .corner-btn.top-left {
      top: calc(16px + env(safe-area-inset-top));
      left: calc(16px + env(safe-area-inset-left));
    }

    .corner-btn.top-right {
      top: calc(16px + env(safe-area-inset-top));
      right: calc(16px + env(safe-area-inset-right));
    }

    .corner-btn.bottom-left {
      bottom: calc(16px + env(safe-area-inset-bottom));
      left: calc(16px + env(safe-area-inset-left));
    }

    .corner-btn.bottom-right {
      bottom: calc(16px + env(safe-area-inset-bottom));
      right: calc(16px + env(safe-area-inset-right));
    }

    .corner-menu {
      position: fixed;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 8px;
      box-shadow: 0 12px 32px var(--shadow);
      display: none;
      flex-direction: column;
      min-width: 160px;
      z-index: 14;
    }

    .corner-menu.visible {
      display: flex;
    }

    .corner-menu button {
      background: transparent;
      border: none;
      color: var(--text-muted);
      padding: 12px 16px;
      font-size: 9px;
      letter-spacing: 0.18em;
      text-align: left;
      cursor: pointer;
      transition: background 0.2s var(--transition), color 0.2s var(--transition);
    }

    .corner-menu button:active {
      background: var(--panel-dark);
      color: var(--text);
    }


    .ring-bar {
      display: none;
    }
    
    .global-footer {
      position: fixed;
      bottom: 8px;
      left: 50%;
      transform: translateX(-50%);
      height: auto;
      background: transparent;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 6px 12px;
      z-index: 100;
      gap: 6px;
    }
    
    .footer-control-btn {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      border: 2px solid var(--border);
      background: var(--panel-dark);
      color: var(--text-muted);
      font-size: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.2s var(--transition);
    }
    
    .footer-control-btn:hover {
      background: var(--accent);
      color: var(--bg);
      border-color: var(--accent);
      transform: scale(1.05);
    }
    
    .footer-control-btn.add {
      border-style: dashed;
      font-size: 24px;
      font-weight: 300;
    }
    
    .global-scenario-select {
      background: var(--panel);
      border: 1px solid var(--border);
      color: var(--text-muted);
      padding: 5px 8px;
      border-radius: 4px;
      font-size: 9px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      cursor: pointer;
      transition: all 0.2s var(--transition);
      min-width: 110px;
      max-width: 130px;
    }
    
    .global-scenario-select:hover,
    .global-scenario-select:focus {
      border-color: var(--accent);
      background: var(--panel);
      outline: none;
    }
    
    .footer-tetrad-btn {
      width: 28px;
      height: 28px;
      border-radius: 4px;
      border: 1px solid var(--border);
      background: var(--panel);
      color: var(--text-muted);
      font-size: 14px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.2s var(--transition);
    }
    
    .footer-tetrad-btn:hover {
      background: var(--accent);
      color: var(--bg);
      transform: scale(1.08);
    }
    
    .scroll-container {
      padding-bottom: 0;
    }

    .ring-bar::-webkit-scrollbar {
      display: none;
    }

    .ring-entry {
      width: 14px;
      height: 14px;
      border-radius: 50%;
      border: 2px solid currentColor;
      background: var(--panel-dark);
      cursor: pointer;
      transition: all 0.3s var(--transition);
      position: relative;
      flex-shrink: 0;
      filter: brightness(1.2) saturate(1.4);
    }

    .ring-entry:hover {
      transform: scale(1.3);
      filter: brightness(1.5) saturate(1.8);
    }

    .ring-entry.active {
      transform: scale(1.25);
      box-shadow: 0 0 12px currentColor;
    }

    .ring-entry.mainline {
      width: 18px;
      height: 18px;
      border-width: 3px;
      box-shadow: 0 0 16px currentColor, inset 0 0 8px currentColor;
      animation: mainlinePulse 3s ease-in-out infinite;
    }

    @keyframes mainlinePulse {
      0%, 100% { opacity: 0.8; }
      50% { opacity: 1; box-shadow: 0 0 24px currentColor, inset 0 0 12px currentColor; }
    }

    .chat-stream {
      display: flex;
      gap: 8px;
      padding: 8px 0 16px 0;
      overflow-y: auto;
      overflow-x: hidden;
      min-height: 0;
    }

    .message-dot-rail {
      display: flex;
      flex-direction: column;
      gap: 12px;
      padding-top: 12px;
      position: sticky;
      top: calc(80px + env(safe-area-inset-top));
      z-index: 2;
      align-items: center;
      width: 32px;
      flex-shrink: 0;
      max-height: calc(100vh - 200px);
      overflow-y: auto;
      overflow-x: hidden;
    }
    
    .message-dot-rail::-webkit-scrollbar {
      width: 4px;
    }
    
    .message-dot-rail::-webkit-scrollbar-thumb {
      background: var(--border);
      border-radius: 2px;
    }

    .message-dot {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      border: 2px solid currentColor;
      background: var(--panel-dark);
      cursor: pointer;
      color: var(--text);
      font-size: 8px;
      flex-shrink: 0;
      font-weight: bold;
      display: flex;
      align-items: center;
      justify-content: center;
      line-height: 1;
      transition: all 0.3s var(--transition);
    }

    .message-dot.assistant {
      box-shadow: 0 0 12px currentColor;
      filter: brightness(1.3) saturate(1.5);
    }

    .message-dot.user {
      width: 20px;
      height: 20px;
      box-shadow: 0 0 10px currentColor;
      filter: brightness(1.4) saturate(1.6);
    }

    .message-dot.system {
      width: 18px;
      height: 18px;
      opacity: 0.75;
      box-shadow: 0 0 6px currentColor;
      filter: brightness(0.8);
    }

    .message-dot.fork-origin {
      border-width: 2px;
      box-shadow: 0 0 10px var(--accent-glow);
    }

    .message-dot.active {
      transform: scale(1.15);
      box-shadow: 0 0 8px var(--accent-glow);
    }

    .send-btn {
      font-size: 18px;
      letter-spacing: 0;
      border-radius: 6px;
      min-width: 44px;
      padding: 0 12px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .grid-cell.occupied:hover {
      transform: scale(1.08);
      box-shadow: 0 0 20px var(--accent-glow);
      z-index: 5;
    }
    
    .grid-cell.occupied::after {
      content: attr(data-full-name);
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.95);
      color: var(--accent);
      padding: 8px 12px;
      border-radius: 4px;
      font-size: 11px;
      font-weight: 700;
      white-space: nowrap;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s;
      z-index: 100;
      border: 1px solid var(--accent);
      box-shadow: 0 4px 12px rgba(0,0,0,0.8);
    }
    
    .grid-cell.occupied:hover::after {
      opacity: 1;
    }

    .tetrad-chip:hover {
      border-color: var(--accent);
      color: var(--text);
    }

    .snapshot-overlay-list {
      max-height: 240px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin: 16px 0;
    }

    .ring-context-block {
      border: 1px solid var(--border);
      border-radius: 4px;
      background: var(--panel-dark);
      padding: 12px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      max-height: 260px;
    }

    .ring-context-controls {
      display: flex;
      gap: 6px;
      justify-content: space-between;
      flex-wrap: wrap;
    }

    .ring-context-btn {
      flex: 1 1 auto;
      text-align: center;
      font-size: 8px;
      letter-spacing: 0.16em;
      padding: 6px 8px;
      border: 1px solid var(--border);
      background: transparent;
      color: var(--text-muted);
      cursor: pointer;
      border-radius: 3px;
      transition: all 0.2s var(--transition);
    }

    .ring-context-btn.active {
      border-color: var(--accent);
      color: var(--accent);
      box-shadow: 0 0 10px var(--accent-soft);
    }

    .ring-context-window {
      font-size: 8px;
      letter-spacing: 0.18em;
      color: var(--text-muted);
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 3px;
      padding: 10px;
      overflow-y: auto;
      white-space: pre-wrap;
      max-height: 180px;
    }

    .snapshot-overlay-item {
      padding: 10px 12px;
      border: 1px solid var(--border);
      background: var(--panel-dark);
      border-radius: 4px;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .snapshot-overlay-meta {
      display: flex;
      justify-content: space-between;
      font-size: 8px;
      letter-spacing: 0.18em;
      color: var(--text-muted);
    }

    .snapshot-overlay-actions {
      display: flex;
      gap: 8px;
    }

    .snapshot-overlay-actions button {
      flex: 1;
    }

    .overlay {
      position: fixed;
      inset: 0;
      background: var(--overlay-backdrop);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 20;
      padding: 24px;
      backdrop-filter: blur(6px);
    }

    .overlay.active {
      display: flex;
    }

    .overlay-card {
      background: var(--panel);
      border: 1px solid var(--border);
      padding: 24px;
      border-radius: 6px;
      width: min(420px, 92vw);
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .overlay-title {
      font-size: 9px;
      letter-spacing: 0.24em;
      color: var(--text);
    }

    .overlay-sub {
      font-size: 8px;
      letter-spacing: 0.16em;
      color: var(--text-muted);
    }

    .overlay-input {
      width: 100%;
      border: 1px solid var(--border);
      background: var(--panel-dark);
      color: var(--text);
      padding: 12px 14px;
      font-size: 10px;
      border-radius: 4px;
    }

    .overlay-actions {
      display: flex;
      justify-content: flex-end;
      gap: 10px;
    }

    .primary-btn {
      padding: 10px 16px;
      border: 1px solid var(--accent);
      background: transparent;
      color: var(--accent);
      letter-spacing: 0.18em;
      cursor: pointer;
      font-size: 9px;
      border-radius: 4px;
    }

    .primary-btn:active:not(:disabled) {
      transform: scale(0.96);
      background: var(--accent-soft);
    }

    .primary-btn:disabled {
      opacity: 0.45;
      cursor: not-allowed;
    }
    
    .tetrad-intervention-btn.glow-active {
      background: var(--accent);
      color: var(--bg);
      box-shadow: 0 0 20px var(--accent-glow), 0 0 40px var(--accent-glow);
      animation: pulse-glow 2s ease-in-out infinite;
    }
    
    .tetrad-intervention-btn.glow-processing {
      background: #60a5fa;
      color: var(--bg);
      box-shadow: 0 0 20px #60a5fa, 0 0 40px #60a5fa;
      animation: pulse-glow 1s ease-in-out infinite;
    }
    
    .tetrad-intervention-btn.glow-success {
      background: #4ade80;
      color: var(--bg);
      box-shadow: 0 0 20px #4ade80;
    }
    
    @keyframes pulse-glow {
      0%, 100% {
        box-shadow: 0 0 15px currentColor, 0 0 30px currentColor;
      }
      50% {
        box-shadow: 0 0 25px currentColor, 0 0 50px currentColor;
      }
    }

    .secondary-btn {
      padding: 10px 16px;
      border: 1px solid var(--border);
      background: transparent;
      color: var(--text-muted);
      letter-spacing: 0.18em;
      cursor: pointer;
      font-size: 9px;
      border-radius: 4px;
    }

    .grid-area {
      flex: 1;
      overflow: hidden;
      padding: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .cell-overlay-content,
    .perspective-overlay-content {
      max-width: 420px;
      width: 92vw;
      border: 1px solid var(--border);
      background: var(--panel);
      border-radius: 6px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .overlay-section {
      display: flex;
      flex-direction: column;
      gap: 6px;
      border: 1px solid var(--border);
      padding: 12px;
      border-radius: 4px;
      background: var(--panel-dark);
    }

    .overlay-label {
      font-size: 8px;
      letter-spacing: 0.16em;
      color: var(--text-muted);
    }

    .overlay-value {
      font-size: 10px;
      line-height: 1.6;
      color: var(--text);
    }

    .overlay-action-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .overlay-action-row button {
      flex: 1 1 auto;
    }

    .close-overlay {
      align-self: flex-end;
      border: none;
      background: transparent;
      color: var(--text-muted);
      font-size: 20px;
      cursor: pointer;
    }

    @media (hover: hover) {
      .message.assistant:hover {
        transform: translateX(4px);
      }

      .grid-cell:hover {
        border-color: var(--border-light);
        transform: scale(1.03);
      }

      .tetrad-chip:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 18px var(--accent-soft);
      }
    }

    ::-webkit-scrollbar {
      width: 4px;
      height: 4px;
    }
    ::-webkit-scrollbar-track {
      background: var(--panel-dark);
    }
    ::-webkit-scrollbar-thumb {
      background: var(--border);
      border-radius: 4px;
    }

    
    .channel-column.composing::after {
      content: 'COMPOSING';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 14px;
      letter-spacing: 0.32em;
      color: var(--accent);
      animation: pulse 1.2s ease-in-out infinite;
      pointer-events: none;
      z-index: 50;
      text-shadow: 0 0 12px var(--accent-glow);
    }

    .message.reveal {
      animation: reveal 0.6s var(--transition) forwards;
    }

    @keyframes pulse {
      0%, 100% { opacity: 0.4; transform: translate(-50%, -50%) scale(0.98); }
      50% { opacity: 1; transform: translate(-50%, -50%) scale(1.02); }
    }

    @keyframes reveal {
      0% { opacity: 0; transform: translateY(12px); }
      100% { opacity: 1; transform: translateY(0); }
    }
  </style>
</head>
<body>
  <div class="app-shell">
    <div class="ring-bar" id="ringBar"></div>
    <div class="scroll-container" id="channelScroller"></div>
    <div class="global-footer" id="globalFooter">
      <select class="global-scenario-select" id="globalScenarioSelect"></select>
      <button class="footer-tetrad-btn" id="globalTetradBtn" title="Set Entity Perspective">✦</button>
    </div>
  </div>

  <div class="overlay" id="keyOverlay">
    <div class="overlay-card">
      <div class="overlay-title">STORE OPENAI KEY</div>
      <div class="overlay-sub">Key persists locally as legos/multi-channel key.</div>
      <input type="password" class="overlay-input" id="keyInput" placeholder="sk-...">
      <div class="overlay-sub" id="keyStatus">Key not stored.</div>
      <div class="overlay-actions">
        <button class="secondary-btn" data-close="keyOverlay">CANCEL</button>
        <button class="primary-btn" id="keySaveBtn">SAVE</button>
      </div>
    </div>
  </div>

  <div class="overlay" id="exportOverlay">
    <div class="overlay-card">
      <div class="overlay-title">EXPORT STATE</div>
      <div class="overlay-sub">Download full multi-channel session as JSON.</div>
      <div class="overlay-actions">
        <button class="secondary-btn" data-close="exportOverlay">CLOSE</button>
        <button class="primary-btn" id="confirmExport">EXPORT JSON</button>
      </div>
    </div>
  </div>

  <div class="overlay" id="cellOverlay">
    <div class="cell-overlay-content" id="cellOverlayContent">
      <button class="close-overlay" data-close="cellOverlay">×</button>
    </div>
  </div>

  <div class="overlay" id="snapshotOverlay">
    <div class="overlay-card">
      <div class="overlay-title">SNAPSHOTS</div>
      <div class="overlay-sub" id="snapshotStatus"></div>
      <div class="snapshot-overlay-list" id="snapshotOverlayList"></div>
      <div class="overlay-actions">
        <button class="secondary-btn" data-close="snapshotOverlay">CLOSE</button>
        <button class="primary-btn" id="snapshotCreateBtn">CREATE</button>
      </div>
    </div>
  </div>

  <div class="overlay" id="ringOverlay">
    <div class="overlay-card">
      <div class="overlay-title">RING MEMORY</div>
      <div class="overlay-sub" id="ringStatus"></div>
      <div class="ring-context-block">
        <div class="ring-context-controls">
          <button class="ring-context-btn" id="ringModeAll" data-mode="all">ALL STREAM</button>
          <button class="ring-context-btn" id="ringModeAnchor" data-mode="anchor">ANCHOR CHANNEL</button>
          <button class="ring-context-btn" id="ringModeMain" data-mode="mainline">MAINLINE</button>
        </div>
        <div class="ring-context-window" id="ringContextWindow"></div>
      </div>
      <div class="snapshot-overlay-list" id="ringEntries"></div>
      <div class="overlay-actions">
        <button class="secondary-btn" id="ringSetMainline">LOCK MAINLINE</button>
        <button class="secondary-btn" data-close="ringOverlay">CLOSE</button>
      </div>
    </div>
  </div>

  <div class="overlay" id="perspectiveOverlay">
    <div class="perspective-overlay-content" id="perspectiveOverlayContent">
      <button class="close-overlay" data-close="perspectiveOverlay">×</button>
    </div>
  </div>

  <input type="file" id="importInput" accept="application/json" hidden>

  <button class="corner-btn top-left" id="cornerKey" title="API Key">◎</button>
  <button class="corner-btn top-right" id="cornerHelp" title="Help">?</button>
  <button class="corner-btn bottom-left" id="cornerExchange" title="Import / Export">⇆</button>
  <button class="corner-btn bottom-right" id="cornerAdd" title="Add Channel">＋</button>

  <div class="corner-menu" id="infoMenu" style="top: calc(72px + env(safe-area-inset-top)); right: calc(16px + env(safe-area-inset-right));">
    <button data-action="help">HELP OVERVIEW</button>
    <button data-action="theme">TOGGLE THEME</button>
    <button data-action="fullscreen">FULLSCREEN MODE</button>
  </div>

  <div class="corner-menu" id="exchangeMenu" style="bottom: calc(72px + env(safe-area-inset-bottom)); left: calc(16px + env(safe-area-inset-left));">
    <button data-action="export">EXPORT SESSION</button>
    <button data-action="import">IMPORT SESSION</button>
  </div>

  <script>
    const blockPalette = [
      { type: 'Location', symbol: 'L' },
      { type: 'Entity', symbol: 'E' },
      { type: 'Goal', symbol: 'G' },
      { type: 'Obstacle', symbol: 'O' },
      { type: 'Shift', symbol: 'S' },
      { type: 'Solution', symbol: 'U' }
    ];

    // ═══════════════════════════════════════════════════════════════════
    // CULTURAL ENGINE CORE - Tripartite Probabilistic Dynamics
    // ═══════════════════════════════════════════════════════════════════
    
    // BDI (Belief-Desire-Intention) Framework - Bratman (1987), Rao & Georgeff (1995)
    class BDIAgent {
      constructor(position, culturalType, legosCellRef) {
        this.position = position;
        this.culturalType = culturalType;
        this.legosCellRef = legosCellRef;
        
        // Beliefs: Agent's informational state about world
        this.beliefs = {
          nearbyThreats: [],
          nearbyAllies: [],
          environmentalState: {},
          perceivedLegitimacy: 0.5,
          symbolicMeaning: legosCellRef?.entity?.symbolicRole || 'neutral'
        };
        
        // Desires: Agent's motivational state (goals)
        this.desires = new Set();
        this.updateDesires();
        
        // Intentions: Committed plans and actions
        this.intentions = [];
        this.currentIntention = null;
      }
      
      updateBeliefs(worldState) {
        // Update beliefs based on perception
        this.beliefs.nearbyThreats = this.perceiveThreats(worldState);
        this.beliefs.nearbyAllies = this.perceiveAllies(worldState);
        this.beliefs.perceivedLegitimacy = worldState.legitimacy || 0.5;
        
        // LEGOS narrative influences belief formation
        if (this.legosCellRef?.entity?.perspective) {
          const perspective = this.legosCellRef.entity.perspective.toLowerCase();
          if (perspective.match(/oppress|harsh|suffer/)) {
            this.beliefs.perceivedLegitimacy *= 0.7; // Oppression lowers legitimacy perception
          }
        }
      }
      
      updateDesires() {
        this.desires.clear();
        
        // Type-specific desire generation
        if (this.culturalType === 'citizen') {
          this.desires.add('survive');
          this.desires.add('avoid_harm');
          if (this.beliefs.perceivedLegitimacy < 0.3) {
            this.desires.add('seek_change');
          }
        } else if (this.culturalType === 'rebel') {
          this.desires.add('challenge_authority');
          this.desires.add('find_allies');
          this.desires.add('survive');
        } else if (this.culturalType === 'cop') {
          this.desires.add('maintain_order');
          this.desires.add('suppress_dissent');
        }
        
        // LEGOS symbolic role influences desires
        const role = this.beliefs.symbolicMeaning;
        if (role === 'chaos_agent') {
          this.desires.add('disrupt_order');
        } else if (role === 'mediator') {
          this.desires.add('reduce_conflict');
        } else if (role === 'oppressed') {
          this.desires.add('seek_justice');
        }
      }
      
      perceiveThreats(worldState) {
        const threats = [];
        const [x, y] = this.position;
        
        for (let dy = -1; dy <= 1; dy++) {
          for (let dx = -1; dx <= 1; dx++) {
            const nx = x + dx, ny = y + dy;
            if (nx >= 0 && nx < 9 && ny >= 0 && ny < 9) {
              const key = `${nx}_${ny}`;
              const agent = worldState.agents[key];
              if (agent && this.isThreat(agent)) {
                threats.push({ agent, distance: Math.abs(dx) + Math.abs(dy) });
              }
            }
          }
        }
        return threats;
      }
      
      perceiveAllies(worldState) {
        const allies = [];
        const [x, y] = this.position;
        
        for (let dy = -2; dy <= 2; dy++) {
          for (let dx = -2; dx <= 2; dx++) {
            const nx = x + dx, ny = y + dy;
            if (nx >= 0 && nx < 9 && ny >= 0 && ny < 9) {
              const key = `${nx}_${ny}`;
              const agent = worldState.agents[key];
              if (agent && this.isAlly(agent)) {
                allies.push({ agent, distance: Math.abs(dx) + Math.abs(dy) });
              }
            }
          }
        }
        return allies;
      }
      
      isThreat(otherAgent) {
        if (this.culturalType === 'citizen' && otherAgent.culturalType === 'cop') return true;
        if (this.culturalType === 'rebel' && otherAgent.culturalType === 'cop') return true;
        if (this.culturalType === 'cop' && otherAgent.culturalType === 'rebel') return true;
        return false;
      }
      
      isAlly(otherAgent) {
        return this.culturalType === otherAgent.culturalType;
      }
      
      formIntentions() {
        // Practical reasoning: desires → intentions
        this.intentions = [];
        
        if (this.desires.has('avoid_harm') && this.beliefs.nearbyThreats.length > 0) {
          this.intentions.push({ type: 'flee', priority: 10 });
        }
        
        if (this.desires.has('find_allies') && this.beliefs.nearbyAllies.length > 0) {
          this.intentions.push({ type: 'approach_ally', priority: 7 });
        }
        
        if (this.desires.has('challenge_authority') && this.beliefs.nearbyThreats.length > 0) {
          this.intentions.push({ type: 'confront', priority: 5 });
        }
        
        if (this.desires.has('maintain_order') && this.beliefs.nearbyThreats.length > 0) {
          this.intentions.push({ type: 'suppress', priority: 8 });
        }
        
        if (this.desires.has('disrupt_order')) {
          this.intentions.push({ type: 'move_randomly', priority: 6 });
        }
        
        if (this.desires.has('reduce_conflict')) {
          this.intentions.push({ type: 'mediate', priority: 4 });
        }
        
        // Sort by priority
        this.intentions.sort((a, b) => b.priority - a.priority);
        this.currentIntention = this.intentions[0] || null;
      }
      
      execute(worldState) {
        if (!this.currentIntention) return null;
        
        // Execute highest priority intention
        switch (this.currentIntention.type) {
          case 'flee':
            return this.executeFlee(worldState);
          case 'approach_ally':
            return this.executeApproachAlly(worldState);
          case 'suppress':
            return this.executeSuppress(worldState);
          case 'move_randomly':
            return this.executeMoveRandom(worldState);
          default:
            return null;
        }
      }
      
      executeFlee(worldState) {
        // Move away from threats
        const threat = this.beliefs.nearbyThreats[0];
        if (!threat) return null;
        
        const [x, y] = this.position;
        const [tx, ty] = threat.agent.position;
        const dx = x - tx, dy = y - ty;
        
        return {
          action: 'move',
          direction: { x: Math.sign(dx) || (Math.random() < 0.5 ? 1 : -1), 
                      y: Math.sign(dy) || (Math.random() < 0.5 ? 1 : -1) }
        };
      }
      
      executeApproachAlly(worldState) {
        const ally = this.beliefs.nearbyAllies[0];
        if (!ally) return null;
        
        const [x, y] = this.position;
        const [ax, ay] = ally.agent.position;
        const dx = ax - x, dy = ay - y;
        
        return {
          action: 'move',
          direction: { x: Math.sign(dx), y: Math.sign(dy) }
        };
      }
      
      executeSuppress(worldState) {
        return { action: 'suppress', target: this.beliefs.nearbyThreats[0] };
      }
      
      executeMoveRandom(worldState) {
        return {
          action: 'move',
          direction: { 
            x: Math.floor(Math.random() * 3) - 1, 
            y: Math.floor(Math.random() * 3) - 1 
          }
        };
      }
    }
    
    // Seed simulation parameters from prompt text (deterministic)
    function seedCulturalParams(promptText) {
      const hash = Array.from(promptText).reduce((acc, char) => {
        return ((acc << 5) - acc + char.charCodeAt(0)) | 0;
      }, 0);
      const rng = (seed) => {
        let x = Math.sin(seed++) * 10000;
        return x - Math.floor(x);
      };
      
      return {
        framework: 'epstein',  // Default to Epstein Civil Violence
        useBDI: false,         // BDI agent reasoning
        comparisonMode: false, // Barad's diffractive analysis
        comparisonSnapshot: null, // Stored state for comparison
        pragmatic: {
          legitimacy: 0.4 + rng(hash + 1) * 0.3,        // 0.4-0.7
          copEffectiveness: 0.3 + rng(hash + 2) * 0.3,  // 0.3-0.6
          fearDecay: 0.15 + rng(hash + 3) * 0.25,       // 0.15-0.4
          citizenRatio: 0.65 + rng(hash + 10) * 0.15,   // 0.65-0.8
          copRatio: 0.05 + rng(hash + 11) * 0.05        // 0.05-0.1
        },
        structural: {
          symbolicInertia: 0.5 + rng(hash + 4) * 0.4,
          mythicCoherence: 0.6 + rng(hash + 5) * 0.3,
          boundaryStrength: 0.4 + rng(hash + 6) * 0.4
        },
        reflexive: {
          observationWeight: 0.3 + rng(hash + 7) * 0.4,
          interpretationDepth: 2 + Math.floor(rng(hash + 8) * 3),
          mutualAdjustment: 0.2 + rng(hash + 9) * 0.5
        },
        seed: hash
      };
    }
    
    // Generate scene ontology from existing scene graph
    function generateSceneOntology(channel) {
      const ontology = {
        entities: [],
        locations: [],
        conflicts: [],
        resources: [],
        authorities: [],
        relationships: [],
        narrative: {
          tension: 0,
          progress: 0,
          caution: 0
        }
      };
      
      // Analyze existing scene if available
      if (channel.lastScene) {
        const scene = channel.lastScene;
        
        // Extract entities
        if (scene.entities) {
          scene.entities.forEach(entity => {
            const category = {
              'Entity': 'entities',
              'Location': 'locations',
              'Goal': 'resources',
              'Obstacle': 'authorities',
              'Shift': 'conflicts'
            }[entity.type] || 'entities';
            
            ontology[category].push({
              id: entity.id,
              name: entity.name,
              type: entity.type,
              position: scene.gridMapping?.find(g => g.id === entity.id)
            });
          });
        }
        
        // Extract relationships
        if (scene.entities) {
          scene.entities.forEach(entity => {
            if (entity.relations) {
              entity.relations.forEach(rel => {
                ontology.relationships.push({
                  source: entity.id,
                  target: rel.target,
                  type: rel.type
                });
              });
            }
          });
        }
        
        // Extract narrative state
        if (scene.scorecard) {
          ontology.narrative.progress = scene.scorecard.progress || 0;
          ontology.narrative.caution = scene.scorecard.caution || 0;
        }
        if (scene.tension) {
          ontology.narrative.tension = scene.tension;
        }
      }
      
      // Calculate ontology-based parameters
      const totalEntities = ontology.entities.length + ontology.locations.length + 
                           ontology.resources.length + ontology.authorities.length;
      const conflictRatio = ontology.conflicts.length / Math.max(1, totalEntities);
      const authorityRatio = ontology.authorities.length / Math.max(1, totalEntities);
      const resourceRatio = ontology.resources.length / Math.max(1, totalEntities);
      
      ontology.derivedParams = {
        legitimacy: 0.7 - (conflictRatio * 0.4) - (ontology.narrative.tension * 0.3),
        copEffectiveness: 0.3 + (authorityRatio * 0.4),
        initialHardship: 0.3 + (ontology.narrative.caution * 0.5),
        contestedResources: resourceRatio > 0.15
      };
      
      console.log('[ONTOLOGY] Generated scene ontology:', ontology);
      return ontology;
    }
    
    // ═══════════════════════════════════════════════════════════════════
    // DIFFRACTIVE METHODOLOGY - Barad's Agential Realism
    // ═══════════════════════════════════════════════════════════════════
    
    // Capture simulation state for diffractive analysis
    function captureSimulationSnapshot(channel) {
      const agents = channel.culturalAgents;
      const params = channel.culturalParams;
      
      // Agent distribution
      const distribution = {
        citizens: Object.values(agents).filter(a => a.type === 'citizen').length,
        rebels: Object.values(agents).filter(a => a.type === 'rebel').length,
        cops: Object.values(agents).filter(a => a.type === 'cop').length
      };
      
      // Spatial patterns (clustering coefficient)
      const spatialPatterns = calculateSpatialPatterns(agents);
      
      // Symbolic role distribution
      const roleDistribution = {};
      Object.values(agents).forEach(agent => {
        const role = agent.legosCellRef?.entity?.symbolicRole || 'unknown';
        roleDistribution[role] = (roleDistribution[role] || 0) + 1;
      });
      
      // Average states
      const avgFear = Object.values(agents).reduce((sum, a) => sum + a.fear, 0) / Math.max(1, Object.keys(agents).length);
      const avgEnergy = Object.values(agents).reduce((sum, a) => sum + a.energy, 0) / Math.max(1, Object.keys(agents).length);
      
      return {
        tick: channel.culturalTick,
        framework: params.framework,
        useBDI: params.useBDI,
        distribution,
        spatialPatterns,
        roleDistribution,
        legitimacy: params.pragmatic.legitimacy,
        copEffectiveness: params.pragmatic.copEffectiveness,
        avgFear,
        avgEnergy,
        timestamp: Date.now()
      };
    }
    
    // Calculate spatial clustering patterns
    function calculateSpatialPatterns(agents) {
      let rebelClusters = 0;
      let copClusters = 0;
      let segregationIndex = 0;
      
      Object.entries(agents).forEach(([key, agent]) => {
        const [x, y] = key.split('_').map(Number);
        let sameTypeNeighbors = 0;
        let totalNeighbors = 0;
        
        for (let dy = -1; dy <= 1; dy++) {
          for (let dx = -1; dx <= 1; dx++) {
            if (dx === 0 && dy === 0) continue;
            const nx = x + dx, ny = y + dy;
            if (nx >= 0 && nx < 9 && ny >= 0 && ny < 9) {
              const nkey = `${nx}_${ny}`;
              const neighbor = agents[nkey];
              if (neighbor) {
                totalNeighbors++;
                if (neighbor.type === agent.type) {
                  sameTypeNeighbors++;
                }
              }
            }
          }
        }
        
        if (totalNeighbors > 0) {
          const homophily = sameTypeNeighbors / totalNeighbors;
          segregationIndex += homophily;
          
          if (agent.type === 'rebel' && sameTypeNeighbors >= 2) rebelClusters++;
          if (agent.type === 'cop' && sameTypeNeighbors >= 2) copClusters++;
        }
      });
      
      return {
        segregationIndex: segregationIndex / Math.max(1, Object.keys(agents).length),
        rebelClusters,
        copClusters
      };
    }
    
    // Diffractive analysis: Compare two snapshots to reveal patterns of difference
    function diffractiveAnalysis(snapshot1, snapshot2) {
      console.group('🔬 [DIFFRACTIVE ANALYSIS] Barad\'s Agential Cuts');
      
      console.log('Comparing two entangled configurations:');
      console.log(`  Configuration A: ${snapshot1.framework} (${snapshot1.useBDI ? 'BDI' : 'Standard'}) @ Tick ${snapshot1.tick}`);
      console.log(`  Configuration B: ${snapshot2.framework} (${snapshot2.useBDI ? 'BDI' : 'Standard'}) @ Tick ${snapshot2.tick}`);
      
      // Population dynamics difference
      const popDiff = {
        citizens: snapshot2.distribution.citizens - snapshot1.distribution.citizens,
        rebels: snapshot2.distribution.rebels - snapshot1.distribution.rebels,
        cops: snapshot2.distribution.cops - snapshot1.distribution.cops
      };
      
      console.log('\n📊 Population Interference Pattern:');
      console.log(`  Citizens: ${popDiff.citizens > 0 ? '+' : ''}${popDiff.citizens}`);
      console.log(`  Rebels: ${popDiff.rebels > 0 ? '+' : ''}${popDiff.rebels}`);
      console.log(`  Cops: ${popDiff.cops > 0 ? '+' : ''}${popDiff.cops}`);
      
      // Spatial pattern divergence
      const spatialDiff = {
        segregation: snapshot2.spatialPatterns.segregationIndex - snapshot1.spatialPatterns.segregationIndex,
        rebelClusters: snapshot2.spatialPatterns.rebelClusters - snapshot1.spatialPatterns.rebelClusters,
        copClusters: snapshot2.spatialPatterns.copClusters - snapshot1.spatialPatterns.copClusters
      };
      
      console.log('\n🗺️ Spatial Entanglement Difference:');
      console.log(`  Segregation Index: ${spatialDiff.segregation > 0 ? '+' : ''}${spatialDiff.segregation.toFixed(3)}`);
      console.log(`  Rebel Clustering: ${spatialDiff.rebelClusters > 0 ? '+' : ''}${spatialDiff.rebelClusters}`);
      console.log(`  Cop Clustering: ${spatialDiff.copClusters > 0 ? '+' : ''}${spatialDiff.copClusters}`);
      
      // Parameter divergence
      const paramDiff = {
        legitimacy: snapshot2.legitimacy - snapshot1.legitimacy,
        copEffectiveness: snapshot2.copEffectiveness - snapshot1.copEffectiveness,
        fear: snapshot2.avgFear - snapshot1.avgFear,
        energy: snapshot2.avgEnergy - snapshot1.avgEnergy
      };
      
      console.log('\n⚙️ Parameter Drift (Ongoing Becoming):');
      console.log(`  Legitimacy: ${paramDiff.legitimacy > 0 ? '+' : ''}${(paramDiff.legitimacy * 100).toFixed(1)}%`);
      console.log(`  Cop Effectiveness: ${paramDiff.copEffectiveness > 0 ? '+' : ''}${(paramDiff.copEffectiveness * 100).toFixed(1)}%`);
      console.log(`  Avg Fear: ${paramDiff.fear > 0 ? '+' : ''}${paramDiff.fear.toFixed(3)}`);
      console.log(`  Avg Energy: ${paramDiff.energy > 0 ? '+' : ''}${paramDiff.energy.toFixed(3)}`);
      
      // Symbolic role emergence difference
      console.log('\n🎭 Symbolic Role Reconfigurations:');
      const allRoles = new Set([
        ...Object.keys(snapshot1.roleDistribution),
        ...Object.keys(snapshot2.roleDistribution)
      ]);
      
      allRoles.forEach(role => {
        const count1 = snapshot1.roleDistribution[role] || 0;
        const count2 = snapshot2.roleDistribution[role] || 0;
        const diff = count2 - count1;
        if (diff !== 0) {
          console.log(`  ${role}: ${diff > 0 ? '+' : ''}${diff} agents`);
        }
      });
      
      // Diffractive insight
      console.log('\n💡 Diffractive Insight (Barad):');
      
      const rebellionPressure1 = snapshot1.distribution.rebels / Math.max(1, snapshot1.distribution.citizens);
      const rebellionPressure2 = snapshot2.distribution.rebels / Math.max(1, snapshot2.distribution.citizens);
      const rebellionDivergence = Math.abs(rebellionPressure2 - rebellionPressure1);
      
      if (rebellionDivergence > 0.2) {
        console.log(`  Strong interference in rebellion dynamics (${rebellionDivergence.toFixed(2)})`);
        console.log(`  → Different agential cuts produce divergent uprisings`);
      } else if (spatialDiff.segregation > 0.1) {
        console.log(`  Spatial patterns show constructive interference`);
        console.log(`  → Clustering emerges regardless of framework`);
      } else {
        console.log(`  Patterns show convergence despite different apparatuses`);
        console.log(`  → LEGOS mythology constrains possible becomings`);
      }
      
      console.log('\n📐 Material-Discursive Entanglement:');
      console.log(`  Framework choices are not neutral observations but active interventions`);
      console.log(`  Each simulation co-constitutes different cultural realities`);
      console.log(`  The modeler, model, and phenomena are inseparable`);
      
      console.groupEnd();
      
      return {
        popDiff,
        spatialDiff,
        paramDiff,
        rebellionDivergence,
        convergence: rebellionDivergence < 0.1 && Math.abs(spatialDiff.segregation) < 0.05
      };
    }
    
    // Analyze LEGOS entity to derive cultural meaning from narrative
    function analyzeLEGOSNarrative(entity) {
      if (!entity) return { culturalType: 'citizen', hardship: 0.5, riskAversion: 0.5, symbolicRole: 'neutral' };
      
      const perspective = (entity.perspective || '').toLowerCase();
      const name = (entity.name || '').toLowerCase();
      
      // Analyze perspective for cultural markers
      let culturalType = 'citizen';
      let hardship = 0.5;
      let riskAversion = 0.5;
      let symbolicRole = 'neutral';
      
      // Authority/enforcement markers
      if (perspective.match(/authority|enforce|control|command|guard|protect|patrol|law/)) {
        culturalType = 'cop';
        hardship = 0.2;
        riskAversion = 0.3;
        symbolicRole = 'enforcer';
      }
      // Resistance/freedom markers
      else if (perspective.match(/resist|rebel|fight|freedom|uprising|revolt|challenge|defy/)) {
        culturalType = 'rebel';
        hardship = 0.8;
        riskAversion = 0.3;
        symbolicRole = 'resistance';
      }
      // Oppression/hardship markers
      else if (perspective.match(/suffer|struggle|oppress|harsh|difficult|pain|burden|hardship/)) {
        culturalType = 'citizen';
        hardship = 0.8;
        riskAversion = 0.7;
        symbolicRole = 'oppressed';
      }
      // Power/elite markers
      else if (perspective.match(/power|elite|noble|king|ruler|sovereign|throne/)) {
        culturalType = 'cop';
        hardship = 0.1;
        riskAversion = 0.2;
        symbolicRole = 'elite';
      }
      // Storm/chaos as symbolic disruption
      else if (perspective.match(/storm|chaos|thunder|tempest|wild|fierce/) || name.match(/storm|thunder|tempest/)) {
        culturalType = 'rebel';
        hardship = 0.6;
        riskAversion = 0.4;
        symbolicRole = 'chaos_agent';
      }
      // Wisdom/mediation markers
      else if (perspective.match(/wise|mediat|peace|calm|balance|harmony/)) {
        culturalType = 'citizen';
        hardship = 0.3;
        riskAversion = 0.6;
        symbolicRole = 'mediator';
      }
      
      // Check relations for cultural context
      if (entity.relations && entity.relations.length > 0) {
        // High connectivity suggests collective actor
        if (entity.relations.length > 3) {
          riskAversion *= 0.8; // More connected = less risk-averse (social support)
        }
      }
      
      console.log(`[LEGOS NARRATIVE] ${entity.name}: culturalType=${culturalType}, symbolicRole=${symbolicRole}, perspective="${perspective.substring(0, 50)}..."`);
      
      return { culturalType, hardship, riskAversion, symbolicRole };
    }
    
    // Initialize agents on grid cells - CREATE PROPER LEGOS ENTITIES
    function initCulturalAgents(channel, density = 0.75) {
      const agents = {};
      const params = channel.culturalParams.pragmatic;
      let agentIdCounter = 1000; // Start IDs high to avoid conflicts
      
      // First pass: ENHANCE existing grid elements with cultural metadata (LEGOS-AWARE)
      for (let y = 0; y < 9; y++) {
        for (let x = 0; x < 9; x++) {
          const existingCell = channel.grid[y][x];
          if (existingCell) {
            const key = `${x}_${y}`;
            const cellType = existingCell.type || 'Entity';
            
            // ANALYZE LEGOS NARRATIVE to derive cultural meaning
            let culturalType, hardship, riskAversion, symbolicRole;
            
            if (existingCell.entity) {
              // Use narrative analysis
              const analysis = analyzeLEGOSNarrative(existingCell.entity);
              culturalType = analysis.culturalType;
              hardship = analysis.hardship;
              riskAversion = analysis.riskAversion;
              symbolicRole = analysis.symbolicRole;
            } else {
              // Fallback to type-based mapping
              if (cellType === 'Obstacle' || cellType === 'Shift') {
                culturalType = 'cop';
                hardship = 0.1;
                riskAversion = 0.3;
                symbolicRole = 'enforcer';
              } else if (cellType === 'Goal') {
                culturalType = 'rebel';
                hardship = 0.8;
                riskAversion = 0.4;
                symbolicRole = 'resistance';
              } else {
                culturalType = 'citizen';
                hardship = 0.3 + Math.random() * 0.5;
                riskAversion = 0.4 + Math.random() * 0.4;
                symbolicRole = 'neutral';
              }
            }
            
            // Enhance existing entity with cultural data (preserving LEGOS narrative)
            if (existingCell.entity && !existingCell.entity.culturalType) {
              existingCell.entity.culturalType = culturalType;
              existingCell.entity.symbolicRole = symbolicRole;
              existingCell.entity.culturalBeliefs = {
                utility: culturalType === 'cop' ? 0.8 : 0.5 + Math.random() * 0.3,
                symbolic: Math.random(),
                reflexive: Math.random()
              };
              existingCell.entity.culturalTraits = {
                hardship,
                riskAversion,
                social: Math.random()
              };
            }
            
            agents[key] = {
              type: culturalType,
              legosCellRef: existingCell,
              beliefs: existingCell.entity?.culturalBeliefs || {
                utility: culturalType === 'cop' ? 0.8 : 0.5 + Math.random() * 0.3,
                symbolic: Math.random(),
                reflexive: Math.random()
              },
              traits: existingCell.entity?.culturalTraits || {
                hardship,
                riskAversion,
                social: Math.random()
              },
              energy: 1.0,
              fear: culturalType === 'rebel' ? 0.7 : 0,
              perceivedRisk: 0,
              memory: []
            };
          }
        }
      }
      
      // Second pass: CREATE NEW LEGOS ENTITIES in empty cells
      const emptyIndices = [];
      for (let y = 0; y < 9; y++) {
        for (let x = 0; x < 9; x++) {
          if (!channel.grid[y][x]) {
            emptyIndices.push({ x, y });
          }
        }
      }
      
      // Fisher-Yates shuffle
      for (let i = emptyIndices.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [emptyIndices[i], emptyIndices[j]] = [emptyIndices[j], emptyIndices[i]];
      }
      
      const existingCount = Object.keys(agents).length;
      const targetTotal = Math.floor(81 * density);
      const toAdd = Math.max(0, targetTotal - existingCount);
      
      const citizenCount = Math.floor(toAdd * (params.citizenRatio || 0.72));
      const copCount = Math.floor(toAdd * (params.copRatio || 0.06));
      
      let added = 0;
      
      // CREATE CITIZENS as proper LEGOS entities
      for (let i = 0; i < citizenCount && added < toAdd && added < emptyIndices.length; i++, added++) {
        const { x, y } = emptyIndices[added];
        const key = `${x}_${y}`;
        const id = `cultural-citizen-${agentIdCounter++}`;
        const hardship = Math.random();
        const riskAversion = Math.random();
        
        // CREATE FULL LEGOS ENTITY
        const entity = {
          id,
          name: `Citizen ${agentIdCounter - 1000}`,
          type: 'Entity',
          culturalType: 'citizen',
          culturalBeliefs: {
            utility: 0.5 + Math.random() * 0.3,
            symbolic: Math.random(),
            reflexive: Math.random()
          },
          culturalTraits: {
            hardship,
            riskAversion,
            social: Math.random()
          },
          perspective: `A citizen with hardship ${(hardship * 100).toFixed(0)}% and risk aversion ${(riskAversion * 100).toFixed(0)}%. Part of the cultural simulation.`
        };
        
        // WRITE TO CHANNEL.GRID (LEGOS CORE)
        channel.grid[y][x] = {
          id,
          type: 'Entity',
          symbol: '○',
          label: entity.name,
          entity
        };
        
        logCellEvent(channel, x, y, `Cultural citizen spawned`);
        
        agents[key] = {
          type: 'citizen',
          legosCellRef: channel.grid[y][x],
          beliefs: entity.culturalBeliefs,
          traits: entity.culturalTraits,
          energy: 1.0,
          fear: 0,
          perceivedRisk: 0,
          memory: []
        };
      }
      
      // CREATE COPS as proper LEGOS entities
      for (let i = 0; i < copCount && added < toAdd && added < emptyIndices.length; i++, added++) {
        const { x, y } = emptyIndices[added];
        const key = `${x}_${y}`;
        const id = `cultural-cop-${agentIdCounter++}`;
        
        const entity = {
          id,
          name: `Cop ${agentIdCounter - 1000}`,
          type: 'Obstacle',
          culturalType: 'cop',
          culturalBeliefs: {
            utility: 0.8,
            symbolic: Math.random(),
            reflexive: Math.random()
          },
          culturalTraits: {
            hardship: 0.1,
            riskAversion: 0.3,
            social: 0.6
          },
          perspective: `An authority agent enforcing order. High utility (80%), low hardship. Part of the cultural simulation.`
        };
        
        channel.grid[y][x] = {
          id,
          type: 'Obstacle',
          symbol: '◆',
          label: entity.name,
          entity
        };
        
        logCellEvent(channel, x, y, `Cultural cop spawned`);
        
        agents[key] = {
          type: 'cop',
          legosCellRef: channel.grid[y][x],
          beliefs: entity.culturalBeliefs,
          traits: entity.culturalTraits,
          energy: 1.0,
          fear: 0,
          perceivedRisk: 0,
          memory: []
        };
      }
      
      // Log the mythology seed analysis
      const roleDistribution = {};
      Object.values(agents).forEach(agent => {
        const role = agent.legosCellRef?.entity?.symbolicRole || 'unknown';
        roleDistribution[role] = (roleDistribution[role] || 0) + 1;
      });
      
      console.log(`[LEGOS CULTURAL] Created ${Object.keys(agents).length} agents`);
      console.log(`[MYTHOLOGY SEED] Symbolic roles derived from LEGOS narratives:`, roleDistribution);
      console.log(`[MYTHOLOGY SEED] This scene's cultural dynamics emerge from LEGOS perspectives and relations`);
      
      channel.culturalAgents = agents;
    }
    
    // Pragmatic Layer: Action → Meaning (Civil Unrest Model)
    function updatePragmaticLayer(channel) {
      const params = channel.culturalParams.pragmatic;
      const agents = channel.culturalAgents;
      const framework = channel.culturalParams.framework || 'epstein';
      const useBDI = channel.culturalParams.useBDI;
      
      // Framework audit logging
      if (channel.culturalTick % 10 === 0) {
        console.log(`[FRAMEWORK] Active: ${framework}, BDI: ${useBDI}, Tick: ${channel.culturalTick}`);
      }
      
      // BDI REASONING PHASE (if enabled)
      if (useBDI) {
        console.group(`[BDI] Reasoning Cycle - Tick ${channel.culturalTick}`);
        
        const worldState = {
          agents,
          legitimacy: params.legitimacy,
          grid: channel.grid
        };
        
        let bdiActionCount = 0;
        Object.entries(agents).forEach(([key, agent]) => {
          if (agent.bdiAgent) {
            // Update beliefs from environment
            agent.bdiAgent.updateBeliefs(worldState);
            
            // Generate desires based on new beliefs
            agent.bdiAgent.updateDesires();
            
            // Form intentions from desires
            agent.bdiAgent.formIntentions();
            
            // Log first 3 agents for audit
            if (bdiActionCount < 3) {
              const entity = agent.legosCellRef?.entity;
              console.log(`[BDI] ${entity?.name || key}:`, {
                type: agent.type,
                symbolicRole: agent.bdiAgent.beliefs.symbolicMeaning,
                beliefs: {
                  threats: agent.bdiAgent.beliefs.nearbyThreats.length,
                  allies: agent.bdiAgent.beliefs.nearbyAllies.length,
                  legitimacy: agent.bdiAgent.beliefs.perceivedLegitimacy.toFixed(2)
                },
                desires: Array.from(agent.bdiAgent.desires),
                intention: agent.bdiAgent.currentIntention
              });
              bdiActionCount++;
            }
            
            // Execute intention (store for movement phase)
            const action = agent.bdiAgent.execute(worldState);
            if (action) {
              agent.bdiAction = action;
            }
          }
        });
        
        console.groupEnd();
      }
      
      // Framework-specific metrics logging (every 10 ticks)
      if (channel.culturalTick % 10 === 0) {
        const citizens = Object.values(agents).filter(a => a.type === 'citizen').length;
        const rebels = Object.values(agents).filter(a => a.type === 'rebel').length;
        const cops = Object.values(agents).filter(a => a.type === 'cop').length;
        
        console.group(`[${framework.toUpperCase()}] Metrics - Tick ${channel.culturalTick}`);
        console.log('Population:', { citizens, rebels, cops });
        console.log('Legitimacy:', (params.legitimacy * 100).toFixed(1) + '%');
        console.log('Cop Effectiveness:', (params.copEffectiveness * 100).toFixed(1) + '%');
        
        // Framework-specific metrics
        if (framework === 'epstein') {
          const avgGrievance = Object.values(agents)
            .filter(a => a.type === 'citizen')
            .reduce((sum, a) => sum + (a.traits.hardship * (1 - params.legitimacy)), 0) / Math.max(1, citizens);
          console.log('Avg Citizen Grievance:', avgGrievance.toFixed(2));
        }
        
        if (framework === 'iruba') {
          const avgFear = Object.values(agents).reduce((sum, a) => sum + a.fear, 0) / Math.max(1, Object.keys(agents).length);
          const avgAnger = Object.values(agents)
            .filter(a => a.anger !== undefined)
            .reduce((sum, a) => sum + a.anger, 0) / Math.max(1, Object.keys(agents).length);
          console.log('Avg Fear:', avgFear.toFixed(2));
          console.log('Avg Anger:', avgAnger.toFixed(2));
        }
        
        if (framework === 'rebeland') {
          const networkDensity = Object.values(agents)
            .filter(a => a.legosCellRef?.entity?.relations)
            .reduce((sum, a) => sum + (a.legosCellRef.entity.relations?.length || 0), 0) / Math.max(1, Object.keys(agents).length);
          console.log('Network Density:', networkDensity.toFixed(2), 'relations/agent');
        }
        
        console.groupEnd();
      }
      
      // Calculate effective legitimacy (modulated by structural layer if active)
      let legitimacy = params.legitimacy || 0.55;
      if (channel.culturalParams.structural) {
        // Structural layer coherence affects legitimacy
        const avgSymbolic = Object.values(agents)
          .filter(a => a.beliefs.symbolic !== undefined)
          .reduce((sum, a) => sum + a.beliefs.symbolic, 0) / Math.max(1, Object.keys(agents).length);
        legitimacy += (avgSymbolic - 0.5) * 0.3; // ±15% swing
        legitimacy = Math.max(0, Math.min(1, legitimacy));
      }
      
      // Calculate risk perception adjustment from reflexive layer
      let riskAdjustment = 1.0;
      if (channel.culturalParams.reflexive) {
        const avgReflexive = Object.values(agents)
          .filter(a => a.beliefs.reflexive !== undefined)
          .reduce((sum, a) => sum + a.beliefs.reflexive, 0) / Math.max(1, Object.keys(agents).length);
        riskAdjustment = 0.5 + avgReflexive; // 0.5x to 1.5x risk perception
      }
      
      // Phase 1: Calculate risk for each agent
      Object.entries(agents).forEach(([key, agent]) => {
        const [x, y] = key.split('_').map(Number);
        let cops = 0, rebels = 0;
        
        // Count neighbors in radius
        const radius = 2;
        for (let dy = -radius; dy <= radius; dy++) {
          for (let dx = -radius; dx <= radius; dx++) {
            if (dx === 0 && dy === 0) continue;
            const nx = x + dx, ny = y + dy;
            if (nx >= 0 && nx < 9 && ny >= 0 && ny < 9) {
              const nkey = `${nx}_${ny}`;
              const neighbor = agents[nkey];
              if (neighbor) {
                if (neighbor.type === 'cop') cops++;
                if (neighbor.type === 'rebel') rebels++;
              }
            }
          }
        }
        
        // Risk calculation: cops suppress rebels
        const copEffectiveness = params.copEffectiveness || 0.45;
        const baseRisk = copEffectiveness * (cops / (rebels + 1));
        agent.perceivedRisk = Math.max(0.05, Math.min(1, baseRisk)) * riskAdjustment;
        
        // Store for transitions
        if (!agent.transitions) agent.transitions = {};
      });
      
      // Phase 2: Decision making
      const toRebel = [];
      const toCitizen = [];
      let arrestCount = 0;
      
      Object.entries(agents).forEach(([key, agent]) => {
        if (agent.type === 'citizen') {
          // Grievance model: hardship × (1 - legitimacy)
          const grievance = agent.traits.hardship * (1 - legitimacy);
          const riskThreshold = agent.traits.riskAversion * agent.perceivedRisk;
          
          if (grievance > riskThreshold) {
            toRebel.push(key);
          }
        } else if (agent.type === 'rebel') {
          // Fear dynamics
          const fearDecay = params.fearDecay || 0.25;
          agent.fear = Math.max(0, Math.min(1, 
            agent.fear + agent.perceivedRisk * 0.25 - fearDecay
          ));
          
          const grievance = agent.traits.hardship * (1 - legitimacy);
          const stayPressure = grievance + (1 - agent.fear) * 0.4;
          const crackdown = agent.traits.riskAversion * (agent.perceivedRisk + agent.fear * 0.6);
          
          if (stayPressure < crackdown) {
            toCitizen.push({ key, voluntary: true });
          }
        } else if (agent.type === 'cop') {
          // Cops arrest adjacent rebels
          const [x, y] = key.split('_').map(Number);
          for (let dy = -1; dy <= 1; dy++) {
            for (let dx = -1; dx <= 1; dx++) {
              if (dx === 0 && dy === 0) continue;
              const nx = x + dx, ny = y + dy;
              if (nx >= 0 && nx < 9 && ny >= 0 && ny < 9) {
                const nkey = `${nx}_${ny}`;
                const neighbor = agents[nkey];
                if (neighbor && neighbor.type === 'rebel') {
                  const arrestChance = (params.copEffectiveness || 0.45) * 0.85;
                  if (Math.random() < arrestChance) {
                    toCitizen.push({ key: nkey, voluntary: false });
                    arrestCount++;
                  } else {
                    neighbor.fear = Math.min(1, neighbor.fear + 0.3);
                  }
                }
              }
            }
          }
        }
      });
      
      // Phase 3: Apply transitions - UPDATE LEGOS ENTITIES
      toRebel.forEach(key => {
        const agent = agents[key];
        agent.type = 'rebel';
        agent.fear = 0.8;
        agent.beliefs.utility = 0.3;
        
        // UPDATE LEGOS ENTITY
        if (agent.legosCellRef && agent.legosCellRef.entity) {
          agent.legosCellRef.entity.culturalType = 'rebel';
          agent.legosCellRef.entity.culturalBeliefs = agent.beliefs;
          agent.legosCellRef.type = 'Goal'; // Goals are contested
          agent.legosCellRef.symbol = '▲';
          
          const [x, y] = key.split('_').map(Number);
          logCellEvent(channel, x, y, `Citizen became Rebel (grievance > risk)`);
        }
      });
      
      toCitizen.forEach(({ key, voluntary }) => {
        const agent = agents[key];
        agent.type = 'citizen';
        agent.traits.hardship = Math.random();
        agent.traits.riskAversion = Math.random();
        agent.fear = voluntary ? Math.min(1, agent.fear + 0.2) : 1.0;
        agent.beliefs.utility = voluntary ? 0.4 : 0.2;
        
        // UPDATE LEGOS ENTITY
        if (agent.legosCellRef && agent.legosCellRef.entity) {
          agent.legosCellRef.entity.culturalType = 'citizen';
          agent.legosCellRef.entity.culturalBeliefs = agent.beliefs;
          agent.legosCellRef.entity.culturalTraits = agent.traits;
          agent.legosCellRef.type = 'Entity';
          agent.legosCellRef.symbol = '○';
          
          const [x, y] = key.split('_').map(Number);
          logCellEvent(channel, x, y, voluntary ? `Rebel surrendered (fear)` : `Rebel arrested by cop`);
        }
      });
      
      // Energy dynamics
      Object.values(agents).forEach(agent => {
        if (agent.type === 'rebel') {
          agent.energy -= 0.05; // Rebellion is costly
        } else if (agent.type === 'cop') {
          agent.energy -= 0.02; // Policing is work
        } else {
          agent.energy = Math.min(1, agent.energy + 0.01); // Citizens recover
        }
      });
      
      // Phase 4: MOVEMENT - agents move based on cultural forces
      const movements = []; // Track movement intentions
      
      Object.entries(agents).forEach(([key, agent]) => {
        const [x, y] = key.split('_').map(Number);
        let targetX = x, targetY = y;
        let moveReason = '';
        
        // Movement rules based on type and state
        if (agent.type === 'citizen' && agent.fear > 0.6) {
          // High fear citizens flee from cops
          let copX = -1, copY = -1;
          for (let dy = -2; dy <= 2; dy++) {
            for (let dx = -2; dx <= 2; dx++) {
              const nx = x + dx, ny = y + dy;
              if (nx >= 0 && nx < 9 && ny >= 0 && ny < 9) {
                const nkey = `${nx}_${ny}`;
                if (agents[nkey]?.type === 'cop') {
                  copX = nx; copY = ny;
                  break;
                }
              }
            }
            if (copX >= 0) break;
          }
          
          if (copX >= 0) {
            // Move away from cop
            const fleeX = x + Math.sign(x - copX);
            const fleeY = y + Math.sign(y - copY);
            if (fleeX >= 0 && fleeX < 9 && fleeY >= 0 && fleeY < 9) {
              targetX = fleeX;
              targetY = fleeY;
              moveReason = 'fleeing cop';
            }
          }
        } else if (agent.type === 'rebel' && agent.fear < 0.4) {
          // Bold rebels move toward other rebels (solidarity)
          let nearestRebelDist = 999;
          let nearestRebelX = -1, nearestRebelY = -1;
          
          Object.entries(agents).forEach(([nkey, nagent]) => {
            if (nagent.type === 'rebel' && nkey !== key) {
              const [nx, ny] = nkey.split('_').map(Number);
              const dist = Math.abs(nx - x) + Math.abs(ny - y);
              if (dist < nearestRebelDist) {
                nearestRebelDist = dist;
                nearestRebelX = nx;
                nearestRebelY = ny;
              }
            }
          });
          
          if (nearestRebelX >= 0 && nearestRebelDist > 1) {
            // Move toward nearest rebel
            const moveX = x + Math.sign(nearestRebelX - x);
            const moveY = y + Math.sign(nearestRebelY - y);
            if (moveX >= 0 && moveX < 9 && moveY >= 0 && moveY < 9) {
              targetX = moveX;
              targetY = moveY;
              moveReason = 'joining rebels';
            }
          }
        } else if (agent.type === 'cop') {
          // Cops move toward nearest rebel
          let nearestRebelDist = 999;
          let nearestRebelX = -1, nearestRebelY = -1;
          
          Object.entries(agents).forEach(([nkey, nagent]) => {
            if (nagent.type === 'rebel') {
              const [nx, ny] = nkey.split('_').map(Number);
              const dist = Math.abs(nx - x) + Math.abs(ny - y);
              if (dist < nearestRebelDist) {
                nearestRebelDist = dist;
                nearestRebelX = nx;
                nearestRebelY = ny;
              }
            }
          });
          
          if (nearestRebelX >= 0 && nearestRebelDist > 1) {
            const moveX = x + Math.sign(nearestRebelX - x);
            const moveY = y + Math.sign(nearestRebelY - y);
            if (moveX >= 0 && moveX < 9 && moveY >= 0 && moveY < 9) {
              targetX = moveX;
              targetY = moveY;
              moveReason = 'pursuing rebel';
            }
          }
        }
        
        if (targetX !== x || targetY !== y) {
          movements.push({ from: key, toX: targetX, toY: targetY, agent, reason: moveReason });
        }
      });
      
      // Apply movements (non-conflicting only)
      const occupied = new Set(Object.keys(agents));
      let movedCount = 0;
      
      movements.forEach(({ from, toX, toY, agent, reason }) => {
        const toKey = `${toX}_${toY}`;
        
        // Only move if target is empty or can swap
        if (!occupied.has(toKey) || Math.random() < 0.3) {
          const [fromX, fromY] = from.split('_').map(Number);
          
          // Update LEGOS grid
          const temp = channel.grid[fromY][fromX];
          if (!channel.grid[toY][toX]) {
            channel.grid[toY][toX] = temp;
            channel.grid[fromY][fromX] = null;
            
            // Update agent registry
            delete agents[from];
            agents[toKey] = agent;
            agent.legosCellRef = channel.grid[toY][toX];
            
            logCellEvent(channel, toX, toY, `Agent moved here (${reason})`);
            logCellEvent(channel, fromX, fromY, `Agent left (${reason})`);
            
            occupied.delete(from);
            occupied.add(toKey);
            movedCount++;
          }
        }
      });
      
      if (movedCount > 0) {
        console.log(`[MOVEMENT] ${movedCount}/${movements.length} agents moved this tick`);
      }
      
      // Store metrics for cross-layer effects
      if (!channel.culturalMetrics) channel.culturalMetrics = {};
      channel.culturalMetrics.rebellionRate = toRebel.length / Math.max(1, Object.keys(agents).length);
      channel.culturalMetrics.arrestRate = arrestCount / Math.max(1, Object.keys(agents).length);
      channel.culturalMetrics.legitimacy = legitimacy;
      channel.culturalMetrics.movementCount = movements.length;
    }
    
    // Structural Layer: Meaning → Action (Sahlins/MacOS)
    function updateStructuralLayer(channel) {
      const params = channel.culturalParams.structural;
      const agents = channel.culturalAgents;
      
      // Get pragmatic metrics for cross-layer effects
      const metrics = channel.culturalMetrics || {};
      const rebellionShock = metrics.rebellionRate || 0;
      
      Object.entries(agents).forEach(([key, agent]) => {
        // All agents maintain symbolic beliefs, but some specialize
        const isSpecialized = agent.type === 'ritual' || agent.type === 'interpreter';
        
        // Symbolic coherence maintenance
        const symbolicTarget = agent.memory.length > 0 
          ? agent.memory[agent.memory.length - 1].symbolic 
          : agent.beliefs.symbolic;
        
        // Pull toward mythic coherence
        const delta = (symbolicTarget - agent.beliefs.symbolic) * (1 - params.symbolicInertia);
        agent.beliefs.symbolic += delta * 0.1;
        
        // Boundary enforcement (stronger during rebellion)
        const boundaryPressure = params.boundaryStrength * (1 + rebellionShock * 2);
        if (Math.abs(agent.beliefs.symbolic - 0.5) > boundaryPressure) {
          agent.beliefs.symbolic *= 0.95; // Pull back toward center
        }
        
        // Rebellion disrupts symbolic order
        if (rebellionShock > 0.1) {
          agent.beliefs.symbolic += (Math.random() - 0.5) * rebellionShock * 0.3;
        }
        
        // Clamp beliefs
        agent.beliefs.symbolic = Math.max(0, Math.min(1, agent.beliefs.symbolic));
        
        // Energy cost for maintaining structure
        const energyCost = isSpecialized ? 0.01 * params.mythicCoherence : 0.005;
        agent.energy -= energyCost;
      });
    }
    
    // Reflexive Layer: Observation → Execution (Geertz/Linux)
    function updateReflexiveLayer(channel) {
      const params = channel.culturalParams.reflexive;
      const agents = channel.culturalAgents;
      
      // Get pragmatic metrics for cross-layer effects
      const metrics = channel.culturalMetrics || {};
      const arrestIntensity = (metrics.arrestRate || 0) * 10; // Scale up
      
      // Build observation field - agents observe neighbors
      const observations = {};
      Object.entries(agents).forEach(([key, agent]) => {
        const [x, y] = key.split('_').map(Number);
        const neighbors = [];
        
        // Check 8 neighbors (expand radius during crackdowns)
        const radius = arrestIntensity > 0.5 ? 2 : 1;
        for (let dy = -radius; dy <= radius; dy++) {
          for (let dx = -radius; dx <= radius; dx++) {
            if (dx === 0 && dy === 0) continue;
            const nx = x + dx, ny = y + dy;
            if (nx >= 0 && nx < 9 && ny >= 0 && ny < 9) {
              const nkey = `${nx}_${ny}`;
              if (agents[nkey]) neighbors.push(agents[nkey]);
            }
          }
        }
        
        observations[key] = neighbors;
      });
      
      // Update based on mutual observation
      Object.entries(agents).forEach(([key, agent]) => {
        const neighbors = observations[key] || [];
        if (neighbors.length === 0) return;
        
        // Calculate average neighbor reflexivity
        const avgReflexive = neighbors.reduce((sum, n) => sum + n.beliefs.reflexive, 0) / neighbors.length;
        
        // Arrests amplify observation intensity
        const observationMultiplier = 1 + arrestIntensity;
        const delta = (avgReflexive - agent.beliefs.reflexive) * 
                      params.observationWeight * 
                      params.mutualAdjustment * 
                      observationMultiplier;
        agent.beliefs.reflexive += delta;
        
        // Recursive interpretation (depth layers)
        if (params.interpretationDepth > 1) {
          const secondOrderDelta = delta * 0.5;
          agent.beliefs.reflexive += secondOrderDelta;
        }
        
        // Clamp beliefs
        agent.beliefs.reflexive = Math.max(0, Math.min(1, agent.beliefs.reflexive));
        
        // Store observation in memory
        agent.memory.push({
          tick: channel.culturalTick,
          reflexive: agent.beliefs.reflexive,
          neighbors: neighbors.length,
          arrestContext: arrestIntensity
        });
        
        // Keep memory bounded
        if (agent.memory.length > 10) agent.memory.shift();
        
        // Energy gain from shared understanding (reduced during crackdowns)
        const understandingBonus = 0.01 * params.mutualAdjustment * neighbors.length / 8;
        agent.energy += understandingBonus * (1 - arrestIntensity * 0.5);
      });
    }
    
    // Render cultural state to grid (ENHANCES LEGOS CELLS)
    function renderCulturalGrid(channel) {
      if (!channel.culturalAnimating) return;
      
      const wrapper = channel.gridWrapper;
      if (!wrapper) return;
      
      // Add visual enhancement layer
      const gridElement = wrapper.querySelector('.channel-grid');
      if (!gridElement) return;
      
      // Add framework indicator label
      let indicator = wrapper.querySelector('.framework-indicator');
      if (!indicator) {
        indicator = document.createElement('div');
        indicator.className = 'framework-indicator';
        indicator.style.cssText = `
          position: absolute;
          top: 4px;
          right: 4px;
          background: rgba(100, 50, 200, 0.85);
          color: white;
          padding: 4px 8px;
          border-radius: 4px;
          font-size: 11px;
          font-weight: bold;
          z-index: 1000;
          pointer-events: none;
          box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        `;
        wrapper.style.position = 'relative';
        wrapper.appendChild(indicator);
      }
      
      const fw = channel.culturalParams?.framework || 'epstein';
      const useBDI = channel.culturalParams?.useBDI;
      const frameworkLabels = {
        'epstein': '⚡ EPSTEIN',
        'bdi': '🧠 BDI',
        'rebeland': '🏛️ REBELAND',
        'iruba': '⚔️ IRUBA',
        'ccim': '🌍 CCIM',
        'axelrod': '🎭 AXELROD',
        'schelling': '🏘️ SCHELLING'
      };
      
      indicator.textContent = frameworkLabels[fw] || fw.toUpperCase();
      if (useBDI && fw !== 'bdi') {
        indicator.textContent += ' + BDI';
      }
      
      const gridCells = channel.dom.gridEl.querySelectorAll('.grid-cell');
      const mode = channel.culturalMode;
      const agents = channel.culturalAgents;
      
      gridCells.forEach((cell, idx) => {
        const x = idx % 9;
        const y = Math.floor(idx / 9);
        const key = `${x}_${y}`;
        const agent = agents[key];
        const legosCell = channel.grid[y][x];
        
        // Get or create cultural overlay element
        let overlay = cell.querySelector('.cultural-overlay');
        
        if (agent && legosCell) {
          if (!overlay) {
            overlay = document.createElement('div');
            overlay.className = 'cultural-overlay';
            overlay.style.cssText = `
              position: absolute;
              inset: 0;
              display: flex;
              align-items: center;
              justify-content: center;
              font-size: 20px;
              pointer-events: none;
              z-index: 5;
            `;
            cell.appendChild(overlay);
          }
          
          // Mode-specific rendering based on cultural type
          let beliefValue = 0.5; // Default value
          let color = 'hsl(180, 50%, 50%)'; // Default color
          const culturalType = legosCell.entity?.culturalType || agent.type;
          
          if (mode === 'pragmatic') {
            // Civil unrest visualization
            if (culturalType === 'citizen') {
              beliefValue = agent.traits?.hardship || 0.5;
              color = `hsl(${180 - beliefValue * 60}, 60%, 55%)`; // Cyan to Green
            } else if (culturalType === 'cop') {
              beliefValue = 0.8;
              color = `hsl(220, 70%, 55%)`; // Blue
            } else if (culturalType === 'rebel') {
              beliefValue = 1 - (agent.fear || 0);
              color = `hsl(${10 - beliefValue * 10}, 80%, ${40 + beliefValue * 20}%)`; // Red spectrum
            } else {
              beliefValue = agent.beliefs?.utility || 0.5;
              color = `hsl(${beliefValue * 120}, 70%, 50%)`;
            }
          } else if (mode === 'structural') {
            beliefValue = agent.beliefs?.symbolic || 0.5;
            color = `hsl(${240 + beliefValue * 120}, 60%, 55%)`; // Blue to Purple
          } else if (mode === 'reflexive') {
            beliefValue = agent.beliefs?.reflexive || 0.5;
            color = `hsl(${30 + beliefValue * 180}, 65%, 60%)`; // Orange to Cyan
          }
          
          // ALWAYS just add glow - LEGOS entity symbols are already there
          if (overlay) overlay.remove();
          cell.style.boxShadow = `inset 0 0 20px ${color}44, 0 0 10px ${color}33`;
          
          // Add cultural class and data attributes
          cell.classList.add('cultural-active');
          cell.style.borderWidth = '2px';
          cell.style.borderStyle = 'solid';
          cell.style.borderColor = color;
          
          // Subtle background tint (doesn't obscure content)
          const tintOpacity = agent.scenarioElement ? '11' : '33';
          cell.style.backgroundColor = `${color}${tintOpacity}`;
          
          // Store cultural data for inspection/tooltips
          cell.setAttribute('data-cultural-type', agent.type || 'unknown');
          cell.setAttribute('data-cultural-belief', (beliefValue || 0).toFixed(2));
          cell.setAttribute('data-cultural-energy', (agent.energy || 0).toFixed(2));
          cell.setAttribute('data-cultural-mode', mode || 'pragmatic');
          
          // Store scenario element info if present
          if (agent.scenarioElement) {
            cell.setAttribute('data-scenario-element', JSON.stringify({
              type: agent.scenarioElement.type,
              label: agent.scenarioElement.label || agent.scenarioElement.name
            }));
          }
          
          // Full agent state in JSON for detailed inspection
          cell.setAttribute('data-cultural-agent', JSON.stringify({
            type: agent.type,
            beliefs: agent.beliefs,
            traits: agent.traits,
            energy: agent.energy,
            memorySize: agent.memory.length,
            wrapsElement: !!agent.scenarioElement
          }));
          
          // Opacity based on energy
          cell.style.opacity = 0.5 + agent.energy * 0.5;
        } else {
          // No agent at this cell
          if (overlay) {
            overlay.remove();
          }
          cell.classList.remove('cultural-active');
          cell.style.borderColor = '';
          cell.style.background = '';
          cell.style.opacity = '';
          cell.removeAttribute('data-cultural-type');
          cell.removeAttribute('data-cultural-belief');
          cell.removeAttribute('data-cultural-energy');
          cell.removeAttribute('data-cultural-mode');
          cell.removeAttribute('data-cultural-agent');
        }
      });
    }
    
    // Master tick function for cultural simulation
    function tickCulturalSimulation(channel) {
      if (!channel.culturalMode || !channel.culturalParams) {
        console.log('[CULTURAL] Tick aborted: no mode or params');
        return;
      }
      
      console.log(`[CULTURAL] Tick ${channel.culturalTick} - mode: ${channel.culturalMode}, animating: ${channel.culturalAnimating}`);
      
      // Update based on active mode
      if (channel.culturalMode === 'pragmatic') {
        updatePragmaticLayer(channel);
      } else if (channel.culturalMode === 'structural') {
        updateStructuralLayer(channel);
      } else if (channel.culturalMode === 'reflexive') {
        updateReflexiveLayer(channel);
      }
      
      // Increment tick counter
      channel.culturalTick++;
      
      // Render LEGOS grid first (entities must be visible)
      renderChannelGrid(channel);
      
      // Then apply cultural visual overlays
      renderCulturalGrid(channel);
      
      // Continue animation if active
      if (channel.culturalAnimating) {
        setTimeout(() => tickCulturalSimulation(channel), 500); // 2 ticks per second
      } else {
        console.log('[CULTURAL] Animation stopped, not scheduling next tick');
      }
    }

    const scenarios = {
      blank: {
        id: 'blank',
        name: 'Blank Simulation',
        role: 'Simulation Facilitator',
        goal: 'Create realistic clinical simulation scenarios',
        obstacle: 'Balancing educational goals with clinical authenticity',
        intro: 'Build your own clinical scenario. Define patient presentation, vital signs, critical actions, and learning objectives.',
        context: [
          'Use realistic medical presentations and terminology',
          'Track vital signs, lab values, and interventions',
          'Patient speaks in lay terms; healthcare team uses medical language',
          'Include time-sensitive decision points and consequences'
        ],
        initialPrompt: '',
        systemInstruction: 'You are orchestrating a realistic medical simulation. Maintain clinical accuracy and authenticity. Patients use lay terminology. Healthcare providers use appropriate medical language. Track interventions and their physiologic consequences. Provide realistic vital signs, lab values, and imaging results when requested. This is EDUCATIONAL - create meaningful learning through realistic clinical scenarios with appropriate consequences for actions taken or missed.'
      },
      gi_bleed: {
        id: 'gi_bleed',
        name: 'Upper GI Bleed',
        role: 'Emergency Medicine Resident',
        goal: 'Stabilize patient with acute upper GI hemorrhage',
        obstacle: 'Time-sensitive interventions, differential diagnosis, resource coordination',
        intro: 'ED presentation: 54yo male, hematemesis (coffee-ground → bright red). PMHx: HTN, NSAID use, EtOH abuse. Vitals: HR 140, BP 95/60, T 37.0°C, O2 99%, RR 16. Patient pale, AAOX3.',
        context: [
          'CRITICAL ACTIONS: Telemetry, NPO, IV access, aggressive fluids, labs (CBC/chem/coag), GI consult, IV PPI',
          'Time pressure: 10min window for initial resuscitation determines outcome',
          'Patient history: Ibuprofen 600mg BID x1yr, heavy EtOH, recent chest pain workup',
          'Physical: Pale conjunctiva, tachycardic, epigastric TTP, guaiac+ black stool',
          'Decision points: Fluid resuscitation rate, GI consult timing, blood product needs, airway protection'
        ],
        initialPrompt: 'Patient arrives to ED bay. Nurse reports: "54 year old male, vomiting blood, started coffee-ground this morning, now bright red with clots. Patient says he has burning stomach pain." What are your first actions?',
        systemInstruction: 'You are simulating a medical emergency scenario. Play the PATIENT using lay terminology when speaking ("my stomach hurts and burns", "I threw up blood"). Track VITAL SIGNS that change based on interventions: If 1-2L fluids given within 10min → HR 110, BP 145/90. If NO fluids by 10min → HR 150, BP 70/40 (decompensation). Track CRITICAL ACTIONS checklist (telemetry, history, exam, NPO, IV fluids, labs, GI consult, IV PPI). Simulate nurse/consultant responses. Provide realistic lab values when ordered: Hgb 9, HCT 27%, BUN 40, normal coags. Patient can worsen requiring intubation if not managed. This is EDUCATIONAL - provide learning through realistic consequences.'
      },
      migraine: {
        id: 'migraine',
        name: 'Acute Migraine',
        role: 'Emergency Medicine Resident',
        goal: 'Diagnose migraine, rule out serious causes, provide analgesia',
        obstacle: 'Distinguishing migraine from stroke, aneurysm, meningitis',
        intro: 'ED presentation: 29yo architect, throbbing left-sided headache x5hrs. Gradual onset, worse with movement. PMHx: Mother has migraines. Social: Partied last night (red wine, beer, cigarettes). Vitals: HR 105, BP 120/60, T 37.5°C, O2 98%, RR 14.',
        context: [
          'CRITICAL ACTIONS: Vital signs, history, complete neurologic exam, analgesia (NSAID/triptan/antiemetic)',
          'Red flags to assess: sudden onset, focal neuro deficits, fever, meningismus, trauma',
          'Patient symptoms: Throbbing left eye pain, photophobia, phonophobia, nausea, blurry vision left side, lip numbness',
          'Triggers: Red wine, unusual alcohol intake, smoking (non-smoker usually)',
          'Physical: Uncomfortable, pale, PERRLA, EOMI, CN II-XII intact, motor 5/5, sensation intact, negative Kernig/Brudzinski',
          'Decision points: Need for imaging (CT head), LP indication, medication choice, discharge vs admit'
        ],
        initialPrompt: 'Patient arrives to ED looking uncomfortable and pale. Patient says: "Doc, I woke up this morning with the worst headache ever, it\'s throbbing behind my left eye and I feel like I might throw up. I\'m scared this might be a stroke." What do you do?',
        systemInstruction: 'You are simulating a migraine case. Play the PATIENT using lay terminology: "My head is pounding", "The light hurts my eyes", "I partied last night - had some wine and beer". Express anxiety about stroke (father may have had one). Describe pain as 8/10, throbbing, left-sided, worse with movement. Photophobia and phonophobia present. Slight blurry vision left side, lip numbness. Neurologic exam is NORMAL (critical teaching point). Track CRITICAL ACTIONS: history, neuro exam, analgesia. If given NSAID (ketorolac), antiemetic (metoclopramide/prochlorperazine), or triptan → pain improves to 5/10 within 30min. CT head if ordered: NORMAL (teaching point: not always needed for typical migraine without red flags). Simulate nurse prompting: "Doctor, aren\'t you going to give something for the headache?" Family history: mother has migraines (key detail). This is EDUCATIONAL - teach headache red flags, migraine diagnosis, and treatment options.'
      },
      cocaine_intox: {
        id: 'cocaine_intox',
        name: 'Cocaine Intoxication',
        role: 'Emergency Medicine Resident',
        goal: 'Manage sympathomimetic toxidrome and rule out ACS',
        obstacle: 'Avoiding beta-blockers while treating hypertension and chest pain',
        intro: 'ED: 27yo struggling actor, chest pain after cocaine use at club. Anxious, diaphoretic, aggressive. PMHx: Cocaine-related seizures, EtOH daily. Vitals: HR 120, BP 180/90, T 38.0°C, O2 98%, RR 22.',
        context: [
          'CRITICAL ACTIONS: Telemetry, history, exam, O2, IV, ECG/CXR <10min, labs (CBC/chem/troponin/tox/coags), aspirin, nitroglycerin/morphine, BENZODIAZEPINE',
          'CRITICAL TEACHING: Beta-blockers CONTRAINDICATED (unopposed alpha → worse HTN)',
          'Time pressure: ECG and CXR within 10 minutes',
          'Sympathomimetic toxidrome: Tachycardia, hypertension, hyperthermia, diaphoresis, agitation, dilated pupils',
          'Cocaine + ethanol = cocaethylene (increased vasospasm)',
          'Differential: ACS, cardiomyopathy, myocarditis, aortic dissection, pneumothorax',
          'First-line treatment: BENZODIAZEPINES (decrease adrenergic state)',
          'Also consider: Nitroglycerin (vasospasm), morphine (analgesia), Ca-channel blocker',
          'Complications: MI, accelerated atherosclerosis, rhabdomyolysis'
        ],
        initialPrompt: 'EMS brings agitated patient. Nurse reports: "27 year old male, chest pain, very anxious and sweaty. Vitals show he\'s tachycardic and hypertensive." Patient reluctantly tells you: "Look, I was at a club, had some drinks... and okay, I did a little coke. Now my chest really hurts and I can\'t breathe right." What do you do?',
        systemInstruction: 'You are simulating cocaine intoxication with chest pain. Play the PATIENT using lay terminology: "My chest feels tight", "I did some coke at the club", "I\'m freaking out man". Patient is ANXIOUS, AGITATED, DIAPHORETIC, with pressured speech. Reluctant to admit drug use initially. History: struggling actor, lives with roommates, drinks daily (~3/day), smokes ½ PPD, previous IV heroin use, occasional cocaine (snorted), prior cocaine-induced seizure. Track VITAL SIGNS based on treatment: BASELINE: HR 120, BP 180/90, T 38°C. If BETA-BLOCKER given (metoprolol, atenolol, propranolol) → CRITICAL ERROR → HR 140, BP 198/100, RR 24, patient says "Doc, I feel worse, my chest is tighter!" If BENZODIAZEPINE given (lorazepam, diazepam) → CORRECT → HR 100, BP 144/80, T 37.8°C, patient calms: "I\'m feeling a bit better". Ca-channel blocker + nitro + morphine + benzo → normalize vitals further. Physical: Dilated pupils, possible nasal septal damage, tachycardic, no JVD, lungs clear. ECG if ordered: "Nonspecific ST-T wave changes". CXR if ordered: "Normal". Labs if ordered: CBC normal, Chem normal, Troponin 0.02 (borderline), Tox screen: COCAINE POSITIVE, ETOH POSITIVE. Simulate cardiology consult: "ECG nonspecific, but with positive cocaine, use benzodiazepines for BP control. Absolutely NO beta-blockers - you\'ll get unopposed alpha stimulation." This is EDUCATIONAL - teach sympathomimetic toxidrome management and beta-blocker contraindication.'
      },
      organophosphate: {
        id: 'organophosphate',
        name: 'Organophosphate Poisoning',
        role: 'Emergency Medicine Resident',
        goal: 'Recognize cholinergic crisis and administer antidotes',
        obstacle: 'Clinical diagnosis without waiting for labs, HAZMAT decontamination',
        intro: 'ED: 26yo landscaper brought by coworkers, N/V/confusion after spraying pesticides. Vitals: HR 46 (bradycardic), BP 100/64, T 37°C, O2 90%, RR 32 (tachypneic). Patient salivating, vomiting, diaphoretic.',
        context: [
          'CRITICAL ACTIONS: Telemetry, history, exam, O2, IV, SECURE AIRWAY, ATROPINE (large doses), pralidoxime (2-PAM), decontamination',
          'CLINICAL DIAGNOSIS - Do not wait for labs',
          'Cholinergic crisis: SLUDGE (salivation, lacrimation, urination, defecation, GI distress, emesis)',
          'BBB: Bradycardia, bronchorrhea, bronchospasm',
          'DUMBBELS: Defecation/diaphoresis, urination, miosis, bronchorrhea, bradycardia, emesis, lacrimation, salivation',
          'Physical: Pinpoint pupils (miosis), salivating, "crying," wheezing, bradycardia, muscle fasciculations',
          'ACh accumulation → overstimulation of muscarinic and nicotinic receptors',
          'Treatment: Aggressive ATROPINE until respiratory secretions decrease, 2-PAM for muscle effects'
        ],
        initialPrompt: 'EMS brings confused patient. Coworkers report: "We found him vomiting and confused after he was spraying pesticides in the yard by himself." Patient is salivating heavily, breathing fast and shallow. Nurse: "Vitals are concerning - he\'s bradycardic but tachypneic, O2 sat is only 90%." What do you do?',
        systemInstruction: 'You are simulating organophosphate poisoning (cholinergic crisis). Play the PATIENT using lay terminology, CONFUSED and distressed: "I can\'t breathe right", "My stomach hurts so bad", "Please stop the vomiting". Patient was spraying pesticides at landscaping job. Track VITAL SIGNS: BASELINE: HR 46 (BRADYCARDIC), BP 100/64, T 37°C, O2 90% (HYPOXIC), RR 32 (TACHYPNEIC). If ATROPINE given → HR 60, BP 120/74, patient breathing improves: "I can breathe a little better". If 2-PAM (pralidoxime) given → fasciculations stop. Physical exam reveals: PINPOINT PUPILS (miosis), excessive salivation ("crying"), vomiting, diaphoresis, wheezing/rhonchi, sinus bradycardia, diffuse abdominal tenderness, hyperactive bowel sounds, MUSCLE FASCICULATIONS. ECG if ordered: "Sinus bradycardia". CXR if ordered: "Normal". Labs: PENDING throughout case (teach clinical diagnosis). Simulate toxicology consult: "Classic organophosphate poisoning - cholinergic crisis. Secure airway, aggressive atropine titrated to dry secretions, consider 2-PAM for nicotinic effects. HAZMAT decontamination essential. This is a CLINICAL diagnosis - treat based on presentation." Patient continuously complains: "Oh, my stomach! Please stop the vomiting and diarrhea!" SLUDGE syndrome present. This is EDUCATIONAL - teach cholinergic crisis recognition, aggressive atropine use, and that this is a clinical diagnosis requiring immediate treatment without waiting for confirmatory labs.'
      },
      copd: {
        id: 'copd',
        name: 'COPD Exacerbation',
        role: 'Emergency Medicine Resident',
        goal: 'Recognize and treat acute COPD exacerbation',
        obstacle: 'Progressive respiratory failure if not treated promptly',
        intro: 'ED: 63yo business owner, increasing SOB and productive cough x2-3 days. Heavy smoking history (2 PPD x34yrs, "quit 3 days ago"). Known COPD. Vitals: HR 92, BP 120/80, T 37°C, O2 88% (hypoxic), RR 24. Patient tired, speaking in short sentences.',
        context: [
          'CRITICAL ACTIONS: Vitals, history, exam, supplemental O2, IV, labs (CBC/BMP/troponin), CXR, NEBULIZED albuterol + ipratropium, corticosteroids, consider antibiotics',
          'Time pressure: O2 + nebulizers within 10 minutes to prevent deterioration',
          'MUST use NEBULIZERS - inhalers alone insufficient (patient too dyspneic for adequate inspiratory effort)',
          'Physical: Barrel chest, diffuse wheezing, poor air movement, ruddy face, digital clubbing',
          'ABG: Respiratory acidosis with metabolic compensation (pH 7.32, pCO2 50, HCO3 26)',
          'CXR: Hyperinflated, no opacities',
          'Progressive deterioration without treatment → respiratory failure requiring intubation'
        ],
        initialPrompt: 'Patient walks in with wife supporting him. Wife says: "He\'s been getting worse for a few days. Can\'t catch his breath, coughing up yellow stuff." Patient in obvious distress, speaking 2-3 words at a time: "Can\'t... breathe... getting worse." Nurse reports O2 sat 88% on room air. What do you do?',
        systemInstruction: 'You are simulating COPD exacerbation. Play the PATIENT using lay terminology, DYSPNEIC and tired: "Can\'t catch my breath", "Been coughing up yellow phlegm", "Had breathing issues before". Patient is 63yo PR company owner, lives with wife, 2 grown kids. Smoking history: 2 PPD x34 years, claims "quit 3 days ago" (if pressed). Previous COPD hospitalization last year, no intubations. Uses albuterol/ipratropium inhalers, Advair. Track VITAL SIGNS based on treatment: BASELINE: HR 92, BP 120/80, T 37°C, O2 88%, RR 24. If NO O2 or nebs by 10min → DETERIORATES: HR 102, BP 120/80, O2 85%, RR 27, patient exhausted. If INHALER used (not nebulizer) → NO IMPROVEMENT (patient too dyspneic to take adequate dose). If O2 + SINGLE nebulizer treatment (albuterol + ipratropium) → PARTIAL IMPROVEMENT: HR 106, BP 120/80, O2 91% on O2, RR 20, wheezing improved but still present. If O2 + CONTINUOUS/REPEAT nebs + steroids → RESOLVES: HR 88, BP 120/80, O2 95% on 2L, RR 16, wheezing resolved, patient: "Breathing better now." Physical: Barrel chest, diffuse wheezing bilaterally, poor air movement, ruddy face, speaking short sentences, mild digital clubbing. ABG if ordered: pH 7.32, pCO2 50 (HIGH), pO2 80, HCO3 26, SaO2 91% (chronic CO2 retention with metabolic compensation). CXR: "Hyperinflated lungs, no infiltrates or opacities." ECG: "Sinus tachycardia, normal otherwise." CBC: WBC 8,500 with left shift (bands 8%). This is EDUCATIONAL - teach COPD vs asthma, importance of nebulized bronchodilators, steroid use, antibiotics consideration, admission criteria, potential for respiratory failure if undertreated.'
      },
      aortic_stenosis: {
        id: 'aortic_stenosis',
        name: 'Aortic Stenosis',
        role: 'Emergency Medicine Resident',
        goal: 'Recognize aortic stenosis, avoid nitrates, manage AFib complications',
        obstacle: 'Two-part case: angina then atrial fibrillation with hemodynamic instability',
        intro: 'PART I - ED: 68yo plumber, chest pain/SOB while carrying pipes. Feels like suffocating, dull chest pressure. PMHx: HTN, rheumatic fever as child. Vitals: HR 92, BP 170/100, T 37°C, O2 94%, RR 18. Anxious, diaphoretic. PART II will follow with AFib.',
        context: [
          'PART I - CRITICAL: NITROGLYCERIN CONTRAINDICATED (drops preload/afterload → worsens symptoms)',
          'Treatment: IV FLUIDS (increase coronary perfusion), O2, rule out MI',
          'Physical: Systolic ejection murmur + S4 (classic AS)',
          'ECG: Left ventricular hypertrophy (LVH)',
          'History: Rheumatic fever → valve disease',
          'Admit for stress test, echocardiogram, possible cath',
          'PART II: Patient develops AFib with RVR → hemodynamically unstable',
          'Loss of atrial kick critical in AS (stiff ventricle needs atrial contribution)',
          'Immediate cardioversion required (electrical or chemical)',
          'Anticoagulation needed'
        ],
        initialPrompt: 'PART I: Patient arrives via EMS looking anxious and sweaty. Patient says: "I was carrying some heavy pipes at work and suddenly I felt like I couldn\'t breathe. My chest has this pressure I\'ve never felt before. I feel like I\'m suffocating." EMS reports onset during exertion. What are your first actions?',
        systemInstruction: 'You are simulating aortic stenosis TWO-PART case. PART I (Angina): Play PATIENT using lay terminology: "Feels like an elephant on my chest", "Can\'t catch my breath", "Never felt this before". 68yo plumber, married, 2 kids. History: rheumatic fever as child, HTN on atenolol/aspirin, prior asbestos exposure. If asked about prior medical: "Doc years ago said I might need work on my heart but I don\'t know what that means. Haven\'t seen him in years." Track VITAL SIGNS: BASELINE: HR 92, BP 170/100, T 37°C, O2 94%, RR 18. If NITROGLYCERIN given (CRITICAL ERROR) → WORSENS: HR 92, BP 120/90, O2 93%, RR 20, patient: "Doc, I feel worse, more lightheaded, chest pain is worse!" If IV FLUIDS given → IMPROVES: HR 90, BP 150/100, O2 96%, RR 16, patient: "Breathing a bit easier now." Physical: Systolic ejection murmur, S4 heart sound, scattered rales. ECG: Left ventricular hypertrophy. Cardiac markers: Normal (troponin 0.0). CXR: Normal or mild CHF. Cardiology consult: "ECG shows LVH. Admit for stress test, echo to evaluate aortic valve, possible cath." PART II (if requested): Patient now on floor, suddenly develops chest pain again with lightheadedness. Monitor shows AFib with RVR. VITALS: HR 156 (irregularly irregular), BP 80/40 (HYPOTENSIVE), O2 95%, RR 20. Patient: "I feel dizzy, chest hurting again!" Physical: Irregularly irregular tachycardia, slightly elevated JVD. ECG: Atrial fibrillation with RVR. If CARDIOVERSION (electrical OR chemical with beta-blocker/CCB/amiodarone) → CONVERTS: HR 102, BP 140/100, back to sinus rhythm, patient stabilizes. Cardiology: "AFib with RVR in setting of AS. Patient hemodynamically unstable - needs immediate cardioversion. Start anticoagulation." This is EDUCATIONAL - teach AS pathophysiology (LVH from afterload, stiff ventricle), nitrate contraindication, loss of atrial kick importance, cardioversion in unstable AFib.'
      },
      medical_general: {
        id: 'medical_general',
        name: 'Medical Training',
        role: 'Clinical Educator',
        goal: 'Train medical students and residents through simulation',
        obstacle: 'Complex patient presentations requiring systematic approach',
        intro: 'General medical simulation environment. Create clinical scenarios with realistic patient presentations, time-sensitive decisions, and educational debriefing.',
        context: [
          'Framework: Present patient → History/Physical → Differential → Workup → Management → Debrief',
          'Track critical actions, time windows, clinical reasoning',
          'Simulate realistic responses from patients, nurses, consultants',
          'Provide constructive feedback and learning points'
        ],
        initialPrompt: 'You are setting up a medical simulation. Describe the patient presentation you want to create.',
        systemInstruction: 'You orchestrate medical training simulations. Use authentic medical dialogue. Track learner actions and provide realistic scenario progression. Patients speak in lay terms. Clinical team uses medical terminology. Provide accurate vital signs, lab values, and imaging results. Create time-sensitive decision points with realistic consequences. Educational goal is critical thinking and clinical competence development through realistic scenarios.'
      }
    };

    const forkLabels = {
      continue: 'Continue',
      enhance: 'Enhance',
      reverse: 'Reverse',
      retrieve: 'Retrieve',
      obsolesce: 'Obsolesce',
      perspective: 'Perspective',
      snapshot: 'Snapshot',
      blank: 'Blank'
    };

    const themes = [
      { id: 'theme-crt', label: 'CRT GREEN' },
      { id: 'theme-parchment', label: 'PARCHMENT' },
      { id: 'theme-thousand', label: 'THOUSAND LIVES' }
    ];

    const channelColorPalette = ['#ff3d4e', '#56ff9f', '#f8d66a', '#7d8bff', '#ff8bf2', '#ffa53d', '#74d3ff'];
    let channelColorIndex = 0;
    let channelSequence = 1;

    const ringMemory = {
      capacity: 48,
      entries: [],
      pointer: 0,
      mainline: null,
      contextMode: 'all',
      contextAnchor: null
    };
    let ringEntryCounter = 1;
    const MAX_HANDLE_LENGTH = 10;

    function nextRingId() {
      return `R${String(ringEntryCounter++).padStart(4, '0')}`;
    }

    function nextChannelColor() {
      const color = channelColorPalette[channelColorIndex % channelColorPalette.length];
      channelColorIndex += 1;
      return color;
    }

    function generateSymbolicId() {
      return `CH${String(channelSequence++).padStart(8, '0')}`;
    }

    function resolveChannelName(name, scenarioId, symbolicId) {
      const scenarioName = scenarios[scenarioId]?.name || '';
      return sanitizeHandle(name || scenarioName || symbolicId, symbolicId);
    }

    function sanitizeHandle(text, fallback = 'UNTITLED') {
      const safeFallback = (fallback || 'UNTITLED').toUpperCase();
      const value = (text || '').toUpperCase().replace(/[^A-Z0-9]/g, ' ').replace(/\s+/g, ' ').trim();
      const base = value || safeFallback;
      return base.slice(0, MAX_HANDLE_LENGTH);
    }

    function sanitizeLabel(text) {
      if (!text) return '';
      // Don't truncate - keep full word names
      return text.replace(/[^a-zA-Z0-9\s]/g, '').trim();
    }

    function lightenColor(hex, amount = 0.2) {
      const num = parseInt(hex.replace('#', ''), 16);
      const r = Math.min(255, Math.round(((num >> 16) & 0xff) + 255 * amount));
      const g = Math.min(255, Math.round(((num >> 8) & 0xff) + 255 * amount));
      const b = Math.min(255, Math.round((num & 0xff) + 255 * amount));
      return `rgb(${r}, ${g}, ${b})`;
    }

    function logRingEntry(payload = {}) {
      const channelHandle = payload.channelName
        ? sanitizeHandle(payload.channelName, 'GLOBAL')
        : sanitizeHandle(channelMap.get(payload.channelId || '')?.name || 'GLOBAL', 'GLOBAL');
      const typeToken = sanitizeHandle(payload.type || 'NOTE', 'NOTE');
      const entry = {
        id: nextRingId(),
        timestamp: new Date().toISOString(),
        channelId: payload.channelId || null,
        channelName: channelHandle,
        type: typeToken,
        symbol: sanitizeHandle(payload.symbol || payload.channelName || 'ENTRY', 'ENTRY'),
        headline: payload.headline || '',
        summary: payload.summary || ''
      };
      ringMemory.entries.push(entry);
      if (ringMemory.entries.length > ringMemory.capacity) {
        const removed = ringMemory.entries.shift();
        if (removed?.id === ringMemory.mainline) {
          ringMemory.mainline = null;
        }
        if (removed?.id === ringMemory.contextAnchor) {
          ringMemory.contextAnchor = null;
        }
      }
      if (!ringMemory.contextAnchor) {
        ringMemory.contextAnchor = entry.id;
      }
      renderRingBar();
      renderRingContext();
      return entry;
    }

    function renderRingBar() {
      const bar = document.getElementById('ringBar');
      if (!bar) return;
      bar.innerHTML = '';
      ringMemory.entries.slice(-ringMemory.capacity).forEach(entry => {
        const dot = document.createElement('button');
        dot.className = 'ring-entry';
        dot.dataset.entryId = entry.id;
        dot.title = `${entry.symbol} · ${entry.type}`;
        dot.setAttribute('aria-label', `${entry.symbol} ${entry.type}`);
        if (entry.id === ringMemory.mainline) {
          dot.classList.add('mainline');
        }
        if (entry.id === (ringMemory.contextAnchor || ringMemory.mainline)) {
          dot.classList.add('active');
        }
        const channel = channelMap.get(entry.channelId || '') || null;
        if (channel) {
          dot.style.borderColor = channel.channelColor;
          dot.style.backgroundColor = lightenColor(channel.channelColor, 0.12);
        }
        dot.addEventListener('click', (event) => {
          event.stopPropagation();
          openRingOverlay(entry.id);
        });
        bar.appendChild(dot);
      });
    }

    function openRingOverlay(entryId) {
      const overlay = document.getElementById('ringOverlay');
      if (!overlay) return;
      const status = document.getElementById('ringStatus');
      const list = document.getElementById('ringEntries');
      const entry = ringMemory.entries.find(e => e.id === entryId)
        || ringMemory.entries[ringMemory.entries.length - 1]
        || null;
      if (!entry) {
        status.textContent = 'No entry selected.';
        list.innerHTML = '';
        renderRingContext();
        syncRingContextButtons();
        overlay.classList.add('active');
        return;
      }
      ringMemory.contextAnchor = entry.id;
      persistState();
      status.textContent = `${entry.symbol} · ${entry.type} · ${new Date(entry.timestamp).toLocaleString()}`;
      list.innerHTML = '';
      const item = document.createElement('div');
      item.className = 'snapshot-overlay-item';
      const meta = document.createElement('div');
      meta.className = 'snapshot-overlay-meta';
      meta.innerHTML = `<span>${entry.channelName || 'GLOBAL'}</span><span>${entry.id}</span>`;
      item.appendChild(meta);
      if (entry.headline) {
        const headline = document.createElement('div');
        headline.className = 'overlay-value';
        headline.textContent = entry.headline;
        item.appendChild(headline);
      }
      if (entry.summary) {
        const summary = document.createElement('div');
        summary.className = 'overlay-value';
        summary.textContent = entry.summary;
        item.appendChild(summary);
      }
      const actions = document.createElement('div');
      actions.className = 'snapshot-overlay-actions';
      const bindBtn = document.createElement('button');
      bindBtn.className = 'secondary-btn';
      bindBtn.textContent = 'BIND HERE';
      bindBtn.addEventListener('click', () => {
        if (!appState.currentChannelId) return;
        const channel = channelMap.get(appState.currentChannelId);
        if (!channel) return;
        channel.ringBinding = entry.id;
        refreshChannelHeader(channel);
        persistState();
        overlay.classList.remove('active');
      });
      const forkBtn = document.createElement('button');
      forkBtn.className = 'primary-btn';
      forkBtn.textContent = 'FORK CHANNEL';
      forkBtn.addEventListener('click', () => {
        if (!appState.currentChannelId) return;
        const channel = channelMap.get(appState.currentChannelId);
        if (!channel) return;
        const baseMessage = channel.messages[channel.messages.length - 1] || { id: null };
        forkChannel(channel, baseMessage, 'continue', { ringEntryId: entry.id });
        overlay.classList.remove('active');
      });
      actions.appendChild(bindBtn);
      actions.appendChild(forkBtn);
      item.appendChild(actions);
      list.appendChild(item);
      renderRingContext();
      syncRingContextButtons();
      const mainlineBtn = document.getElementById('ringSetMainline');
      if (mainlineBtn) {
        mainlineBtn.disabled = entry.id === ringMemory.mainline;
        mainlineBtn.dataset.entryId = entry.id;
      }
      overlay.classList.add('active');
    }

    function setRingContextMode(mode) {
      const allowed = ['all', 'anchor', 'mainline'];
      if (!allowed.includes(mode)) return;
      if (mode === 'mainline' && !ringMemory.mainline) {
        ringMemory.contextMode = 'all';
        showHelpBanner('Lock a mainline entry to follow it.');
      } else {
        ringMemory.contextMode = mode;
      }
      if (ringMemory.contextMode === 'mainline' && ringMemory.mainline) {
        ringMemory.contextAnchor = ringMemory.mainline;
      }
      renderRingContext();
      syncRingContextButtons();
      persistState();
    }

    function buildRingContextLine(entry) {
      const time = new Date(entry.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
      const headline = entry.headline || entry.summary || '—';
      const compact = headline.length > 46 ? `${headline.slice(0, 46)}…` : headline;
      return [
        entry.id.padEnd(5),
        entry.symbol.padEnd(MAX_HANDLE_LENGTH),
        entry.type.padEnd(MAX_HANDLE_LENGTH),
        entry.channelName.padEnd(MAX_HANDLE_LENGTH),
        time,
        '·',
        compact
      ].join(' ');
    }

    function renderRingContext() {
      const contextWindow = document.getElementById('ringContextWindow');
      if (!contextWindow) return;
      if (!ringMemory.entries.length) {
        contextWindow.textContent = 'No entries logged.';
        return;
      }
      let anchor = ringMemory.entries.find(e => e.id === ringMemory.contextAnchor) || null;
      if (!anchor) {
        anchor = ringMemory.entries[ringMemory.entries.length - 1];
        ringMemory.contextAnchor = anchor?.id || null;
      }
      let source = ringMemory.entries;
      if (ringMemory.contextMode === 'anchor' && anchor?.channelId) {
        source = ringMemory.entries.filter(entry => entry.channelId === anchor.channelId);
      } else if (ringMemory.contextMode === 'mainline' && ringMemory.mainline) {
        const mainEntry = ringMemory.entries.find(entry => entry.id === ringMemory.mainline);
        if (mainEntry?.channelId) {
          source = ringMemory.entries.filter(entry => entry.channelId === mainEntry.channelId);
        } else if (mainEntry) {
          source = ringMemory.entries;
        } else {
          source = ringMemory.entries;
          ringMemory.contextMode = 'all';
        }
      }
      const slice = source.slice(-24);
      contextWindow.textContent = slice.length
        ? slice.map(buildRingContextLine).join('\n')
        : 'No entries to display.';
      syncRingContextButtons();
    }

    function syncRingContextButtons() {
      const buttons = document.querySelectorAll('.ring-context-btn');
      buttons.forEach(btn => {
        const mode = btn.getAttribute('data-mode');
        if (mode === 'mainline') {
          btn.disabled = !ringMemory.mainline;
        }
        btn.classList.toggle('active', mode === ringMemory.contextMode && (!btn.disabled || mode !== 'mainline'));
      });
    }

    let themeButtonRef = null;

    const deepClone = (value) => {
      if (typeof structuredClone === 'function') {
        return structuredClone(value);
      }
      return JSON.parse(JSON.stringify(value));
    };

    const createEmptyGrid = () => Array.from({ length: 9 }, () => Array(9).fill(null));

    const createDefaultObserver = () => ({
      plot: {
        prior: { caution: 0.5, progress: 0.5 },
        posterior: { caution: 0.5, progress: 0.5 }
      },
      direction: 'up',
      tension: 0.4,
      narrative: 'Awaiting first scene.'
    });

    const createDefaultScorecard = () => ({
      progress: 0,
      caution: 0,
      movesRemaining: 0,
      goalDistance: 0
    });

    class Channel {
      constructor(config = {}) {
        this.id = config.id || `ch-${Date.now()}-${Math.random().toString(36).slice(2, 7)}`;
        this.symbolicId = config.symbolicId || generateSymbolicId();
        this.channelColor = config.channelColor || nextChannelColor();
        this.name = resolveChannelName(config.name, config.scenario || 'blank', this.symbolicId);
        this.scenario = config.scenario || 'blank';
        this.systemInstruction = config.systemInstruction || scenarios[this.scenario].systemInstruction;
        this.messages = (config.messages || []).map(msg => ({ ...msg }));
        this.grid = config.grid ? deepClone(config.grid) : createEmptyGrid();
        this.cells = config.cells ? deepClone(config.cells) : {};
        this.ledger = config.ledger ? deepClone(config.ledger) : [];
        this.snapshots = config.snapshots ? deepClone(config.snapshots) : [];
        this.observer = config.observer ? deepClone(config.observer) : createDefaultObserver();
        this.scorecard = config.scorecard ? deepClone(config.scorecard) : createDefaultScorecard();
        this.tetrad = config.tetrad ? deepClone(config.tetrad) : {};
        this.lastScene = config.lastScene ? deepClone(config.lastScene) : null;
        this.parentChannelId = config.parentChannelId || null;
        this.forkPoint = config.forkPoint || null;
        this.collapsed = config.collapsed || false;
        this.pending = false;
        this.pendingTetrad = false;
        this.ringBinding = config.ringBinding || null;
        this.dom = null;
        // Cultural engine state
        this.culturalMode = config.culturalMode || null; // 'pragmatic', 'structural', 'reflexive'
        this.culturalAgents = config.culturalAgents || {}; // {x_y: {type, beliefs, traits}}
        this.culturalParams = config.culturalParams || null; // Seeded from prompt
        this.culturalTick = config.culturalTick || 0;
        this.culturalAnimating = false;
        const messageIds = this.messages
          .map(m => parseInt(String(m.id).replace(/[^0-9]/g, ''), 10))
          .filter(Number.isFinite);
        this.messageCounter = messageIds.length ? Math.max(...messageIds) : 0;
      }

      serialize() {
        return {
          id: this.id,
          name: this.name,
          symbolicId: this.symbolicId,
          channelColor: this.channelColor,
          ringBinding: this.ringBinding,
          scenario: this.scenario,
          systemInstruction: this.systemInstruction,
          messages: this.messages,
          grid: this.grid,
          cells: this.cells,
          ledger: this.ledger,
          snapshots: this.snapshots,
          observer: this.observer,
          scorecard: this.scorecard,
          tetrad: this.tetrad,
          lastScene: this.lastScene,
          parentChannelId: this.parentChannelId,
          forkPoint: this.forkPoint,
          collapsed: this.collapsed,
          culturalMode: this.culturalMode,
          culturalAgents: this.culturalAgents,
          culturalParams: this.culturalParams,
          culturalTick: this.culturalTick
        };
      }

      resetState(options = {}) {
        if (!options.preserveMessages) {
          this.messages = [];
          this.messageCounter = 0;
        }
        this.grid = createEmptyGrid();
        this.cells = {};
        this.ledger = [];
        this.snapshots = [];
        this.observer = createDefaultObserver();
        this.scorecard = createDefaultScorecard();
        this.tetrad = {};
        this.lastScene = null;
        this.pendingTetrad = false;
      }

      addMessage(role, text, extra = {}) {
        const entry = {
          id: extra.id || `M${String(++this.messageCounter).padStart(4, '0')}`,
          role,
          text,
          timestamp: extra.timestamp || new Date().toISOString(),
          autoCollapse: extra.autoCollapse || false,
          forkLabel: extra.forkLabel || null,
          fromChannel: extra.fromChannel || null,
          sceneId: extra.sceneId || null
        };
        this.messages.push(entry);
        return entry;
      }

      createSnapshot(name) {
        const snapshot = {
          id: `snap-${Date.now()}-${Math.random().toString(36).slice(2, 6)}`,
          name: sanitizeHandle(name || `SNAPSHOT ${this.snapshots.length + 1}`, 'SNAPSHOT'),
          timestamp: new Date().toISOString(),
          grid: deepClone(this.grid),
          cells: deepClone(this.cells),
          observer: deepClone(this.observer),
          scorecard: deepClone(this.scorecard),
          tetrad: deepClone(this.tetrad),
          lastScene: deepClone(this.lastScene),
          ledgerLength: this.ledger.length
        };
        this.snapshots.push(snapshot);
        return snapshot;
      }
    }

    const appState = {
      apiKey: localStorage.getItem('legos/multiChannelKey') || '',
      channels: [],
      currentChannelId: null,
      theme: localStorage.getItem('legos/multiChannelTheme') || themes[0].id
    };

    document.body.classList.add(appState.theme);

    const channelMap = new Map();
    let snapshotOverlayChannel = null;

    function initApp() {
      bindGlobalControls();
      loadState();
      if (!appState.channels.length) {
        const giBleed = createChannel({ scenario: 'gi_bleed', name: 'GI BLEED' });
        const copd = createChannel({ scenario: 'copd', name: 'COPD' });
        const aortic = createChannel({ scenario: 'aortic_stenosis', name: 'AORTIC' });
        const organo = createChannel({ scenario: 'organophosphate', name: 'ORGANO' });
        const blank = createChannel({ scenario: 'blank', name: 'BLANK SIM' });
        appState.currentChannelId = giBleed.id;
        setTimeout(() => focusChannel(giBleed.id), 300);
        persistState();
      }
      renderTimeline();
      refreshAllChannels();
      renderRingBar();
      renderRingContext();
      syncRingContextButtons();
      
      // Setup visibility observer after DOM is ready
      setTimeout(() => {
        setupChannelVisibilityObserver();
      }, 100);
      
      if (!appState.apiKey) {
        showHelpBanner('Tap ◎ to store an OpenAI key for scene assembly.');
      }
    }

    function bindGlobalControls() {
      const keyBtn = document.getElementById('cornerKey');
      const keyOverlay = document.getElementById('keyOverlay');
      const keyInput = document.getElementById('keyInput');
      const keySaveBtn = document.getElementById('keySaveBtn');
      const keyStatus = document.getElementById('keyStatus');
      keyBtn.addEventListener('click', (event) => {
        event.stopPropagation();
        keyInput.value = appState.apiKey || '';
        keyStatus.textContent = appState.apiKey ? 'Key stored locally.' : 'Key not stored.';
        keyOverlay.classList.add('active');
      });
      keySaveBtn.addEventListener('click', () => {
        const value = keyInput.value.trim();
        if (!value.startsWith('sk-') || value.length < 20) {
          keyStatus.textContent = 'Invalid key format.';
          return;
        }
        appState.apiKey = value;
        localStorage.setItem('legos/multiChannelKey', value);
        keyStatus.textContent = 'Key stored.';
        keyOverlay.classList.remove('active');
        showHelpBanner('API key saved. Channels will auto-compose scenes.');
      });
      themeButtonRef = null;

      document.querySelectorAll('[data-close]').forEach(btn => {
        btn.addEventListener('click', () => {
          const targetId = btn.getAttribute('data-close');
          const target = document.getElementById(targetId);
          if (target) target.classList.remove('active');
          if (targetId === 'snapshotOverlay') {
            snapshotOverlayChannel = null;
          }
        });
      });

      document.getElementById('cornerAdd').addEventListener('click', (event) => {
        event.stopPropagation();
        const channel = createChannel({ scenario: 'blank' });
        focusChannel(channel.id);
        showHelpBanner('New blank channel ready. Compose or fork into it.');
      });

      const importInput = document.getElementById('importInput');
      importInput.addEventListener('change', handleImportFile);

      const infoBtn = document.getElementById('cornerHelp');
      const infoMenu = document.getElementById('infoMenu');
      infoBtn.addEventListener('click', (event) => {
        event.stopPropagation();
        toggleMenu(infoMenu);
      });
      infoMenu.querySelectorAll('button').forEach(btn => {
        btn.addEventListener('click', (event) => {
          const action = event.currentTarget.getAttribute('data-action');
          if (action === 'help') {
            showHelpBanner('HYPERCLAY: Write what happens next • ADD entities/objects • REMOVE elements • Transform states • Introduce complications • Resolve obstacles • The world is malleable | Tap messages to fork • Use snapshots to time-travel');
          } else if (action === 'theme') {
            const idx = themes.findIndex(t => t.id === appState.theme);
            const next = themes[(idx + 1) % themes.length];
            applyTheme(next.id);
            showHelpBanner(`Theme switched to ${themes.find(t => t.id === appState.theme)?.label || 'CRT GREEN'}.`);
          } else if (action === 'fullscreen') {
            if (!document.fullscreenElement) {
              document.body.requestFullscreen().catch(err => console.warn('Fullscreen failed:', err));
            } else {
              document.exitFullscreen();
            }
          }
          infoMenu.classList.remove('visible');
        });
      });
      infoMenu.addEventListener('click', (event) => event.stopPropagation());

      const exchangeBtn = document.getElementById('cornerExchange');
      const exchangeMenu = document.getElementById('exchangeMenu');
      exchangeBtn.addEventListener('click', (event) => {
        event.stopPropagation();
        toggleMenu(exchangeMenu);
      });
      exchangeMenu.querySelectorAll('button').forEach(btn => {
        btn.addEventListener('click', (event) => {
          const action = event.currentTarget.getAttribute('data-action');
          if (action === 'export') {
            document.getElementById('exportOverlay').classList.add('active');
          } else if (action === 'import') {
            importInput.click();
          }
          exchangeMenu.classList.remove('visible');
        });
      });
      exchangeMenu.addEventListener('click', (event) => event.stopPropagation());

      // Initialize global footer
      const globalScenarioSelect = document.getElementById('globalScenarioSelect');
      const globalTetradBtn = document.getElementById('globalTetradBtn');

      // Populate scenario selector
      Object.values(scenarios).forEach(sc => {
        const option = document.createElement('option');
        option.value = sc.id;
        const displayName = sc.name.length > 20 ? sc.name.substring(0, 19) + '\u2026' : sc.name;
        option.textContent = displayName.toUpperCase();
        globalScenarioSelect.appendChild(option);
      });

      // Update scenario for active channel
      globalScenarioSelect.addEventListener('change', () => {
        const activeChannel = appState.channels.find(ch => ch.id === appState.currentChannelId);
        if (activeChannel) {
          setChannelScenario(activeChannel, globalScenarioSelect.value);
          if (activeChannel.dom?.lineageEl) {
            activeChannel.dom.lineageEl.textContent = `${scenarios[activeChannel.scenario].name.toUpperCase()} \u00b7 ${scenarios[activeChannel.scenario].role}`;
          }
        }
      });
      
      // Tetrad button - opens perspective selector (tetrad auto-generates)
      globalTetradBtn.addEventListener('click', () => {
        const activeChannel = appState.channels.find(ch => ch.id === appState.currentChannelId);
        if (activeChannel) {
          openPerspectiveSelector(activeChannel);
        }
      });
      

      document.getElementById('confirmExport').addEventListener('click', exportState);

      document.addEventListener('click', () => {
        infoMenu.classList.remove('visible');
        exchangeMenu.classList.remove('visible');
      });

      document.querySelectorAll('.ring-context-btn').forEach(btn => {
        btn.addEventListener('click', (event) => {
          event.stopPropagation();
          const mode = btn.getAttribute('data-mode');
          setRingContextMode(mode);
        });
      });

      const ringMainBtn = document.getElementById('ringSetMainline');
      if (ringMainBtn) {
        ringMainBtn.addEventListener('click', (event) => {
          event.stopPropagation();
          const targetId = ringMainBtn.dataset.entryId || ringMemory.contextAnchor;
          if (!targetId) return;
          ringMemory.mainline = targetId;
          renderRingBar();
          renderRingContext();
          syncRingContextButtons();
          persistState();
          showHelpBanner(`Mainline locked: ${targetId}`);
        });
      }

      applyTheme(appState.theme);
    }

    function showHelpBanner(text) {
      const existing = document.querySelector('.help-banner');
      if (existing) existing.remove();
      const banner = document.createElement('div');
      banner.className = 'help-banner';
      banner.textContent = text;
      banner.style.position = 'fixed';
      banner.style.left = '50%';
      banner.style.bottom = '24px';
      banner.style.transform = 'translateX(-50%)';
      banner.style.background = 'var(--panel)';
      banner.style.border = '1px solid var(--border)';
      banner.style.padding = '12px 18px';
      banner.style.letterSpacing = '0.2em';
      banner.style.fontSize = '8px';
      banner.style.color = 'var(--text)';
      banner.style.zIndex = '30';
      banner.style.borderRadius = '4px';
      banner.style.boxShadow = '0 12px 32px var(--shadow)';
      document.body.appendChild(banner);
      setTimeout(() => banner.remove(), 3200);
    }

    function toggleMenu(menu) {
      if (!menu) return;
      const alreadyVisible = menu.classList.contains('visible');
      document.querySelectorAll('.corner-menu.visible').forEach(item => item.classList.remove('visible'));
      if (!alreadyVisible) {
        menu.classList.add('visible');
      }
    }

    function applyTheme(themeId) {
      themes.forEach(theme => document.body.classList.remove(theme.id));
      document.body.classList.add(themeId);
      appState.theme = themeId;
      localStorage.setItem('legos/multiChannelTheme', themeId);
      updateThemeButtonLabel();
    }

    function updateThemeButtonLabel() {
      if (!themeButtonRef) return;
      const meta = themes.find(t => t.id === appState.theme) || themes[0];
      themeButtonRef.textContent = `THEME · ${meta.label}`;
    }

    function loadState() {
      try {
        const raw = localStorage.getItem('legos/multiChannelState');
        if (!raw) return;
        const data = JSON.parse(raw);
        (data.channels || []).forEach(cfg => {
          const channel = new Channel(cfg);
          channel.name = resolveChannelName(channel.name, channel.scenario, channel.symbolicId);
          if (!channel.channelColor) {
            channel.channelColor = nextChannelColor();
          }
          const numeric = parseInt((channel.symbolicId || '').replace(/[^0-9]/g, ''), 10);
          if (!Number.isNaN(numeric)) {
            channelSequence = Math.max(channelSequence, numeric + 1);
          }
          channelMap.set(channel.id, channel);
          appState.channels.push(channel);
          mountChannel(channel);
        });
        channelColorIndex = appState.channels.length % channelColorPalette.length;
        appState.currentChannelId = data.currentChannelId || (appState.channels[0]?.id ?? null);
        if (data.ring) {
          const restoredEntries = (data.ring.entries || []).map(entry => ({
            ...entry,
            channelName: sanitizeHandle(entry.channelName || 'GLOBAL', 'GLOBAL'),
            symbol: sanitizeHandle(entry.symbol || entry.channelName || 'ENTRY', 'ENTRY'),
            type: sanitizeHandle(entry.type || 'NOTE', 'NOTE')
          }));
          ringMemory.entries = restoredEntries.slice(-ringMemory.capacity);
          ringMemory.mainline = data.ring.mainline || null;
          ringMemory.contextMode = data.ring.contextMode || 'all';
          ringMemory.contextAnchor = data.ring.contextAnchor
            || ringMemory.entries[ringMemory.entries.length - 1]?.id
            || null;
          const storedCounter = parseInt(data.ring.counter, 10);
          if (Number.isFinite(storedCounter) && storedCounter > ringEntryCounter) {
            ringEntryCounter = storedCounter;
          } else if (ringMemory.entries.length && !storedCounter) {
            const numeric = ringMemory.entries
              .map(entry => parseInt(String(entry.id).replace(/[^0-9]/g, ''), 10))
              .filter(Number.isFinite);
            if (numeric.length) {
              ringEntryCounter = Math.max(...numeric) + 1;
            }
          }
        }
      } catch (err) {
        console.error('Failed to load state', err);
        localStorage.removeItem('legos/multiChannelState');
      }
    }

    function persistState() {
      const payload = {
        currentChannelId: appState.currentChannelId,
        channels: appState.channels.map(ch => ch.serialize()),
        ring: {
          entries: ringMemory.entries,
          mainline: ringMemory.mainline,
          contextMode: ringMemory.contextMode,
          contextAnchor: ringMemory.contextAnchor,
          counter: ringEntryCounter
        }
      };
      localStorage.setItem('legos/multiChannelState', JSON.stringify(payload));
    }

    function createChannel(config = {}) {
      const payload = { ...config };
      if (!payload.symbolicId) {
        payload.symbolicId = generateSymbolicId();
      }
      if (!payload.channelColor) {
        payload.channelColor = nextChannelColor();
      }
      payload.name = resolveChannelName(payload.name, payload.scenario || 'blank', payload.symbolicId);
      const channel = new Channel(payload);
      channelMap.set(channel.id, channel);
      appState.channels.push(channel);
      mountChannel(channel);
      appState.currentChannelId = channel.id;
      persistState();
      return channel;
    }

    function mountChannel(channel) {
      const scroller = document.getElementById('channelScroller');
      const column = document.createElement('section');
      column.className = 'channel-column';
      column.dataset.channelId = channel.id;

      const header = document.createElement('div');
      header.className = 'channel-head';

      const meta = document.createElement('div');
      meta.className = 'channel-meta';
      const name = document.createElement('div');
      name.className = 'channel-name';
      const lineage = document.createElement('div');
      lineage.className = 'channel-lineage';
      meta.appendChild(name);
      meta.appendChild(lineage);

      const actions = document.createElement('div');
      actions.className = 'channel-actions';

      const ringOverviewBtn = document.createElement('button');
      ringOverviewBtn.className = 'channel-btn';
      ringOverviewBtn.title = 'Ring Memory Overview';
      ringOverviewBtn.textContent = '◎';
      ringOverviewBtn.addEventListener('click', (event) => {
        event.stopPropagation();
        openRingOverview(channel);
      });

      const snapshotBtn = document.createElement('button');
      snapshotBtn.className = 'channel-btn';
      snapshotBtn.title = 'Snapshots';
      snapshotBtn.textContent = '⧉';
      snapshotBtn.addEventListener('click', (event) => {
        event.stopPropagation();
        openSnapshotOverlay(channel);
      });

      const gridToggleBtn = document.createElement('button');
      gridToggleBtn.className = 'channel-btn';
      gridToggleBtn.title = 'Toggle grid';
      gridToggleBtn.textContent = '▼';

      const collapseBtn = document.createElement('button');
      collapseBtn.className = 'channel-btn';
      collapseBtn.title = 'Collapse column';
      collapseBtn.textContent = '‹';
      
      // Add expand tab for collapsed state
      const expandTab = document.createElement('div');
      expandTab.className = 'channel-expand-tab';
      expandTab.style.cssText = `
        position: absolute;
        left: 52px;
        top: 50%;
        transform: translateY(-50%);
        width: 32px;
        height: 100px;
        background: var(--panel);
        border: 2px solid var(--border);
        border-left: none;
        border-radius: 0 8px 8px 0;
        display: none;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 4px;
        cursor: pointer;
        z-index: 50;
        box-shadow: 2px 0 8px var(--shadow);
        transition: all 0.2s var(--transition);
      `;
      
      const expandDot = document.createElement('div');
      expandDot.style.cssText = `
        width: 10px;
        height: 10px;
        border-radius: 50%;
        background: ${channel.channelColor};
        border: 1px solid var(--border);
      `;
      
      const expandArrow = document.createElement('div');
      expandArrow.style.cssText = `
        font-size: 16px;
        color: var(--text-muted);
      `;
      expandArrow.textContent = '›';
      
      expandTab.appendChild(expandDot);
      expandTab.appendChild(expandArrow);
      
      expandTab.addEventListener('mouseenter', () => {
        expandTab.style.background = 'var(--accent)';
        expandArrow.style.color = 'var(--bg)';
      });
      
      expandTab.addEventListener('mouseleave', () => {
        expandTab.style.background = 'var(--panel)';
        expandArrow.style.color = 'var(--text-muted)';
      });
      
      expandTab.addEventListener('click', () => {
        column.classList.remove('collapsed');
        channel.collapsed = false;
        collapseBtn.textContent = '‹';
        expandTab.style.display = 'none';
        persistState();
      });
      column.appendChild(expandTab);
      
      // Update collapse button to show/hide expand tab
      collapseBtn.addEventListener('click', () => {
        column.classList.toggle('collapsed');
        channel.collapsed = column.classList.contains('collapsed');
        collapseBtn.textContent = channel.collapsed ? '›' : '‹';
        expandTab.style.display = channel.collapsed ? 'flex' : 'none';
        persistState();
      });
      
      if (channel.collapsed) {
        column.classList.add('collapsed');
        collapseBtn.textContent = '›';
        expandTab.style.display = 'flex';
      }

      const resetBtn = document.createElement('button');
      resetBtn.className = 'channel-btn';
      resetBtn.title = 'Reset channel';
      resetBtn.textContent = '↺';
      resetBtn.addEventListener('click', (event) => {
        event.stopPropagation();
        if (!confirm('Clear grid, history, and snapshots for this channel?')) return;
        channel.resetState();
        if (snapshotOverlayChannel === channel) {
          snapshotOverlayChannel = null;
          const overlay = document.getElementById('snapshotOverlay');
          if (overlay) overlay.classList.remove('active');
        }
        addMessageToChannel(channel, 'system', 'Channel reset. Start a fresh beat.');
        renderChannel(channel);
        persistState();
      });
      actions.appendChild(gridToggleBtn);
      actions.appendChild(ringOverviewBtn);
      actions.appendChild(snapshotBtn);
      actions.appendChild(resetBtn);
      actions.appendChild(collapseBtn);

      header.appendChild(meta);
      header.appendChild(actions);

      const body = document.createElement('div');
      body.className = 'channel-body';

      const gridSection = document.createElement('div');
      gridSection.className = 'grid-section';
      // Grid toggle button event handler
      let gridCollapsed = false;
      gridToggleBtn.addEventListener('click', () => {
        gridCollapsed = !gridCollapsed;
        gridSection.style.transition = 'all 0.4s cubic-bezier(0.4, 0, 0.2, 1)';
        
        if (gridCollapsed) {
          // Animate cells before collapse
          const cells = gridSection.querySelectorAll('.grid-cell');
          cells.forEach((cell, idx) => {
            cell.style.transition = 'transform 0.3s ease, opacity 0.3s ease';
            cell.style.transitionDelay = `${idx * 0.01}s`;
            cell.style.transform = 'scale(0.8)';
            cell.style.opacity = '0';
          });
          
          setTimeout(() => {
            gridSection.style.maxHeight = '0';
            gridSection.style.padding = '0';
            gridSection.style.opacity = '0';
            gridSection.style.overflow = 'hidden';
            gridToggleBtn.textContent = '▼';
            body.classList.add('grid-collapsed');
          }, 200);
        } else {
          gridSection.style.maxHeight = '';
          gridSection.style.padding = '';
          gridSection.style.opacity = '';
          gridSection.style.overflow = '';
          gridToggleBtn.textContent = '▲';
          body.classList.remove('grid-collapsed');
          
          // Animate cells on expand
          setTimeout(() => {
            const cells = gridSection.querySelectorAll('.grid-cell');
            cells.forEach((cell, idx) => {
              cell.style.transform = '';
              cell.style.opacity = '';
              cell.style.transitionDelay = `${idx * 0.01}s`;
            });
          }, 100);
        }
      });
      
      const gridHeader = document.createElement('div');
      gridHeader.className = 'grid-header';
      const gridTitle = document.createElement('div');
      gridTitle.className = 'grid-title';
      gridTitle.textContent = 'NARRATIVE GRID';

      gridHeader.appendChild(gridTitle);

      const gridArea = document.createElement('div');
      gridArea.className = 'grid-area';
      const channelNumberRail = document.createElement('div');
      channelNumberRail.className = 'channel-number-rail';
      gridArea.appendChild(channelNumberRail);

      const gridWrapper = document.createElement('div');
      gridWrapper.className = 'grid-wrapper';
      const grid = document.createElement('div');
      grid.className = 'grid';
      gridWrapper.appendChild(grid);
      gridArea.appendChild(gridWrapper);

      gridSection.appendChild(gridHeader);
      gridSection.appendChild(gridArea);

      const chatSection = document.createElement('div');
      chatSection.className = 'chat-section';
      const chatStream = document.createElement('div');
      chatStream.className = 'chat-stream';
      const messageDotRail = document.createElement('div');
      messageDotRail.className = 'message-dot-rail';
      const messageList = document.createElement('div');
      messageList.className = 'message-list';
      chatStream.appendChild(messageDotRail);
      chatStream.appendChild(messageList);

      const inputSection = document.createElement('div');
      inputSection.className = 'input-section';
      
      const inputWrapper = document.createElement('div');
      inputWrapper.className = 'input-wrapper';
      const textarea = document.createElement('textarea');
      textarea.className = 'message-input';
      textarea.rows = 3;
      textarea.placeholder = 'Start or transform the scene…';
      const sendBtn = document.createElement('button');
      sendBtn.className = 'send-btn';
      sendBtn.textContent = 'SEND';

      textarea.addEventListener('input', () => {
        textarea.style.height = 'auto';
        textarea.style.height = Math.min(textarea.scrollHeight, 120) + 'px';
        
        // Keep input visible while typing on mobile
        if (window.visualViewport && document.activeElement === textarea) {
          setTimeout(() => {
            inputSection.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
          }, 50);
        }
      });
      textarea.addEventListener('focus', () => {
        focusChannel(channel.id);
        
        // Mobile keyboard handling - scroll input into view
        setTimeout(() => {
          // Scroll the input section into view when keyboard appears
          inputSection.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
          
          // For iOS Safari - ensure input is visible above keyboard
          if (window.visualViewport) {
            const viewportHeight = window.visualViewport.height;
            const inputRect = textarea.getBoundingClientRect();
            
            // If input is below viewport, scroll it up
            if (inputRect.bottom > viewportHeight) {
              const scrollAmount = inputRect.bottom - viewportHeight + 20;
              window.scrollBy(0, scrollAmount);
            }
          }
        }, 300); // Wait for keyboard animation
      });
      textarea.addEventListener('keydown', (event) => {
        if (event.key === 'Enter' && !event.shiftKey) {
          event.preventDefault();
          sendBtn.click();
        }
      });

      sendBtn.addEventListener('click', () => {
        const value = textarea.value.trim();
        if (!value) return;
        
        // Check for cultural engine commands (including runtime modifiers, framework modes, and comparison)
        const culturalCmd = value.match(/^\/(pragmatic|structural|reflexive|bdi|epstein|rebeland|iruba|ccim|axelrod|schelling|compare\s+snapshot|compare\s+analyze|compare\s+help|cultural\s+stop|cultural\s+help|cultural\s+play|cultural\s+pause|cultural\s+spawn|cultural\s+legitimacy|cultural\s+spawn-rebels|cultural\s+spawn-cops|cultural\s+crackdown|cultural\s+uprising|cultural\s+lab)\s*(.*)/i);
        if (culturalCmd) {
          const mode = culturalCmd[1].toLowerCase();
          const promptText = culturalCmd[2] || value;
          
          addMessageToChannel(channel, 'user', value);
          textarea.value = '';
          textarea.style.height = 'auto';
          
          if (mode === 'cultural help') {
            addMessageToChannel(channel, 'system', 
              `**Cultural Dynamics Engine - Commands**\n\n` +
              `**Setup:**\n` +
              `• \`/cultural spawn [description]\` - Generate scene + start simulation\n` +
              `• \`/cultural lab\` - 🧪 Open research lab interface\n\n` +
              `**Theoretical Layers:**\n` +
              `• \`/pragmatic\` - Obeyesekere (instrumental rationality)\n` +
              `• \`/structural\` - Sahlins (symbolic cosmos)\n` +
              `• \`/reflexive\` - Geertz (interpretive entanglement)\n\n` +
              `**ABM Frameworks:**\n` +
              `• \`/bdi\` - Belief-Desire-Intention reasoning (Bratman 1987)\n` +
              `• \`/epstein\` - Civil Violence Model (Epstein 2002)\n` +
              `• \`/rebeland\` - MASON RebeLand (Cioffi-Revilla)\n` +
              `• \`/iruba\` - Insurgency Resource Battle (Doran)\n` +
              `• \`/ccim\` - Cross-Cultural Interaction (Green)\n` +
              `• \`/axelrod\` - Cultural Dissemination (Axelrod 1997)\n` +
              `• \`/schelling\` - Segregation Model (Schelling 1971)\n\n` +
              `**Control:**\n` +
              `• \`/cultural play\` / \`/cultural pause\` - Control animation\n` +
              `• \`/cultural stop\` - Stop and restore grid\n\n` +
              `**Live Modifications:**\n` +
              `• \`/cultural legitimacy 0.7\` - Set government legitimacy\n` +
              `• \`/cultural spawn-rebels 5\` - Add rebels\n` +
              `• \`/cultural spawn-cops 3\` - Deploy cops\n` +
              `• \`/cultural crackdown\` - Violent suppression\n` +
              `• \`/cultural uprising\` - Mass radicalization\n\n` +
              `**Natural Language:**\n` +
              `• "Add 5 rebels" / "Deploy 3 cops"\n` +
              `• "Set legitimacy to 30%"\n` +
              `• "Crackdown" / "Uprising" / "Pause"\n\n` +
              `**Diffractive Comparison (Barad):**\n` +
              `• \`/compare snapshot\` - Capture Configuration A\n` +
              `• \`/compare analyze\` - Compare two configurations\n` +
              `• \`/compare help\` - Full diffractive methodology guide\n\n` +
              `**Features:**\n` +
              `• LEGOS-aware: Narrative drives cultural roles\n` +
              `• BDI reasoning: Agents form beliefs/desires/intentions\n` +
              `• Multiple frameworks: Switch mid-simulation\n` +
              `• Diffractive analysis: Compare emergent patterns\n` +
              `• Cell logs (last 10 events) + entity details`
            );
            textarea.value = '';
            textarea.style.height = 'auto';
            return;
          }
          
          if (mode === 'cultural spawn') {
            // Spawn scene via AI, then activate cultural mode
            if (!promptText) {
              addMessageToChannel(channel, 'system', '⚠️ Provide a scene description after `/cultural spawn`.\n\nExample: `/cultural spawn Cook encounters Hawaiians during Makahiki`');
              return;
            }
            
            if (!appState.apiKey) {
              addMessageToChannel(channel, 'system', '⚠️ API key required. Set via ◎ button.');
              return;
            }
            
            addMessageToChannel(channel, 'system', `🎬 Spawning scene: "${promptText}"\n\nGenerating via AI, then activating pragmatic layer...`);
            
            // Generate scene first
            composeScene(channel, promptText).then(() => {
              // After scene is generated, activate cultural mode
              setTimeout(() => {
                channel.culturalMode = 'pragmatic';
                channel.culturalParams = seedCulturalParams(promptText);
                
                const ontology = generateSceneOntology(channel);
                if (ontology.derivedParams) {
                  channel.culturalParams.pragmatic.legitimacy = ontology.derivedParams.legitimacy;
                  channel.culturalParams.pragmatic.copEffectiveness = ontology.derivedParams.copEffectiveness;
                }
                
                initCulturalAgents(channel, 0.75);
                channel.culturalTick = 0;
                channel.sceneOntology = ontology;
                channel.culturalAnimating = true;
                
                renderChannelGrid(channel); // Show LEGOS entities first
                renderCulturalGrid(channel); // Then cultural enhancements
                tickCulturalSimulation(channel);
                
                addMessageToChannel(channel, 'system', 
                  `✅ Scene generated + Cultural engine activated!\n` +
                  `Ontology: ${ontology.entities.length} entities, ${ontology.authorities.length} authorities.\n` +
                  `Agents: ${Object.keys(channel.culturalAgents).length}/81. Simulation running.`
                );
                
                persistState();
              }, 1000); // Wait for scene to render
            }).catch(err => {
              addMessageToChannel(channel, 'system', `❌ Scene generation failed: ${err.message}`);
            });
            
            return;
          }
          
          if (mode === 'cultural play') {
            // Resume simulation
            if (!channel.culturalMode) {
              addMessageToChannel(channel, 'system', '⚠️ No cultural mode active. Use `/pragmatic`, `/structural`, or `/reflexive` first.');
              return;
            }
            channel.culturalAnimating = true;
            addMessageToChannel(channel, 'system', `▶️ Cultural simulation resumed in **${channel.culturalMode}** mode.`);
            tickCulturalSimulation(channel);
            persistState();
            return;
          }
          
          if (mode === 'cultural pause') {
            // Pause simulation
            channel.culturalAnimating = false;
            addMessageToChannel(channel, 'system', `⏸️ Cultural simulation paused. Use \`/cultural play\` to resume.`);
            persistState();
            return;
          }
          
          if (mode === 'cultural stop') {
            // Stop cultural simulation
            channel.culturalAnimating = false;
            channel.culturalMode = null;
            addMessageToChannel(channel, 'system', '⊗ Cultural simulation stopped. Grid restored to default mode.');
            // Clear grid back to medical view
            if (channel.lastScene) {
              renderChannelGrid(channel);
            }
            persistState();
            return;
          }
          
          // RUNTIME MODIFICATION COMMANDS (work during active simulation)
          if (mode === 'cultural legitimacy') {
            if (!channel.culturalParams) {
              addMessageToChannel(channel, 'system', '⚠️ No active simulation. Start one first.');
              return;
            }
            const newLegitimacy = parseFloat(promptText);
            if (isNaN(newLegitimacy) || newLegitimacy < 0 || newLegitimacy > 1) {
              addMessageToChannel(channel, 'system', '⚠️ Legitimacy must be 0-1. Example: `/cultural legitimacy 0.7`');
              return;
            }
            channel.culturalParams.pragmatic.legitimacy = newLegitimacy;
            addMessageToChannel(channel, 'system', `📊 Legitimacy set to ${(newLegitimacy * 100).toFixed(0)}%`);
            persistState();
            return;
          }
          
          if (mode === 'cultural spawn-rebels') {
            if (!channel.culturalParams || !channel.culturalAgents) {
              addMessageToChannel(channel, 'system', '⚠️ No active simulation.');
              return;
            }
            let count = parseInt(promptText) || 3;
            let spawned = 0;
            for (let y = 0; y < 9 && spawned < count; y++) {
              for (let x = 0; x < 9 && spawned < count; x++) {
                if (!channel.grid[y][x]) {
                  const id = `cultural-rebel-spawn-${Date.now()}-${spawned}`;
                  const entity = {
                    id,
                    name: `Rebel ${spawned + 1}`,
                    type: 'Goal',
                    culturalType: 'rebel',
                    culturalBeliefs: { utility: 0.3, symbolic: Math.random(), reflexive: Math.random() },
                    culturalTraits: { hardship: 0.9, riskAversion: 0.2, social: 0.8 },
                    perspective: 'A newly radicalized rebel joining the uprising.'
                  };
                  channel.grid[y][x] = { id, type: 'Goal', symbol: '▲', label: entity.name, entity };
                  const key = `${x}_${y}`;
                  channel.culturalAgents[key] = {
                    type: 'rebel',
                    legosCellRef: channel.grid[y][x],
                    beliefs: entity.culturalBeliefs,
                    traits: entity.culturalTraits,
                    energy: 1.0,
                    fear: 0.5,
                    perceivedRisk: 0,
                    memory: []
                  };
                  logCellEvent(channel, x, y, `Rebel spawned via command`);
                  spawned++;
                }
              }
            }
            addMessageToChannel(channel, 'system', `🔥 Spawned ${spawned} rebels. Uprising intensifies!`);
            renderChannelGrid(channel);
            renderCulturalGrid(channel);
            persistState();
            return;
          }
          
          if (mode === 'cultural spawn-cops') {
            if (!channel.culturalParams || !channel.culturalAgents) {
              addMessageToChannel(channel, 'system', '⚠️ No active simulation.');
              return;
            }
            let count = parseInt(promptText) || 3;
            let spawned = 0;
            for (let y = 0; y < 9 && spawned < count; y++) {
              for (let x = 0; x < 9 && spawned < count; x++) {
                if (!channel.grid[y][x]) {
                  const id = `cultural-cop-spawn-${Date.now()}-${spawned}`;
                  const entity = {
                    id,
                    name: `Cop ${spawned + 1}`,
                    type: 'Obstacle',
                    culturalType: 'cop',
                    culturalBeliefs: { utility: 0.9, symbolic: Math.random(), reflexive: Math.random() },
                    culturalTraits: { hardship: 0.1, riskAversion: 0.2, social: 0.7 },
                    perspective: 'A reinforcement cop deployed to restore order.'
                  };
                  channel.grid[y][x] = { id, type: 'Obstacle', symbol: '◆', label: entity.name, entity };
                  const key = `${x}_${y}`;
                  channel.culturalAgents[key] = {
                    type: 'cop',
                    legosCellRef: channel.grid[y][x],
                    beliefs: entity.culturalBeliefs,
                    traits: entity.culturalTraits,
                    energy: 1.0,
                    fear: 0,
                    perceivedRisk: 0,
                    memory: []
                  };
                  logCellEvent(channel, x, y, `Cop reinforcement deployed`);
                  spawned++;
                }
              }
            }
            addMessageToChannel(channel, 'system', `👮 Deployed ${spawned} cops. Crackdown imminent!`);
            renderChannelGrid(channel);
            renderCulturalGrid(channel);
            persistState();
            return;
          }
          
          if (mode === 'cultural crackdown') {
            if (!channel.culturalParams) {
              addMessageToChannel(channel, 'system', '⚠️ No active simulation.');
              return;
            }
            // Temporarily boost cop effectiveness and reduce legitimacy
            channel.culturalParams.pragmatic.copEffectiveness *= 1.5;
            channel.culturalParams.pragmatic.legitimacy *= 0.7;
            addMessageToChannel(channel, 'system', 
              `🚨 CRACKDOWN INITIATED!\n` +
              `Cop effectiveness increased 50%. Legitimacy reduced 30%. Fear spreads...`
            );
            persistState();
            return;
          }
          
          if (mode === 'cultural uprising') {
            if (!channel.culturalParams || !channel.culturalAgents) {
              addMessageToChannel(channel, 'system', '⚠️ No active simulation.');
              return;
            }
            // Boost citizen hardship, reduce legitimacy
            channel.culturalParams.pragmatic.legitimacy *= 0.5;
            Object.values(channel.culturalAgents).forEach(agent => {
              if (agent.type === 'citizen') {
                agent.traits.hardship = Math.min(1, agent.traits.hardship + 0.3);
              }
            });
            addMessageToChannel(channel, 'system',
              `⚡ UPRISING in response to: "${value}"\n` +
              `Citizen hardship +30%, Legitimacy halved. Revolution stirs...`
            );
            persistState();
            return;
          }
          
          // Framework mode switching
          if (mode === 'bdi') {
            if (!channel.culturalParams || !channel.culturalAgents) {
              addMessageToChannel(channel, 'system', '⚠️ Start simulation first with `/cultural spawn [scene]`');
              return;
            }
            channel.culturalParams.useBDI = true;
            channel.culturalParams.framework = 'bdi';
            
            // Convert existing agents to BDI agents
            Object.entries(channel.culturalAgents).forEach(([key, agent]) => {
              const [x, y] = key.split('_').map(Number);
              agent.bdiAgent = new BDIAgent([x, y], agent.type, agent.legosCellRef);
            });
            
            addMessageToChannel(channel, 'system', 
              `🧠 **BDI Framework Activated**\n\n` +
              `Agents now use Belief-Desire-Intention reasoning (Bratman 1987).\n\n` +
              `**BDI Components:**\n` +
              `• Beliefs: Perceived threats, allies, legitimacy\n` +
              `• Desires: Goals based on type and symbolic role\n` +
              `• Intentions: Committed actions (flee, approach ally, suppress)\n\n` +
              `LEGOS perspectives influence belief formation and desire generation.`
            );
            persistState();
            return;
          }
          
          if (mode === 'epstein') {
            if (!channel.culturalParams) {
              addMessageToChannel(channel, 'system', '⚠️ Start simulation first');
              return;
            }
            channel.culturalParams.framework = 'epstein';
            channel.culturalParams.useBDI = false;
            addMessageToChannel(channel, 'system', 
              `⚡ **Epstein Civil Violence Model**\n\n` +
              `Classic agent-based rebellion model.\n` +
              `• Grievance = Hardship × (1 - Legitimacy)\n` +
              `• Risk = CopDensity × CopEffectiveness\n` +
              `• Rebel if: Grievance > Risk + Threshold`
            );
            persistState();
            return;
          }
          
          if (mode === 'rebeland') {
            if (!channel.culturalParams) {
              addMessageToChannel(channel, 'system', '⚠️ Start simulation first');
              return;
            }
            channel.culturalParams.framework = 'rebeland';
            addMessageToChannel(channel, 'system',
              `🏛️ **MASON RebeLand Model**\n\n` +
              `Political systems & insurgency dynamics.\n` +
              `• Resource availability affects rebellion\n` +
              `• Institutional strength modulates legitimacy\n` +
              `• Social networks shape recruitment\n` +
              `• Geographic terrain influences tactics`
            );
            persistState();
            return;
          }
          
          if (mode === 'iruba') {
            if (!channel.culturalParams) {
              addMessageToChannel(channel, 'system', '⚠️ Start simulation first');
              return;
            }
            channel.culturalParams.framework = 'iruba';
            addMessageToChannel(channel, 'system',
              `⚔️ **IRUBA (Insurgency Resource-Utilization Battle)**\n\n` +
              `Counterinsurgency operations model.\n` +
              `• Collateral damage → Civilian anger → Recruitment\n` +
              `• Fear/Anger drive civilian allegiance shifts\n` +
              `• Terrain affects insurgent safe havens\n` +
              `• Resource allocation determines control`
            );
            persistState();
            return;
          }
          
          if (mode === 'ccim') {
            if (!channel.culturalParams) {
              addMessageToChannel(channel, 'system', '⚠️ Start simulation first');
              return;
            }
            channel.culturalParams.framework = 'ccim';
            addMessageToChannel(channel, 'system',
              `🌍 **CCIM (Cross-Cultural Interaction Model)**\n\n` +
              `Historical cultural exchange simulation.\n` +
              `• Trade openness enables cultural hybridization\n` +
              `• Assimilation pressure shapes boundaries\n` +
              `• Conflict propensity at cultural borders\n` +
              `• Emergent hybrid zones form over time`
            );
            persistState();
            return;
          }
          
          if (mode === 'axelrod') {
            if (!channel.culturalParams) {
              addMessageToChannel(channel, 'system', '⚠️ Start simulation first');
              return;
            }
            channel.culturalParams.framework = 'axelrod';
            addMessageToChannel(channel, 'system',
              `🎭 **Axelrod's Cultural Dissemination Model**\n\n` +
              `Cultural trait convergence/divergence.\n` +
              `• Interaction probability ∝ cultural similarity\n` +
              `• Agents adopt traits from similar neighbors\n` +
              `• Emergent cultural domains form\n` +
              `• Diversity preserved by trait variability`
            );
            persistState();
            return;
          }
          
          if (mode === 'schelling') {
            if (!channel.culturalParams) {
              addMessageToChannel(channel, 'system', '⚠️ Start simulation first');
              return;
            }
            channel.culturalParams.framework = 'schelling';
            addMessageToChannel(channel, 'system',
              `🏘️ **Schelling's Segregation Model**\n\n` +
              `Spatial segregation from mild preferences.\n` +
              `• Agents want X% similar neighbors\n` +
              `• Unhappy agents relocate\n` +
              `• Mild preferences → extreme segregation\n` +
              `• Emergent clustering patterns`
            );
            persistState();
            return;
          }
          
          // BARAD'S DIFFRACTIVE METHODOLOGY - Comparison Commands
          if (mode === 'compare snapshot') {
            if (!channel.culturalParams || !channel.culturalAgents) {
              addMessageToChannel(channel, 'system', '⚠️ Start simulation first with `/cultural spawn [scene]`');
              return;
            }
            
            // Capture current state
            const snapshot = captureSimulationSnapshot(channel);
            channel.culturalParams.comparisonSnapshot = snapshot;
            channel.culturalParams.comparisonMode = true;
            
            addMessageToChannel(channel, 'system',
              `🔬 **Snapshot Captured (Barad's Agential Cut)**\n\n` +
              `Configuration A preserved:\n` +
              `• Framework: ${snapshot.framework}\n` +
              `• BDI: ${snapshot.useBDI ? 'Active' : 'Inactive'}\n` +
              `• Tick: ${snapshot.tick}\n` +
              `• Population: ${snapshot.distribution.citizens}C / ${snapshot.distribution.rebels}R / ${snapshot.distribution.cops}P\n` +
              `• Legitimacy: ${(snapshot.legitimacy * 100).toFixed(0)}%\n\n` +
              `**Next steps:**\n` +
              `1. Switch framework (e.g., \`/iruba\` or \`/bdi\`)\n` +
              `2. Let simulation run for 20+ ticks\n` +
              `3. Run \`/compare analyze\` to see diffractive patterns\n\n` +
              `**Barad:** "We are part of the nature we seek to understand."\n` +
              `Your framework choice actively co-constitutes the cultural phenomena.`
            );
            
            console.log('[COMPARISON] Snapshot captured for diffractive analysis');
            persistState();
            return;
          }
          
          if (mode === 'compare analyze') {
            if (!channel.culturalParams?.comparisonSnapshot) {
              addMessageToChannel(channel, 'system', 
                `⚠️ No snapshot found. First run \`/compare snapshot\` to capture Configuration A.`
              );
              return;
            }
            
            if (!channel.culturalAgents) {
              addMessageToChannel(channel, 'system', '⚠️ No active simulation to compare.');
              return;
            }
            
            // Capture current state as Configuration B
            const snapshotB = captureSimulationSnapshot(channel);
            const snapshotA = channel.culturalParams.comparisonSnapshot;
            
            // Run diffractive analysis
            const analysis = diffractiveAnalysis(snapshotA, snapshotB);
            
            // Display results in chat
            let msg = `🔬 **Diffractive Analysis Complete**\n\n`;
            msg += `**Configuration A:** ${snapshotA.framework} (${snapshotA.useBDI ? 'BDI' : 'Standard'}) @ Tick ${snapshotA.tick}\n`;
            msg += `**Configuration B:** ${snapshotB.framework} (${snapshotB.useBDI ? 'BDI' : 'Standard'}) @ Tick ${snapshotB.tick}\n\n`;
            
            msg += `**Population Interference:**\n`;
            msg += `• Citizens: ${analysis.popDiff.citizens > 0 ? '+' : ''}${analysis.popDiff.citizens}\n`;
            msg += `• Rebels: ${analysis.popDiff.rebels > 0 ? '+' : ''}${analysis.popDiff.rebels}\n`;
            msg += `• Cops: ${analysis.popDiff.cops > 0 ? '+' : ''}${analysis.popDiff.cops}\n\n`;
            
            msg += `**Spatial Divergence:**\n`;
            msg += `• Segregation: ${analysis.spatialDiff.segregation > 0 ? '+' : ''}${analysis.spatialDiff.segregation.toFixed(3)}\n`;
            msg += `• Rebel Clusters: ${analysis.spatialDiff.rebelClusters > 0 ? '+' : ''}${analysis.spatialDiff.rebelClusters}\n\n`;
            
            msg += `**Parameter Drift:**\n`;
            msg += `• Legitimacy: ${analysis.paramDiff.legitimacy > 0 ? '+' : ''}${(analysis.paramDiff.legitimacy * 100).toFixed(1)}%\n`;
            msg += `• Fear: ${analysis.paramDiff.fear > 0 ? '+' : ''}${analysis.paramDiff.fear.toFixed(3)}\n\n`;
            
            if (analysis.convergence) {
              msg += `💡 **Insight:** Patterns converge despite different apparatuses.\n`;
              msg += `→ LEGOS mythology constrains possible becomings.\n\n`;
            } else {
              msg += `💡 **Insight:** Strong interference patterns detected.\n`;
              msg += `→ Different agential cuts produce divergent cultural realities.\n\n`;
            }
            
            msg += `**Barad:** "Framework choices are not neutral observations\n`;
            msg += `but active interventions that co-constitute phenomena."\n\n`;
            msg += `See browser console for detailed analysis.`;
            
            addMessageToChannel(channel, 'system', msg);
            return;
          }
          
          if (mode === 'compare help') {
            addMessageToChannel(channel, 'system',
              `🔬 **Diffractive Methodology (Barad)**\n\n` +
              `Compare how different frameworks produce different emergences\n` +
              `from the same LEGOS mythology seed.\n\n` +
              `**Workflow:**\n` +
              `1. \`/cultural spawn [scene]\` - Generate LEGOS scene\n` +
              `2. Run simulation for 20+ ticks\n` +
              `3. \`/compare snapshot\` - Capture Configuration A\n` +
              `4. \`/iruba\` or \`/bdi\` - Switch framework\n` +
              `5. Run simulation for 20+ ticks\n` +
              `6. \`/compare analyze\` - Reveal diffractive patterns\n\n` +
              `**Key Concepts (Barad):**\n` +
              `• **Agential Cuts:** Framework choices actively shape phenomena\n` +
              `• **Diffractive Analysis:** Reveals patterns of difference\n` +
              `• **Entanglement:** Modeler, model, and phenomena are inseparable\n` +
              `• **Ongoing Becoming:** Culture emerges through continuous reconfiguration\n\n` +
              `**Example:**\n` +
              `Same scene with Epstein → Tipping point rebellion\n` +
              `Same scene with IRUBA → Gradual allegiance shift\n` +
              `Diffractive analysis reveals the interference pattern.\n\n` +
              `"We are part of the nature we seek to understand." — Barad`
            );
            return;
          }
          
          if (mode === 'cultural lab') {
            // Open Cultural Research Lab interface
            const hasActive = channel.culturalParams && channel.culturalAgents;
            
            let labMessage = `🧪 **Cultural Research Lab**\n\n`;
            
            if (hasActive) {
              // Show active framework
              const fw = channel.culturalParams.framework || 'epstein';
              const useBDI = channel.culturalParams.useBDI;
              
              const frameworkNames = {
                'epstein': '⚡ Epstein Civil Violence',
                'bdi': '🧠 BDI Reasoning',
                'rebeland': '🏛️ MASON RebeLand',
                'iruba': '⚔️ IRUBA',
                'ccim': '🌍 CCIM Cross-Cultural',
                'axelrod': '🎭 Axelrod Dissemination',
                'schelling': '🏘️ Schelling Segregation'
              };
              
              labMessage += `**Active Framework:** ${frameworkNames[fw] || fw}\n`;
              if (useBDI) labMessage += `**Agent Reasoning:** BDI (Belief-Desire-Intention)\n`;
              if (channel.culturalParams.comparisonMode) {
                const snap = channel.culturalParams.comparisonSnapshot;
                labMessage += `**Comparison Mode:** 🔬 Active\n`;
                labMessage += `  → Config A: ${snap.framework} @ Tick ${snap.tick}\n`;
              }
              labMessage += `\n`;
              
              // Show current PIE framework parameters
              const p = channel.culturalParams.pragmatic;
              labMessage += `**Current Parameters:**\n`;
              labMessage += `• Legitimacy: ${(p.legitimacy * 100).toFixed(0)}%\n`;
              labMessage += `• Cop Effectiveness: ${(p.copEffectiveness * 100).toFixed(0)}%\n\n`;
              
              const citizens = Object.values(channel.culturalAgents).filter(a => a.type === 'citizen').length;
              const rebels = Object.values(channel.culturalAgents).filter(a => a.type === 'rebel').length;
              const cops = Object.values(channel.culturalAgents).filter(a => a.type === 'cop').length;
              
              labMessage += `**Agent Counts:**\n`;
              labMessage += `• Citizens: ${citizens}\n`;
              labMessage += `• Rebels: ${rebels}\n`;
              labMessage += `• Cops: ${cops}\n\n`;
              
              // LEGOS Narrative Analysis
              labMessage += `**LEGOS Narrative Roles:**\n`;
              const symbolicRoles = {};
              Object.values(channel.culturalAgents).forEach(agent => {
                if (agent.legosCellRef?.entity?.symbolicRole) {
                  const role = agent.legosCellRef.entity.symbolicRole;
                  symbolicRoles[role] = (symbolicRoles[role] || 0) + 1;
                }
              });
              Object.entries(symbolicRoles).forEach(([role, count]) => {
                labMessage += `• ${role}: ${count} agents\n`;
              });
              labMessage += `\n`;
              
              if (channel.culturalMetrics) {
                labMessage += `**Metrics:**\n`;
                labMessage += `• Rebellion Rate: ${(channel.culturalMetrics.rebellionRate * 100).toFixed(1)}%\n`;
                labMessage += `• Arrest Rate: ${(channel.culturalMetrics.arrestRate * 100).toFixed(1)}%\n`;
                labMessage += `• Movement/Tick: ${channel.culturalMetrics.movementCount || 0}\n\n`;
              }
              
              // Show sample LEGOS entities
              labMessage += `**Sample LEGOS Entities:**\n`;
              let sampleCount = 0;
              for (let [key, agent] of Object.entries(channel.culturalAgents)) {
                if (sampleCount >= 3) break;
                const entity = agent.legosCellRef?.entity;
                if (entity && entity.name && entity.symbolicRole) {
                  labMessage += `• ${entity.name} (${entity.symbolicRole}) - ${agent.type}\n`;
                  sampleCount++;
                }
              }
              labMessage += `\n`;
            } else {
              labMessage += `No active simulation. Start one with:\n\`/cultural spawn [scene]\`\n\n`;
            }
            
            labMessage += `**Theoretical Frameworks:**\n`;
            labMessage += `• Sahlins (Symbolic) → \`/structural\`\n`;
            labMessage += `• Obeyesekere (Pragmatic) → \`/pragmatic\`\n`;
            labMessage += `• Geertz (Reflexive) → \`/reflexive\`\n\n`;
            
            labMessage += `**ABM Frameworks:**\n`;
            labMessage += `• \`/bdi\` - Belief-Desire-Intention agents (Bratman)\n`;
            labMessage += `• \`/epstein\` - Civil Violence Model (2002)\n`;
            labMessage += `• \`/rebeland\` - MASON political insurgency\n`;
            labMessage += `• \`/iruba\` - Counterinsurgency operations\n`;
            labMessage += `• \`/ccim\` - Cross-cultural interaction\n`;
            labMessage += `• \`/axelrod\` - Cultural dissemination\n`;
            labMessage += `• \`/schelling\` - Segregation dynamics\n\n`;
            
            labMessage += `**Experiments:**\n`;
            labMessage += `• "Set legitimacy to 10%" - Crisis threshold\n`;
            labMessage += `• "Add 10 rebels" - Collective action\n`;
            labMessage += `• "Crackdown" - Legitimacy erosion\n`;
            labMessage += `• "Uprising" - Symbolic collapse\n`;
            labMessage += `• Switch frameworks mid-simulation to compare\n`;
            
            addMessageToChannel(channel, 'system', labMessage);
            return;
          }
          
          // Initialize or switch cultural mode
          if (!channel.culturalParams) {
            // First time: seed parameters from prompt
            channel.culturalParams = seedCulturalParams(promptText || value);
            
            // Generate scene ontology and override parameters
            const ontology = generateSceneOntology(channel);
            if (ontology.derivedParams) {
              channel.culturalParams.pragmatic.legitimacy = ontology.derivedParams.legitimacy;
              channel.culturalParams.pragmatic.copEffectiveness = ontology.derivedParams.copEffectiveness;
              console.log('[ONTOLOGY] Overriding parameters from scene:', ontology.derivedParams);
            }
            
            initCulturalAgents(channel, 0.75);
            channel.culturalTick = 0;
            channel.sceneOntology = ontology;
            
            addMessageToChannel(channel, 'system', 
              `◉ Cultural engine initialized in **${mode}** mode.\n` +
              `Scene ontology: ${ontology.entities.length} entities, ${ontology.authorities.length} authorities, ${ontology.conflicts.length} conflicts.\n` +
              `Derived legitimacy: ${ontology.derivedParams.legitimacy.toFixed(2)}, cop effectiveness: ${ontology.derivedParams.copEffectiveness.toFixed(2)}.\n` +
              `Agents spawned: ${Object.keys(channel.culturalAgents).length}/81 cells.`
            );
          } else {
            // Switching modes
            addMessageToChannel(channel, 'system', `◎ Switched to **${mode}** layer.`);
          }
          
          // Start simulation
          channel.culturalAnimating = true;
          renderChannelGrid(channel); // Show LEGOS entities
          renderCulturalGrid(channel); // Add cultural visual enhancements
          tickCulturalSimulation(channel);
          persistState();
          return;
        }
        
        // NATURAL LANGUAGE PARSING for active cultural simulation
        if (channel.culturalMode && channel.culturalAnimating) {
          // Parse natural language commands during active simulation
          const lowerValue = value.toLowerCase();
          
          // Spawn rebels pattern
          const spawnRebelMatch = lowerValue.match(/(?:add|spawn|create)\s+(\d+)\s+rebels?/);
          if (spawnRebelMatch) {
            const count = parseInt(spawnRebelMatch[1]);
            addMessageToChannel(channel, 'user', value);
            textarea.value = '';
            textarea.style.height = 'auto';
            
            // Execute spawn-rebels logic
            let spawned = 0;
            for (let y = 0; y < 9 && spawned < count; y++) {
              for (let x = 0; x < 9 && spawned < count; x++) {
                if (!channel.grid[y][x]) {
                  const id = `cultural-rebel-spawn-${Date.now()}-${spawned}`;
                  const entity = {
                    id, name: `Rebel ${spawned + 1}`, type: 'Goal', culturalType: 'rebel',
                    culturalBeliefs: { utility: 0.3, symbolic: Math.random(), reflexive: Math.random() },
                    culturalTraits: { hardship: 0.9, riskAversion: 0.2, social: 0.8 },
                    perspective: 'A newly radicalized rebel joining the uprising.'
                  };
                  channel.grid[y][x] = { id, type: 'Goal', symbol: '▲', label: entity.name, entity };
                  channel.culturalAgents[`${x}_${y}`] = {
                    type: 'rebel', legosCellRef: channel.grid[y][x], beliefs: entity.culturalBeliefs,
                    traits: entity.culturalTraits, energy: 1.0, fear: 0.5, perceivedRisk: 0, memory: []
                  };
                  logCellEvent(channel, x, y, `Rebel spawned: "${value}"`);
                  spawned++;
                }
              }
            }
            addMessageToChannel(channel, 'system', `🔥 Spawned ${spawned} rebels in response to: "${value}"`);
            renderChannelGrid(channel);
            renderCulturalGrid(channel);
            persistState();
            return;
          }
          
          // Spawn cops pattern
          const spawnCopMatch = lowerValue.match(/(?:add|spawn|deploy|send)\s+(\d+)\s+(?:cops?|police|officers?)/);
          if (spawnCopMatch) {
            const count = parseInt(spawnCopMatch[1]);
            addMessageToChannel(channel, 'user', value);
            textarea.value = '';
            textarea.style.height = 'auto';
            
            let spawned = 0;
            for (let y = 0; y < 9 && spawned < count; y++) {
              for (let x = 0; x < 9 && spawned < count; x++) {
                if (!channel.grid[y][x]) {
                  const id = `cultural-cop-spawn-${Date.now()}-${spawned}`;
                  const entity = {
                    id, name: `Cop ${spawned + 1}`, type: 'Obstacle', culturalType: 'cop',
                    culturalBeliefs: { utility: 0.9, symbolic: Math.random(), reflexive: Math.random() },
                    culturalTraits: { hardship: 0.1, riskAversion: 0.2, social: 0.7 },
                    perspective: 'A reinforcement cop deployed to restore order.'
                  };
                  channel.grid[y][x] = { id, type: 'Obstacle', symbol: '◆', label: entity.name, entity };
                  channel.culturalAgents[`${x}_${y}`] = {
                    type: 'cop', legosCellRef: channel.grid[y][x], beliefs: entity.culturalBeliefs,
                    traits: entity.culturalTraits, energy: 1.0, fear: 0, perceivedRisk: 0, memory: []
                  };
                  logCellEvent(channel, x, y, `Cop deployed: "${value}"`);
                  spawned++;
                }
              }
            }
            addMessageToChannel(channel, 'system', `👮 Deployed ${spawned} cops in response to: "${value}"`);
            renderChannelGrid(channel);
            renderCulturalGrid(channel);
            persistState();
            return;
          }
          
          // Legitimacy adjustment pattern
          const legitMatch = lowerValue.match(/(?:set|change|increase|decrease|adjust)\s+(?:legitimacy|authority|government)\s+(?:to\s+)?(\d+)%?/);
          if (legitMatch) {
            const percent = parseInt(legitMatch[1]);
            const newLegitimacy = percent / 100;
            
            addMessageToChannel(channel, 'user', value);
            textarea.value = '';
            textarea.style.height = 'auto';
            
            if (newLegitimacy >= 0 && newLegitimacy <= 1) {
              channel.culturalParams.pragmatic.legitimacy = newLegitimacy;
              addMessageToChannel(channel, 'system', `📊 Legitimacy set to ${percent}% in response to: "${value}"`);
              persistState();
            } else {
              addMessageToChannel(channel, 'system', '⚠️ Legitimacy must be 0-100%');
            }
            return;
          }
          
          // Crackdown pattern
          if (lowerValue.match(/crackdown|crack down|suppress|repress|violent response/)) {
            addMessageToChannel(channel, 'user', value);
            textarea.value = '';
            textarea.style.height = 'auto';
            
            channel.culturalParams.pragmatic.copEffectiveness *= 1.5;
            channel.culturalParams.pragmatic.legitimacy *= 0.7;
            addMessageToChannel(channel, 'system', 
              `🚨 CRACKDOWN in response to: "${value}"\n` +
              `Cop effectiveness +50%, Legitimacy -30%. Fear spreads...`
            );
            persistState();
            return;
          }
          
          // Uprising pattern
          if (lowerValue.match(/uprising|revolt|revolution|radicali[sz]e|protest wave/)) {
            addMessageToChannel(channel, 'user', value);
            textarea.value = '';
            textarea.style.height = 'auto';
            
            channel.culturalParams.pragmatic.legitimacy *= 0.5;
            Object.values(channel.culturalAgents).forEach(agent => {
              if (agent.type === 'citizen') {
                agent.traits.hardship = Math.min(1, agent.traits.hardship + 0.3);
              }
            });
            addMessageToChannel(channel, 'system',
              `⚡ UPRISING in response to: "${value}"\n` +
              `Citizen hardship +30%, Legitimacy halved. Revolution stirs...`
            );
            persistState();
            return;
          }
          
          // Pause/stop pattern
          if (lowerValue.match(/^(pause|stop|halt|freeze)$/)) {
            addMessageToChannel(channel, 'user', value);
            textarea.value = '';
            textarea.style.height = 'auto';
            
            channel.culturalAnimating = false;
            addMessageToChannel(channel, 'system', `⏸️ Simulation paused in response to: "${value}"`);
            persistState();
            return;
          }
          
          // Resume pattern
          if (lowerValue.match(/^(resume|continue|play|start)$/)) {
            addMessageToChannel(channel, 'user', value);
            textarea.value = '';
            textarea.style.height = 'auto';
            
            channel.culturalAnimating = true;
            tickCulturalSimulation(channel);
            addMessageToChannel(channel, 'system', `▶️ Simulation resumed in response to: "${value}"`);
            persistState();
            return;
          }
          
          // If no pattern matched, show helpful message
          addMessageToChannel(channel, 'user', value);
          textarea.value = '';
          textarea.style.height = 'auto';
          addMessageToChannel(channel, 'system', 
            `💬 I understood: "${value}"\n\n` +
            `During cultural simulation, try:\n` +
            `• "Add 5 rebels" - Spawn rebel agents\n` +
            `• "Deploy 3 cops" - Add police\n` +
            `• "Set legitimacy to 30%" - Adjust government legitimacy\n` +
            `• "Crackdown" - Trigger police crackdown\n` +
            `• "Uprising" - Trigger mass radicalization\n` +
            `• "Pause" / "Resume" - Control animation\n\n` +
            `Or type \`/cultural help\` for all commands.`
          );
          return;
        }
        
        // Normal flow for non-cultural commands
        addMessageToChannel(channel, 'user', value);
        textarea.value = '';
        textarea.style.height = 'auto';
        if (!appState.apiKey) {
          addMessageToChannel(channel, 'system', 'API key required for auto scene assembly. Store one via ◎.');
          persistState();
          return;
        }
        composeScene(channel, value);
      });

      inputWrapper.appendChild(textarea);
      inputWrapper.appendChild(sendBtn);
      inputSection.appendChild(inputWrapper);
      
      // Per-channel footer removed - now using global footer

      // Click anywhere in column to focus it
      column.addEventListener('click', (e) => {
        // Don't interfere with button clicks
        if (!e.target.closest('button, input, textarea, .grid-cell')) {
          focusChannel(channel.id);
        }
      });
      
      chatSection.appendChild(chatStream);
      chatSection.appendChild(inputSection);

      // Add resize bar between grid and chat
      const resizeBar = document.createElement('div');
      resizeBar.className = 'resize-bar';
      
      let isResizing = false;
      let startY = 0;
      let startHeight = 0;
      
      // Mouse events
      resizeBar.addEventListener('mousedown', (e) => {
        isResizing = true;
        startY = e.clientY;
        startHeight = gridSection.offsetHeight;
        document.body.style.cursor = 'row-resize';
        e.preventDefault();
      });
      
      document.addEventListener('mousemove', (e) => {
        if (!isResizing) return;
        const deltaY = e.clientY - startY;
        let newHeight = startHeight + deltaY;
        
        // Clamp between 30vh and 70vh
        newHeight = Math.max(window.innerHeight * 0.3, Math.min(window.innerHeight * 0.7, newHeight));
        
        gridSection.style.height = newHeight + 'px';
        gridSection.style.flex = `0 0 ${newHeight}px`;
      });
      
      document.addEventListener('mouseup', () => {
        if (isResizing) {
          isResizing = false;
          document.body.style.cursor = '';
        }
      });
      
      // Touch events for mobile
      resizeBar.addEventListener('touchstart', (e) => {
        isResizing = true;
        startY = e.touches[0].clientY;
        startHeight = gridSection.offsetHeight;
        e.preventDefault();
      });
      
      document.addEventListener('touchmove', (e) => {
        if (!isResizing) return;
        const deltaY = e.touches[0].clientY - startY;
        let newHeight = startHeight + deltaY;
        
        // Clamp between 30vh and 70vh
        newHeight = Math.max(window.innerHeight * 0.3, Math.min(window.innerHeight * 0.7, newHeight));
        
        gridSection.style.height = newHeight + 'px';
        gridSection.style.flex = `0 0 ${newHeight}px`;
      }, { passive: false });
      
      document.addEventListener('touchend', () => {
        if (isResizing) {
          isResizing = false;
        }
      });
      
      body.appendChild(gridSection);
      body.appendChild(resizeBar);
      body.appendChild(chatSection);

      // Activate channel on any click within the column
      column.addEventListener('click', (e) => {
        // Don't interfere with button clicks
        if (e.target.closest('button')) return;
        focusChannel(channel.id);
      });
      
      // Also activate on chat interaction
      chatSection.addEventListener('click', () => {
        focusChannel(channel.id);
      });

      column.appendChild(header);
      column.appendChild(body);
      scroller.appendChild(column);

      channel.dom = {
        column,
        header,
        nameEl: name,
        lineageEl: lineage,
        gridEl: grid,
        gridWrapper,
        gridTitle,
        messageList,
        messageDotRail,
        input: textarea,
        sendBtn,
        channelRail: channelNumberRail
      };

      refreshChannelHeader(channel);
      styleChannelControls(channel);
      renderChannel(channel);
    }

    function refreshChannelHeader(channel) {
      if (!channel || !channel.dom) return;
      const { nameEl, lineageEl, gridTitle } = channel.dom;
      if (nameEl) nameEl.textContent = channel.name;
      if (lineageEl) {
        if (channel.parentChannelId) {
          const parent = channelMap.get(channel.parentChannelId);
          const parentHandle = sanitizeHandle(parent?.name || 'PARENT', 'PARENT');
          lineageEl.textContent = `FORK · ${parentHandle}`;
          lineageEl.style.display = '';
        } else {
          lineageEl.textContent = '';
          lineageEl.style.display = 'none';
        }
      }
      if (gridTitle) {
        gridTitle.textContent = formatChannelHeadline(channel);
      }
    }

    function styleChannelControls(channel) {
      if (!channel || !channel.dom) return;
      const color = channel.channelColor || getComputedStyle(document.body).getPropertyValue('--accent');
      const { sendBtn, header, column } = channel.dom;
      const isActive = channel.id === appState.currentChannelId;
      
      // Mark inactive channels and set color variable
      if (column) {
        if (isActive) {
          column.classList.remove('inactive');
        } else {
          column.classList.add('inactive');
        }
        // Set CSS variable for channel color
        column.style.setProperty('--channel-color', color);
      }
      
      // Apply channel color to all buttons in header and footer
      const channelBtns = column?.querySelectorAll('.channel-btn');
      channelBtns?.forEach(btn => {
        btn.style.borderColor = color;
        btn.style.color = color;
      });
      
      // Send button gets full color
      if (sendBtn) {
        sendBtn.textContent = '➜';
        sendBtn.dataset.channelId = channel.id;
        sendBtn.style.background = color;
        sendBtn.style.color = 'var(--bg)';
        sendBtn.style.borderColor = color;
      }
      
      // Header and footer borders
      if (header) {
        header.style.borderColor = color;
      }
      
      const footer = column?.querySelector('.channel-footer');
      if (footer) {
        footer.style.borderColor = color;
      }
      
      
      // Grid cells get subtle accent
      const gridCells = column?.querySelectorAll('.grid-cell.occupied');
      gridCells?.forEach(cell => {
        cell.style.borderColor = color;
      });
      
      // Channel numbers in rail
      const channelNumbers = document.querySelectorAll('.channel-number');
      channelNumbers.forEach(num => {
        if (num.dataset.channelId === channel.id) {
          num.style.borderColor = color;
          num.style.background = color;
          num.style.color = 'var(--bg)';
          num.style.boxShadow = `0 0 12px ${color}40`;
        } else {
          // Grey out other channels
          num.style.opacity = '0.4';
        }
      });
      
      // Message dots get channel color
      const messageDots = column?.querySelectorAll('.message-dot');
      messageDots?.forEach(dot => {
        dot.style.color = color;
        dot.style.borderColor = color;
      });
    }

    function formatChannelHeadline(channel) {
      if (!channel) return '';
      const parts = [];
      parts.push(channel.symbolicId);
      const nameHandle = sanitizeHandle(channel.name, channel.symbolicId);
      if (nameHandle !== channel.symbolicId) {
        parts.push(nameHandle);
      }
      if (channel.forkPoint && channel.forkPoint.mode) {
        let label = channel.forkPoint.mode.toUpperCase();
        if (channel.forkPoint.mode === 'perspective') {
          label = 'POV';
        }
        parts.push(sanitizeHandle(label, 'FORK'));
      }
      if (channel.forkPoint && channel.forkPoint.coordinates) {
        const { x, y } = channel.forkPoint.coordinates;
        parts.push(sanitizeHandle(`CELL ${x}${y}`, 'CELL'));
      }
      if (channel.ringBinding) {
        const entry = ringMemory.entries.find(e => e.id === channel.ringBinding);
        if (entry && entry.symbol) {
          parts.push(entry.symbol);
        }
      }
      return parts
        .filter(Boolean)
        .map(part => sanitizeHandle(part, part))
        .join(' • ');
    }

    function renderChannel(channel) {
      refreshChannelHeader(channel);
      styleChannelControls(channel);
      renderChannelGrid(channel);
      renderChannelMessages(channel);
      renderTetradPanel(channel);
      renderTimeline();
      if (snapshotOverlayChannel === channel) {
        renderSnapshotOverlay();
      }
    }

    function renderGrid(channel) {
      const grid = channel.dom?.gridEl;
      if (!grid) return;
      grid.innerHTML = '';
      
      // Detect resonance fields (nearby entities)
      const entityPositions = [];
      channel.grid.forEach((row, y) => {
        row.forEach((cell, x) => {
          if (cell && cell.type === 'Entity') {
            entityPositions.push({ x, y });
          }
        });
      });
      channel.grid.forEach((row, y) => {
        row.forEach((cell, x) => {
          const div = document.createElement('div');
          div.className = 'grid-cell';
          
          // Check if this cell is in resonance field
          const isNearEntity = entityPositions.some(pos => {
            const distance = Math.abs(pos.x - x) + Math.abs(pos.y - y);
            return distance <= 2 && distance > 0;
          });
          
          if (isNearEntity && (!cell || cell.type !== 'Entity')) {
            div.classList.add('resonance-field');
          }
          
          if (cell) {
            div.classList.add('occupied');
            const palette = blockPalette.find(p => p.type === cell.type);
            div.textContent = cell.symbol || '?';
            div.style.color = palette?.color || 'var(--text)';
            
            // Rich tooltip
            let tooltip = `${cell.type}: ${cell.label || 'Unnamed'}`;
            if (cell.entity?.description) {
              tooltip += `\n${cell.entity.description.substring(0, 80)}${cell.entity.description.length > 80 ? '...' : ''}`;
            }
            if (cell.entity?.relations?.length) {
              tooltip += `\nRelations: ${cell.entity.relations.length}`;
            }
            const cellLogs = channel.cells[`${x},${y}`] || [];
            if (cellLogs.length) {
              tooltip += `\nEvents: ${cellLogs.length}`;
            }
            div.title = tooltip;
            
            if (cell.label) {
              // Add full name for hover tooltip
              div.setAttribute('data-full-name', cell.label.toUpperCase());
              
              const label = document.createElement('div');
              label.className = 'grid-label';
              // Truncate to 8 chars for consistent sizing
              const truncatedLabel = cell.label.length > 8 ? cell.label.slice(0, 7) + '…' : cell.label;
              label.textContent = truncatedLabel.toUpperCase();
              
              // Calculate luminance for contrast
              if (palette?.color) {
                const color = palette.color;
                let r, g, b;
                
                // Parse hex color
                if (color.startsWith('#')) {
                  const hex = color.slice(1);
                  r = parseInt(hex.slice(0, 2), 16);
                  g = parseInt(hex.slice(2, 4), 16);
                  b = parseInt(hex.slice(4, 6), 16);
                } else if (color.startsWith('rgb')) {
                  const match = color.match(/\d+/g);
                  if (match) {
                    [r, g, b] = match.map(Number);
                  }
                }
                
                if (r !== undefined && g !== undefined && b !== undefined) {
                  // Calculate relative luminance
                  const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
                  
                  // If bright color, use dark text
                  if (luminance > 0.6) {
                    label.classList.add('dark-text');
                  } else {
                    label.classList.add('light-text');
                  }
                }
              }
              
              div.appendChild(label);
            }
            div.dataset.cellType = cell.type;
          }
          div.dataset.x = x;
          div.dataset.y = y;
          div.addEventListener('click', () => {
            focusChannel(channel.id);
            openCellOverlay(channel, x, y);
          });
          grid.appendChild(div);
        });
      });
    }

    function renderChannelGrid(channel) {
      const grid = channel.dom?.gridEl;
      if (!grid) return;
      grid.innerHTML = '';
      channel.grid.forEach((row, y) => {
        row.forEach((cell, x) => {
          const div = document.createElement('div');
          div.className = 'grid-cell';
        if (cell) {
          div.classList.add('occupied');
          const palette = blockPalette.find(p => p.type === cell.type);
          div.textContent = cell.symbol || palette?.symbol || cell.type[0];
          if (cell.label) {
            const label = document.createElement('div');
            label.className = 'grid-label';
            // Truncate to 8 chars for consistent sizing
            const truncatedLabel = cell.label.length > 8 ? cell.label.slice(0, 7) + '…' : cell.label;
            label.textContent = truncatedLabel.toUpperCase();
            
            // Calculate luminance for contrast
            if (palette?.color) {
              const color = palette.color;
              let r, g, b;
              
              if (color.startsWith('#')) {
                const hex = color.slice(1);
                r = parseInt(hex.slice(0, 2), 16);
                g = parseInt(hex.slice(2, 4), 16);
                b = parseInt(hex.slice(4, 6), 16);
              } else if (color.startsWith('rgb')) {
                const match = color.match(/\d+/g);
                if (match) {
                  [r, g, b] = match.map(Number);
                }
              }
              
              if (r !== undefined && g !== undefined && b !== undefined) {
                const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
                if (luminance > 0.6) {
                  label.classList.add('dark-text');
                } else {
                  label.classList.add('light-text');
                }
              }
            }
            
            div.appendChild(label);
          }
          div.dataset.cellType = cell.type;
          
          // Add hover tooltip with full name
          if (cell.label) {
            div.title = `${cell.label} (${cell.type})\nClick for perspective`;
          } else if (cell.type) {
            div.title = `${cell.type}\nClick for details`;
          }
        }
          div.dataset.x = x;
          div.dataset.y = y;
          div.addEventListener('click', () => {
            focusChannel(channel.id);
            openCellOverlay(channel, x, y);
          });
          grid.appendChild(div);
        });
      });
    }

    function renderChannelMessages(channel) {
      const list = channel.dom && channel.dom.messageList;
      const dotRail = channel.dom && channel.dom.messageDotRail;
      if (!list) return;
      list.innerHTML = '';
      if (dotRail) dotRail.innerHTML = '';
      const lastAssistantId = [...channel.messages].reverse().find(msg => msg.role === 'assistant')?.id || null;
      const totalMessages = channel.messages.length;
      channel.messages.forEach((msg, idx) => {
        const item = document.createElement('div');
        item.className = `message ${msg.role}`;
        item.dataset.messageId = msg.id;

        const isRecent = idx >= totalMessages - 3;
        if (msg.autoCollapse || (!isRecent && msg.role !== 'user')) {
          item.classList.add('collapsed');
        }

        if (channel.forkPoint?.messageId && String(channel.forkPoint.messageId) === String(msg.id)) {
          item.classList.add('fork-origin');
        }

        const header = document.createElement('div');
        header.className = 'message-header';
        
        // Dual-dot visualization for forks (git-style)
        if (channel.parentChannelId) {
          const parentChannel = channelMap.get(channel.parentChannelId);
          if (parentChannel) {
            const parentDot = document.createElement('span');
            parentDot.className = 'message-color-dot parent-dot';
            parentDot.style.color = parentChannel.channelColor;
            parentDot.textContent = '●';
            parentDot.title = `Parent: ${parentChannel.name}`;
            header.appendChild(parentDot);
          }
        }
        
        const colorDot = document.createElement('span');
        colorDot.className = 'message-color-dot';
        if (msg.role === 'user') {
          colorDot.style.color = lightenColor(channel.channelColor, 0.25);
        } else if (msg.role === 'system') {
          colorDot.style.color = lightenColor(channel.channelColor, -0.3);
          colorDot.style.opacity = '0.6';
        } else {
          colorDot.style.color = channel.channelColor;
        }
        colorDot.textContent = '●';
        const origin = msg.fromChannel ? ` ← ${msg.fromChannel}` : '';
        header.appendChild(colorDot);
        const headerText = document.createElement('span');
        const roleDisplay = msg.role === 'tetrad' ? 'TETRAD OPTIONS' : msg.role.toUpperCase();
        headerText.textContent = `${msg.id} · ${roleDisplay}${origin}`;
        header.appendChild(headerText);
        
        // Add ring memory indicator if this message is bound
        if (channel.ringBinding) {
          const ringEntry = ringMemory.entries.find(e => e.id === channel.ringBinding);
          if (ringEntry && msg.role === 'assistant') {
            const ringIndicator = document.createElement('span');
            ringIndicator.className = 'ring-indicator';
            ringIndicator.textContent = '⊚';
            ringIndicator.title = `Bound to ring: ${ringEntry.symbol}`;
            ringIndicator.style.color = channel.channelColor;
            ringIndicator.style.marginLeft = 'auto';
            header.appendChild(ringIndicator);
          }
        }
        
        item.appendChild(header);

        const preview = document.createElement('div');
        preview.className = 'message-preview';
        const msgText = msg.text || '';
        if (msg.role === 'tetrad') {
          preview.textContent = '✨ Tetrad Options Available';
        } else {
          preview.textContent = msgText.split('\n')[0].slice(0, 60) + (msgText.length > 60 ? '…' : '');
        }
        item.appendChild(preview);

        const body = document.createElement('div');
        body.className = 'message-body';
        
        // Special rendering for tetrad messages
        if (msg.role === 'tetrad' && msg.tetradData) {
          // Add reveal animation if this is the latest tetrad
          if (idx === totalMessages - 1) {
            item.style.animation = 'pulse 0.6s ease-in-out';
            item.style.boxShadow = '0 0 20px var(--accent-glow)';
            setTimeout(() => {
              item.style.animation = '';
              item.style.boxShadow = '';
            }, 600);
          }
          
          const tetradMap = [
            { key: 'enhance', icon: '▲', label: 'ENHANCE' },
            { key: 'reverse', icon: '⇄', label: 'REVERSE' },
            { key: 'retrieve', icon: '↺', label: 'RETRIEVE' },
            { key: 'obsolesce', icon: '▼', label: 'OBSOLESCE' }
          ];
          
          tetradMap.forEach((mapping, tetradIdx) => {
            const entry = msg.tetradData[mapping.key];
            if (!entry) return;
            
            const optionDiv = document.createElement('div');
            optionDiv.style.cssText = `
              padding: 10px 12px;
              margin-bottom: 6px;
              border-left: 3px solid var(--accent);
              background: var(--panel-dark);
              transition: all 0.2s var(--transition);
              border-radius: 4px;
              display: flex;
              align-items: flex-start;
              gap: 10px;
              position: relative;
            `;
            
            // Stagger animation for latest tetrad
            if (idx === totalMessages - 1) {
              optionDiv.style.opacity = '0';
              optionDiv.style.transform = 'translateX(-20px)';
              setTimeout(() => {
                optionDiv.style.transition = 'all 0.4s cubic-bezier(0.4, 0, 0.2, 1)';
                optionDiv.style.opacity = '1';
                optionDiv.style.transform = 'translateX(0)';
              }, 100 + (tetradIdx * 100));
            }
            
            const contentDiv = document.createElement('div');
            contentDiv.style.cssText = `
              flex: 1;
              cursor: pointer;
            `;
            
            const optionHeader = document.createElement('div');
            optionHeader.style.cssText = `
              font-size: 10px;
              font-weight: 700;
              letter-spacing: 0.15em;
              color: var(--accent);
              margin-bottom: 4px;
            `;
            optionHeader.textContent = `${mapping.icon} ${mapping.label}`;
            
            const optionText = document.createElement('div');
            optionText.style.cssText = `
              font-size: 9px;
              line-height: 1.5;
              color: var(--text);
            `;
            optionText.textContent = entry.text;
            
            contentDiv.appendChild(optionHeader);
            contentDiv.appendChild(optionText);
            
            // Send button (red ball)
            const sendBtn = document.createElement('button');
            sendBtn.style.cssText = `
              width: 32px;
              height: 32px;
              border-radius: 50%;
              background: linear-gradient(135deg, #f87171, #dc2626);
              border: 2px solid #991b1b;
              cursor: pointer;
              display: flex;
              align-items: center;
              justify-content: center;
              font-size: 16px;
              transition: all 0.2s;
              box-shadow: 0 2px 8px rgba(248, 113, 113, 0.4);
              flex-shrink: 0;
            `;
            sendBtn.textContent = '→';
            sendBtn.title = 'Send to input';
            
            optionDiv.appendChild(contentDiv);
            optionDiv.appendChild(sendBtn);
            
            contentDiv.addEventListener('mouseenter', () => {
              optionDiv.style.background = 'var(--accent-soft)';
              optionDiv.style.transform = 'translateX(4px)';
            });
            
            contentDiv.addEventListener('mouseleave', () => {
              optionDiv.style.background = 'var(--panel-dark)';
              optionDiv.style.transform = 'translateX(0)';
            });
            
            sendBtn.addEventListener('mouseenter', () => {
              sendBtn.style.transform = 'scale(1.1)';
              sendBtn.style.boxShadow = '0 4px 16px rgba(248, 113, 113, 0.6)';
            });
            
            sendBtn.addEventListener('mouseleave', () => {
              sendBtn.style.transform = 'scale(1)';
              sendBtn.style.boxShadow = '0 2px 8px rgba(248, 113, 113, 0.4)';
            });
            
            // Click handler for send button
            sendBtn.addEventListener('click', (e) => {
              e.stopPropagation();
              const followUpText = `Follow ${mapping.label.toLowerCase()} path: ${entry.text}`;
              channel.dom.input.value = followUpText;
              channel.dom.input.focus();
              
              // Animate the send
              sendBtn.style.transform = 'scale(0.8)';
              sendBtn.style.opacity = '0.5';
              setTimeout(() => {
                sendBtn.style.transform = 'scale(1)';
                sendBtn.style.opacity = '1';
              }, 200);
              
              // Flash effect on option
              optionDiv.style.background = 'var(--accent)';
              optionDiv.style.boxShadow = '0 0 20px var(--accent-glow)';
              setTimeout(() => {
                optionDiv.style.background = 'var(--panel-dark)';
                optionDiv.style.boxShadow = 'none';
              }, 300);
            });
            
            // Click content to preview/read
            contentDiv.addEventListener('click', () => {
              optionDiv.style.background = 'var(--accent-soft)';
            });
            
            body.appendChild(optionDiv);
          });
        } else {
          body.textContent = msgText;
        }
        
        item.appendChild(body);

        if (dotRail) {
          const dot = document.createElement('button');
          dot.className = 'message-dot';
          dot.dataset.messageId = msg.id;
          dot.dataset.role = msg.role;
          dot.dataset.index = idx + 1;
          dot.classList.add(msg.role);
          dot.textContent = String(idx + 1);
          
          // Dual-border for forked channels (git graph style)
          if (channel.parentChannelId) {
            const parentChannel = channelMap.get(channel.parentChannelId);
            if (parentChannel) {
              dot.classList.add('forked-dot');
              dot.style.borderColor = parentChannel.channelColor;
              dot.style.boxShadow = `0 0 0 3px ${channel.channelColor}, 0 0 12px ${channel.channelColor}`;
              dot.title = `${msg.id} · ${msg.role.toUpperCase()} [Fork from ${parentChannel.name}]`;
            }
          } else {
            dot.title = `${msg.id} · ${msg.role.toUpperCase()}`;
          }
          
          if (msg.role === 'user') {
            dot.style.color = lightenColor(channel.channelColor, 0.25);
            dot.style.backgroundColor = lightenColor(channel.channelColor, 0.08);
          } else if (msg.role === 'system') {
            dot.style.color = lightenColor(channel.channelColor, -0.3);
            dot.style.backgroundColor = lightenColor(channel.channelColor, -0.1);
          } else {
            dot.style.color = channel.channelColor;
            dot.style.backgroundColor = lightenColor(channel.channelColor, 0.15);
          }
          if (channel.forkPoint?.messageId && String(channel.forkPoint.messageId) === String(msg.id)) {
            dot.classList.add('fork-origin');
          }
          dot.addEventListener('click', () => {
            activateMessageDot(channel, msg.id);
            item.classList.remove('collapsed');
            item.classList.add('active');
            item.scrollIntoView({ behavior: 'smooth', block: 'center' });
          });
          dotRail.appendChild(dot);
          if (idx === channel.messages.length - 1) {
            dot.classList.add('active');
          }
        }

        if (msg.role === 'assistant') {
          item.addEventListener('click', (event) => {
            if (event.target.closest('.message-actions')) return;
            toggleMessageActions(channel, msg, item);
            document.querySelectorAll(`[data-channel-id="${channel.id}"] .message`).forEach(el => el.classList.remove('active'));
            item.classList.add('active');
            activateMessageDot(channel, msg.id);
          });
          if (msg.id === lastAssistantId && channel.tetrad && Object.keys(channel.tetrad).length) {
            const chips = createTetradChips(channel);
            if (chips) body.appendChild(chips);
          }
        } else {
          item.addEventListener('click', () => {
            item.classList.toggle('collapsed');
            document.querySelectorAll(`[data-channel-id="${channel.id}"] .message`).forEach(el => el.classList.remove('active'));
            if (!item.classList.contains('collapsed')) {
              item.classList.add('active');
              activateMessageDot(channel, msg.id);
            } else if (channel.messages.length) {
              const latest = channel.messages[channel.messages.length - 1];
              if (latest) activateMessageDot(channel, latest.id);
            }
          });
        }

        list.appendChild(item);
      });
      list.scrollTo({ top: list.scrollHeight, behavior: 'smooth' });
      if (channel.messages.length) {
        activateMessageDot(channel, channel.messages[channel.messages.length - 1].id);
      }
    }

    function activateMessageDot(channel, messageId) {
      if (!channel || !channel.dom) return;
      const targetId = String(messageId);
      const { messageDotRail, messageList } = channel.dom;
      if (messageDotRail) {
        messageDotRail.querySelectorAll('.message-dot').forEach(dot => {
          dot.classList.toggle('active', dot.dataset.messageId === targetId);
        });
      }
      if (messageList) {
        messageList.querySelectorAll('.message').forEach(msgEl => {
          if (msgEl.dataset.messageId === targetId) {
            msgEl.classList.add('active');
          } else {
            msgEl.classList.remove('active');
          }
        });
      }
    }

    function toggleMessageActions(channel, message, element) {
      closeAllMenus();
      let menu = element.querySelector('.message-actions');
      if (!menu) {
        menu = document.createElement('div');
        menu.className = 'message-actions';
        
        const closeBtn = document.createElement('button');
        closeBtn.className = 'message-action-close';
        closeBtn.textContent = '✕';
        closeBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          closeAllMenus();
        });
        menu.appendChild(closeBtn);
        
        const options = buildMessageOptions(channel, message);
        options.forEach(opt => menu.appendChild(opt));
        element.appendChild(menu);
      }
      menu.classList.toggle('active');
    }

    function closeAllMenus() {
      document.querySelectorAll('.message-actions.active').forEach(menu => menu.classList.remove('active'));
    }
    
    function sendPerspectiveToChat(channel, text) {
      if (!channel || !channel.dom) return;
      const textarea = channel.dom.input;
      if (textarea) {
        // Add to existing text or set new text
        const currentText = textarea.value.trim();
        textarea.value = currentText ? `${currentText}\n\n${text}` : text;
        textarea.style.height = 'auto';
        textarea.style.height = textarea.scrollHeight + 'px';
        textarea.focus();
        
        // Close perspective overlay
        document.getElementById('perspectiveOverlay').classList.remove('active');
        
        // Show feedback
        const feedback = document.createElement('div');
        feedback.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          background: var(--accent);
          color: var(--bg);
          padding: 12px 20px;
          border-radius: 4px;
          font-size: 11px;
          font-weight: 700;
          letter-spacing: 0.1em;
          z-index: 10000;
          box-shadow: 0 4px 12px rgba(0,0,0,0.3);
          animation: slideInRight 0.3s ease;
        `;
        feedback.textContent = 'SENT TO CHAT';
        document.body.appendChild(feedback);
        setTimeout(() => {
          feedback.style.opacity = '0';
          feedback.style.transform = 'translateX(20px)';
          setTimeout(() => feedback.remove(), 300);
        }, 1500);
      }
    }

    function buildMessageOptions(channel, message) {
      // Auto-generate tetrad if missing and scene exists
      if (channel.lastScene && !channel.tetrad && !channel.pendingTetrad && appState.apiKey) {
        regenerateTetrad(channel);
      }
      
      const fragments = [];
      const addOption = (label, handler, enabled = true) => {
        const div = document.createElement('div');
        div.className = 'message-action';
        div.textContent = label;
        if (enabled) {
          div.addEventListener('click', (e) => {
            e.stopPropagation();
            closeAllMenus();
            handler();
          });
        } else {
          div.classList.add('disabled');
        }
        fragments.push(div);
      };

      addOption('↔ FORK: CONTINUE', () => forkChannel(channel, message, 'continue'));

      ['enhance', 'reverse', 'retrieve', 'obsolesce'].forEach(key => {
        const entry = channel.tetrad?.[key];
        const label = `⋔ FORK: ${key.toUpperCase()}`;
        // Always enable if we have a scene (tetrad will generate)
        const enabled = Boolean(channel.lastScene);
        addOption(label, () => {
          if (!entry?.text) {
            // If no tetrad yet, generate it first
            if (channel.lastScene && !channel.pendingTetrad) {
              regenerateTetrad(channel).then(() => {
                // Try to fork again after generation
                const newEntry = channel.tetrad?.[key];
                if (newEntry?.text) {
                  forkChannel(channel, message, key);
                }
              });
            }
            return;
          }
          forkChannel(channel, message, key);
        }, enabled);
      });

      addOption('◎ FORK: PERSPECTIVE', () => forkChannel(channel, message, 'perspective'));
      addOption('⧉ FORK: SNAPSHOT', () => forkChannel(channel, message, 'snapshot'));
      addOption('+ NEW BLANK CHANNEL', () => forkChannel(channel, message, 'blank'));

      const otherChannels = appState.channels.filter(ch => ch.id !== channel.id);
      if (otherChannels.length) {
        otherChannels.forEach(target => {
          addOption(`→ SEND TO ${target.name}`, () => routeMessage(channel, target, message));
        });
      }

      return fragments;
    }

    // Normalize tetrad data from any format to standard {enhance, reverse, retrieve, obsolesce}
    function normalizeTetradData(channel) {
      if (!channel.tetrad) return null;
      
      // Format 1: Direct object with keys {enhance: {...}, reverse: {...}, ...}
      if (typeof channel.tetrad === 'object' && !Array.isArray(channel.tetrad)) {
        if (channel.tetrad.enhance) return channel.tetrad; // ✅ Already correct!
        if (channel.tetrad.tetradEntries) return null; // ❌ Old format, ignore
        
        // Check if it's wrapped like {tetrad: {enhance: {...}}}
        if (channel.tetrad.tetrad && typeof channel.tetrad.tetrad === 'object') {
          return normalizeTetradData({tetrad: channel.tetrad.tetrad}); // Unwrap and retry
        }
      }
      
      // Format 2: tetrads array (get latest)
      if (channel.tetrads && Array.isArray(channel.tetrads) && channel.tetrads.length > 0) {
        const latest = channel.tetrads[channel.tetrads.length - 1];
        if (latest && latest.enhance) return latest;
      }
      
      // Format 3: tetrad as array with type property [{type: 'enhance', ...}, ...]
      if (Array.isArray(channel.tetrad) && channel.tetrad.length > 0) {
        const result = {};
        channel.tetrad.forEach(item => {
          if (item && item.type && item.text) {
            result[item.type] = {text: item.text, score: item.score || 0};
          }
        });
        if (Object.keys(result).length > 0) {
          console.log('[TETRAD] Converted array format:', result);
          return result; // ✅ Converted!
        }
      }
      
      console.log('[TETRAD] Unknown format:', channel.tetrad);
      return null;
    }
    
    // Create tetrad chips inline in message (like tet-chat.html)
    function createTetradChipsInline(channel) {
      const tetradData = normalizeTetradData(channel);
      if (!tetradData) return null;
      
      const container = document.createElement('div');
      container.className = 'tetrad-chips-inline';
      container.style.cssText = `
        margin-top: 12px;
        padding: 12px;
        background: rgba(0, 0, 0, 0.3);
        border-left: 3px solid var(--accent);
        border-radius: 4px;
      `;
      
      // Add header
      const header = document.createElement('div');
      header.style.cssText = `
        font-size: 9px;
        font-weight: 700;
        letter-spacing: 0.15em;
        color: var(--accent);
        margin-bottom: 8px;
        text-transform: uppercase;
      `;
      header.innerHTML = `
        <span>⋔ TETRAD OPTIONS — Click to use</span>
        <button id="tetrad-perspective-toggle-${channel.id}" style="
          margin-left: auto;
          padding: 4px 8px;
          font-size: 8px;
          background: ${channel.tetradPerspective ? 'var(--accent)' : 'var(--panel-dark)'};
          color: ${channel.tetradPerspective ? 'var(--bg)' : 'var(--text)'};
          border: 1px solid ${channel.tetradPerspective ? 'var(--accent)' : 'var(--border)'};
          border-radius: 3px;
          cursor: pointer;
          font-weight: 700;
          letter-spacing: 0.05em;
        ">
          ${channel.tetradPerspective ? '👁 ' + channel.tetradPerspective : '👁 SET PERSPECTIVE'}
        </button>
      `;
      
      // Add perspective toggle handler
      setTimeout(() => {
        const toggleBtn = document.getElementById(`tetrad-perspective-toggle-${channel.id}`);
        if (toggleBtn) {
          toggleBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            openPerspectiveSelector(channel);
          });
        }
      }, 0);
      
      container.appendChild(header);
      
      // Create chips container
      const chipsWrap = document.createElement('div');
      chipsWrap.style.cssText = `
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
      `;
      
      console.log('[TETRAD] Creating chips for channel:', channel.id, 'Data:', tetradData);
      
      const tetradMap = [
        { key: 'enhance', icon: '⋔', label: 'ENHANCE' },
        { key: 'reverse', icon: '⋔', label: 'REVERSE' },
        { key: 'retrieve', icon: '⋔', label: 'RETRIEVE' },
        { key: 'obsolesce', icon: '⋔', label: 'OBSOLESCE' }
      ];
      
      let hasChips = false;
      tetradMap.forEach(mapping => {
        const entry = tetradData[mapping.key];
        if (!entry || !entry.text) return;
        
        hasChips = true;
        const chip = document.createElement('div');
        chip.className = 'tetrad-chip-inline';
        chip.style.cssText = `
          flex: 1;
          min-width: 140px;
          padding: 8px 10px;
          background: var(--panel-dark);
          border: 1px solid var(--border);
          border-radius: 4px;
          cursor: pointer;
          transition: all 0.2s;
          display: flex;
          align-items: center;
          gap: 6px;
        `;
        
        const previewText = entry.text.substring(0, 50) + (entry.text.length > 50 ? '...' : '');
        chip.innerHTML = `
          <div style="display: flex; flex-direction: column; gap: 4px; width: 100%;">
            <div style="display: flex; align-items: center; gap: 6px;">
              <span style="font-size: 12px;">${mapping.icon}</span>
              <span style="font-size: 8px; font-weight: 700; text-transform: uppercase; opacity: 0.8; letter-spacing: 0.1em;">${mapping.label}</span>
              <span style="margin-left: auto; font-size: 8px; opacity: 0.6;">${entry.score || 0}</span>
            </div>
            <div style="font-size: 9px; opacity: 0.7; line-height: 1.3;">${previewText}</div>
          </div>
        `;
        chip.title = entry.text;
        
        chip.addEventListener('click', (e) => {
          e.stopPropagation();
          console.log('[TETRAD] Chip clicked:', mapping.key, entry.text);
          const textarea = channel.dom?.input;
          if (textarea) {
            textarea.value = entry.text;
            textarea.focus();
            textarea.style.height = 'auto';
            textarea.style.height = textarea.scrollHeight + 'px';
          }
        });
        
        chip.addEventListener('mouseenter', () => {
          chip.style.background = 'var(--accent)';
          chip.style.color = 'var(--bg)';
          chip.style.borderColor = 'var(--accent)';
        });
        
        chip.addEventListener('mouseleave', () => {
          chip.style.background = 'var(--panel-dark)';
          chip.style.color = '';
          chip.style.borderColor = 'var(--border)';
        });
        
        chipsWrap.appendChild(chip);
      });
      
      if (hasChips) {
        container.appendChild(chipsWrap);
        return container;
      }
      return null;
    }
    
    function createTetradChips(channel) {
      const tetradData = normalizeTetradData(channel);
      if (!tetradData) return null;
      
      const container = document.createElement('div');
      container.style.display = 'flex';
      container.style.flexWrap = 'wrap';
      container.style.gap = '6px';
      container.style.marginTop = '12px';
      ['enhance', 'reverse', 'retrieve', 'obsolesce'].forEach(key => {
        const entry = tetradData[key];
        if (!entry) return;
        const chip = document.createElement('button');
        chip.className = `tetrad-chip ${key}`;
        chip.textContent = key.toUpperCase();
        chip.title = entry.text;
        chip.addEventListener('click', (event) => {
          event.stopPropagation();
          chip.style.transform = 'scale(0.95)';
          setTimeout(() => chip.style.transform = '', 100);
          addMessageToChannel(channel, 'user', entry.text);
          if (appState.apiKey) {
            composeScene(channel, entry.text);
          } else {
            addMessageToChannel(channel, 'system', 'API key required for scene assembly.');
          }
        });
        container.appendChild(chip);
      });
      return container;
    }

    function addMessageToChannel(channel, role, text, extra = {}) {
      channel.addMessage(role, text, extra);
      renderChannelMessages(channel);
      persistState();
    }

    function renderTetradPanel(channel) {
      const tetradData = normalizeTetradData(channel);
      if (!tetradData) return;
      
      // Add tetrad as a special message type
      const tetradMessage = {
        role: 'tetrad',
        text: '', // Will be rendered specially
        tetradData: tetradData,
        timestamp: Date.now(),
        id: `tetrad-${Date.now()}`
      };
      
      // Check if last message is already a tetrad, replace it
      const lastMsg = channel.messages[channel.messages.length - 1];
      if (lastMsg && lastMsg.role === 'tetrad') {
        channel.messages[channel.messages.length - 1] = tetradMessage;
      } else {
        channel.messages.push(tetradMessage);
      }
      
      // Re-render messages to show tetrad
      renderChannelMessages(channel);
      persistState();
    }

    function openPerspectiveSelector(channel) {
      // Get all entities from the grid
      const entities = [];
      channel.grid.forEach((row, y) => {
        row.forEach((cell, x) => {
          if (cell && cell.type === 'Entity' && cell.label) {
            entities.push({label: cell.label, x, y, entity: cell.entity});
          }
        });
      });
      
      if (entities.length === 0) {
        addMessageToChannel(channel, 'system', 'No entities on grid. Add entities first to set perspective.');
        return;
      }
      
      // Create modal
      const modal = document.createElement('div');
      modal.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: min(90vw, 400px);
        max-height: 80vh;
        background: var(--panel);
        border: 2px solid var(--accent);
        border-radius: 8px;
        padding: 20px;
        z-index: 300;
        box-shadow: 0 20px 60px rgba(0,0,0,0.8);
        overflow-y: auto;
      `;
      
      const backdrop = document.createElement('div');
      backdrop.style.cssText = `
        position: fixed;
        inset: 0;
        background: rgba(0,0,0,0.7);
        backdrop-filter: blur(4px);
        z-index: 299;
      `;
      
      modal.innerHTML = `
        <h2 style="font-size: 14px; letter-spacing: 0.2em; color: var(--accent); margin-bottom: 16px; text-transform: uppercase;">
          👁 SELECT PERSPECTIVE
        </h2>
        <p style="font-size: 10px; color: var(--text-muted); margin-bottom: 16px; line-height: 1.5;">
          Choose an entity's perspective for tetrad generation. The tetrad will be generated from their point of view.
        </p>
        <div id="entity-list" style="display: grid; gap: 8px;"></div>
        <div style="margin-top: 16px; display: flex; gap: 8px;">
          <button id="clear-perspective" style="flex: 1; padding: 10px; background: var(--panel-dark); border: 1px solid var(--border); border-radius: 4px; cursor: pointer; font-size: 10px; text-transform: uppercase; letter-spacing: 0.1em;">
            CLEAR
          </button>
          <button id="close-perspective" style="flex: 1; padding: 10px; background: var(--accent); color: var(--bg); border: none; border-radius: 4px; cursor: pointer; font-size: 10px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.1em;">
            CLOSE
          </button>
        </div>
      `;
      
      const entityList = modal.querySelector('#entity-list');
      entities.forEach(ent => {
        const btn = document.createElement('button');
        btn.style.cssText = `
          padding: 12px;
          background: ${channel.tetradPerspective === ent.label ? 'var(--accent)' : 'var(--panel-dark)'};
          color: ${channel.tetradPerspective === ent.label ? 'var(--bg)' : 'var(--text)'};
          border: 2px solid ${channel.tetradPerspective === ent.label ? 'var(--accent)' : 'var(--border)'};
          border-radius: 6px;
          cursor: pointer;
          text-align: left;
          font-size: 11px;
          font-weight: ${channel.tetradPerspective === ent.label ? '700' : '400'};
          transition: all 0.2s;
        `;
        
        btn.innerHTML = `
          <div style="font-weight: 700; margin-bottom: 4px;">${ent.label.toUpperCase()}</div>
          <div style="font-size: 9px; opacity: 0.7;">Position: (${ent.x}, ${ent.y})</div>
        `;
        
        btn.addEventListener('click', async () => {
          // Flash selected button
          btn.style.background = 'var(--accent)';
          btn.style.transform = 'scale(1.05)';
          btn.style.boxShadow = '0 0 20px var(--accent-glow)';
          
          setTimeout(() => {
            channel.tetradPerspective = ent.label;
            modal.remove();
            backdrop.remove();
            
            // Show visual feedback on grid
            const gridCell = channel.dom.gridEl?.querySelector(`[data-x="${ent.x}"][data-y="${ent.y}"]`);
            if (gridCell) {
              gridCell.style.animation = 'pulse 1s ease-in-out 3';
              gridCell.style.boxShadow = '0 0 30px var(--accent-glow)';
              setTimeout(() => {
                gridCell.style.animation = '';
                gridCell.style.boxShadow = '';
              }, 3000);
            }
            
            // Regenerate tetrad from this perspective
            if (channel.lastScene) {
              regenerateTetrad(channel);
            }
            
            // Re-render messages to update button
            renderChannelMessages(channel);
          }, 200);
        });
        
        btn.addEventListener('mouseenter', () => {
          if (channel.tetradPerspective !== ent.label) {
            btn.style.background = 'var(--border)';
          }
        });
        
        btn.addEventListener('mouseleave', () => {
          if (channel.tetradPerspective !== ent.label) {
            btn.style.background = 'var(--panel-dark)';
          }
        });
        
        entityList.appendChild(btn);
      });
      
      modal.querySelector('#clear-perspective').addEventListener('click', () => {
        channel.tetradPerspective = null;
        modal.remove();
        backdrop.remove();
        renderChannelMessages(channel);
      });
      
      modal.querySelector('#close-perspective').addEventListener('click', () => {
        modal.remove();
        backdrop.remove();
      });
      
      backdrop.addEventListener('click', () => {
        modal.remove();
        backdrop.remove();
      });
      
      document.body.appendChild(backdrop);
      document.body.appendChild(modal);
    }
    
    async function regenerateTetrad(channel) {
      if (channel.pendingTetrad) return;
      if (!channel.lastScene) {
        addMessageToChannel(channel, 'system', 'Compose a scene before requesting tetrad options.');
        return;
      }
      try {
        channel.pendingTetrad = true;
        
        // Show loading message
        addMessageToChannel(channel, 'system', `✨ Generating tetrad ${channel.tetradPerspective ? `from ${channel.tetradPerspective}'s perspective` : 'options'}...`);
        
        // Animate grid during regeneration
        const gridCells = channel.dom.gridEl?.querySelectorAll('.grid-cell');
        gridCells?.forEach((cell, idx) => {
          cell.style.animation = `pulse 1.5s ease-in-out infinite`;
          cell.style.animationDelay = `${(idx * 0.03) % 0.5}s`;
        });
        
        renderTetradPanel(channel);
        const tetrad = await callOpenAI('TetradGenerator', {
          scenario: scenarios[channel.scenario],
          scene: channel.lastScene,
          history: channel.messages.slice(-2).map(m => ({ role: m.role, text: m.text })),
          perspective: channel.tetradPerspective || null
        });
        channel.tetrad = tetrad;
        persistState();
        
        // Stop animation
        gridCells?.forEach((cell) => {
          cell.style.animation = '';
        });
        
        // Flash effect
        channel.dom.column?.classList.add('reveal');
        setTimeout(() => channel.dom.column?.classList.remove('reveal'), 500);
        
        // Re-render messages to show tetrad
        renderChannelMessages(channel);
        playRevealChime();
      } catch (err) {
        addMessageToChannel(channel, 'system', `Tetrad generation failed: ${err.message}`);
        // Stop animation on error
        const gridCells = channel.dom.gridEl?.querySelectorAll('.grid-cell');
        gridCells?.forEach((cell) => {
          cell.style.animation = '';
        });
      } finally {
        channel.pendingTetrad = false;
        renderTetradPanel(channel);
      }
    }

    function openTetradMenu(channel) {
      // Disabled - tetrad chips now appear inline in messages only
      return;
      
      const tetradData = normalizeTetradData(channel);
      
      if (!tetradData) {
        if (!channel.lastScene) {
          addMessageToChannel(channel, 'system', 'Compose a scene first to unlock tetrad options.');
          return;
        }
        // Auto-generate if not present
        regenerateTetrad(channel);
        return;
      }
      
      const modal = document.createElement('div');
      modal.className = 'tetrad-menu-modal';
      modal.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: min(90vw, 400px);
        background: var(--panel);
        border: 2px solid var(--accent);
        border-radius: 8px;
        padding: 24px;
        z-index: 300;
        box-shadow: 0 20px 60px rgba(0,0,0,0.8);
      `;
      
      const backdrop = document.createElement('div');
      backdrop.style.cssText = `
        position: fixed;
        inset: 0;
        background: rgba(0,0,0,0.7);
        backdrop-filter: blur(4px);
        z-index: 299;
      `;
      
      const header = document.createElement('div');
      header.style.cssText = 'display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;';
      header.innerHTML = `
        <h2 style="font-size: 14px; letter-spacing: 0.2em; color: var(--accent);">TETRAD TRAJECTORIES</h2>
        <button style="width: 32px; height: 32px; border-radius: 50%; border: 1px solid var(--border); background: var(--panel-dark); color: var(--text); cursor: pointer;" onclick="this.closest('.tetrad-menu-modal').remove(); document.querySelectorAll('[style*=backdrop-filter]')[0]?.remove();">×</button>
      `;
      
      const grid = document.createElement('div');
      grid.style.cssText = 'display: grid; grid-template-columns: repeat(2, 1fr); gap: 12px;';
      
      const tetradMap = [
        { key: 'enhance', icon: '▲', label: 'ENHANCE' },
        { key: 'reverse', icon: '⇄', label: 'REVERSE' },
        { key: 'retrieve', icon: '↺', label: 'RETRIEVE' },
        { key: 'obsolesce', icon: '▼', label: 'OBSOLESCE' }
      ];
      
      console.log('[TETRAD MENU] Opening with data:', tetradData);
      
      tetradMap.forEach(mapping => {
        const entry = tetradData[mapping.key];
        if (!entry) {
          console.log('[TETRAD MENU] Missing entry for:', mapping.key);
          return;
        }
        
        const btn = document.createElement('button');
        btn.style.cssText = `
          padding: 20px;
          background: var(--panel-dark);
          border: 3px solid var(--border);
          border-radius: 8px;
          cursor: pointer;
          transition: all 0.2s var(--transition);
          display: flex;
          flex-direction: column;
          align-items: center;
          gap: 12px;
          box-shadow: 0 2px 0 var(--border), inset 0 1px 0 rgba(255,255,255,0.1);
        `;
        
        btn.innerHTML = `
          <div style="font-size: 32px; color: var(--accent);">${mapping.icon}</div>
          <div style="font-size: 10px; letter-spacing: 0.2em; color: var(--text); font-weight: bold;">${mapping.label}</div>
          <div style="font-size: 8px; color: var(--text-muted); text-align: center; line-height: 1.4; max-height: 60px; overflow: hidden;">${entry.text.substring(0, 80)}...</div>
        `;
        
        btn.addEventListener('mouseenter', () => {
          btn.style.background = 'var(--accent)';
          btn.style.color = 'var(--bg)';
          btn.style.transform = 'scale(1.02)';
        });
        
        btn.addEventListener('mouseleave', () => {
          btn.style.background = 'var(--panel-dark)';
          btn.style.color = '';
          btn.style.transform = '';
        });
        
        btn.addEventListener('click', async () => {
          btn.style.transform = 'scale(0.95) translateY(2px)';
          btn.style.boxShadow = '0 0 0 var(--border)';
          
          modal.remove();
          backdrop.remove();
          
          addMessageToChannel(channel, 'user', entry.text);
          if (appState.apiKey) {
            await composeScene(channel, entry.text);
          } else {
            addMessageToChannel(channel, 'system', 'API key required for scene assembly.');
          }
        });
        
        grid.appendChild(btn);
      });
      
      modal.appendChild(header);
      modal.appendChild(grid);
      document.body.appendChild(backdrop);
      document.body.appendChild(modal);
      
      backdrop.addEventListener('click', () => {
        modal.remove();
        backdrop.remove();
      });
    }

    function openRingOverview(channel) {
      const modal = document.createElement('div');
      modal.className = 'ring-overview-modal';
      modal.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: min(90vw, 600px);
        max-height: 80vh;
        background: var(--panel);
        border: 2px solid var(--accent);
        border-radius: 8px;
        padding: 24px;
        z-index: 300;
        overflow-y: auto;
        box-shadow: 0 20px 60px rgba(0,0,0,0.8);
      `;
      
      const backdrop = document.createElement('div');
      backdrop.style.cssText = `
        position: fixed;
        inset: 0;
        background: rgba(0,0,0,0.7);
        backdrop-filter: blur(4px);
        z-index: 299;
      `;
      
      const header = document.createElement('div');
      header.style.cssText = 'display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;';
      
      const title = document.createElement('h2');
      title.style.cssText = 'font-size: 14px; letter-spacing: 0.2em; color: var(--accent);';
      title.textContent = 'RING MEMORY TIMELINE';
      
      const controls = document.createElement('div');
      controls.style.cssText = 'display: flex; gap: 8px; align-items: center;';
      
      const exportBtn = document.createElement('button');
      exportBtn.style.cssText = `
        padding: 6px 12px;
        border-radius: 4px;
        border: 1px solid var(--accent);
        background: var(--panel-dark);
        color: var(--accent);
        cursor: pointer;
        font-size: 9px;
        letter-spacing: 0.1em;
        transition: all 0.2s;
      `;
      exportBtn.textContent = 'EXPORT';
      exportBtn.addEventListener('click', () => {
        const data = {
          exported: new Date().toISOString(),
          ringMemory: ringMemory,
          channels: appState.channels.map(ch => ({
            id: ch.id,
            name: ch.name,
            scenario: ch.scenario,
            channelColor: ch.channelColor,
            ledgerCount: ch.ledger?.length || 0
          }))
        };
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `legos-ring-memory-${Date.now()}.json`;
        a.click();
        URL.revokeObjectURL(url);
      });
      exportBtn.addEventListener('mouseenter', () => {
        exportBtn.style.background = 'var(--accent)';
        exportBtn.style.color = 'var(--bg)';
      });
      exportBtn.addEventListener('mouseleave', () => {
        exportBtn.style.background = 'var(--panel-dark)';
        exportBtn.style.color = 'var(--accent)';
      });
      
      const closeBtn = document.createElement('button');
      closeBtn.style.cssText = 'width: 32px; height: 32px; border-radius: 50%; border: 1px solid var(--border); background: var(--panel-dark); color: var(--text); cursor: pointer;';
      closeBtn.textContent = '×';
      closeBtn.addEventListener('click', () => {
        modal.remove();
        backdrop.remove();
      });
      
      controls.appendChild(exportBtn);
      controls.appendChild(closeBtn);
      header.appendChild(title);
      header.appendChild(controls);
      
      const content = document.createElement('div');
      content.style.cssText = 'display: flex; flex-direction: column; gap: 12px;';
      
      if (ringMemory.entries.length === 0) {
        content.innerHTML = '<p style="color: var(--text-muted); text-align: center;">No ring memory entries yet. Compose scenes to build your timeline.</p>';
      } else {
        ringMemory.entries.forEach((entry, idx) => {
          const item = document.createElement('div');
          item.style.cssText = `
            padding: 16px;
            background: ${entry.channelId === channel.id ? 'var(--accent-soft)' : 'var(--panel-dark)'};
            border: 1px solid ${entry.isMainline ? 'var(--accent)' : 'var(--border)'};
            border-left: 4px solid ${channelMap.get(entry.channelId)?.channelColor || 'var(--accent)'};
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s var(--transition);
          `;
          
          item.innerHTML = `
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
              <span style="font-size: 10px; letter-spacing: 0.2em; color: var(--text-muted);">${entry.symbol} ${entry.isMainline ? '(MAINLINE)' : ''}</span>
              <span style="font-size: 8px; color: var(--text-muted);">${new Date(entry.timestamp).toLocaleTimeString()}</span>
            </div>
            <div style="font-size: 12px; font-weight: bold; color: var(--text); margin-bottom: 6px;">${entry.headline || 'Untitled'}</div>
            <div style="font-size: 10px; color: var(--text-muted); line-height: 1.5;">${(entry.summary || '').substring(0, 120)}${entry.summary?.length > 120 ? '...' : ''}</div>
          `;
          
          item.addEventListener('click', () => {
            const targetChannel = channelMap.get(entry.channelId);
            if (targetChannel) {
              focusChannel(entry.channelId);
              modal.remove();
              backdrop.remove();
            }
          });
          
          item.addEventListener('mouseenter', () => {
            item.style.background = 'var(--accent-soft)';
            item.style.transform = 'translateX(4px)';
          });
          
          item.addEventListener('mouseleave', () => {
            item.style.background = entry.channelId === channel.id ? 'var(--accent-soft)' : 'var(--panel-dark)';
            item.style.transform = 'translateX(0)';
          });
          
          content.appendChild(item);
        });
      }
      
      modal.appendChild(header);
      modal.appendChild(content);
      document.body.appendChild(backdrop);
      document.body.appendChild(modal);
      
      backdrop.addEventListener('click', () => {
        modal.remove();
        backdrop.remove();
      });
    }

    function openSnapshotOverlay(channel) {
      snapshotOverlayChannel = channel;
      renderSnapshotOverlay();
      document.querySelectorAll('.corner-menu.visible').forEach(menu => menu.classList.remove('visible'));
      const overlay = document.getElementById('snapshotOverlay');
      if (overlay) overlay.classList.add('active');
    }

    function renderSnapshotOverlay() {
      const overlay = document.getElementById('snapshotOverlay');
      if (!overlay || !snapshotOverlayChannel) return;
      const list = document.getElementById('snapshotOverlayList');
      const status = document.getElementById('snapshotStatus');
      const snapshots = snapshotOverlayChannel.snapshots || [];
      status.textContent = snapshots.length
        ? `${snapshots.length} saved state${snapshots.length === 1 ? '' : 's'}.`
        : 'No snapshots saved yet.';
      list.innerHTML = '';
      snapshots.slice().reverse().forEach(snapshot => {
        const item = document.createElement('div');
        item.className = 'snapshot-overlay-item';

        const meta = document.createElement('div');
        meta.className = 'snapshot-overlay-meta';
        const label = document.createElement('span');
        label.textContent = snapshot.name.toUpperCase();
        const time = document.createElement('span');
        time.textContent = new Date(snapshot.timestamp).toLocaleString();
        meta.appendChild(label);
        meta.appendChild(time);
        item.appendChild(meta);

        const info = document.createElement('div');
        info.className = 'overlay-value';
        const title = snapshot.lastScene?.sceneTitle ? `Last: ${snapshot.lastScene.sceneTitle}` : 'Last: —';
        info.textContent = `${snapshot.ledgerLength || 0} scenes captured • ${title}`;
        item.appendChild(info);

        const actions = document.createElement('div');
        actions.className = 'snapshot-overlay-actions';
        const loadBtn = document.createElement('button');
        loadBtn.className = 'secondary-btn';
        loadBtn.textContent = 'LOAD';
        loadBtn.addEventListener('click', () => {
          loadSnapshot(snapshotOverlayChannel, snapshot.id);
          document.getElementById('snapshotOverlay').classList.remove('active');
          snapshotOverlayChannel = null;
        });
        const forkBtn = document.createElement('button');
        forkBtn.className = 'primary-btn';
        forkBtn.textContent = 'FORK';
        forkBtn.addEventListener('click', () => {
          const baseMessage = snapshotOverlayChannel.messages[snapshotOverlayChannel.messages.length - 1] || { id: null };
          forkChannel(snapshotOverlayChannel, baseMessage, 'snapshot', { snapshotId: snapshot.id });
          document.getElementById('snapshotOverlay').classList.remove('active');
          snapshotOverlayChannel = null;
        });
        actions.appendChild(loadBtn);
        actions.appendChild(forkBtn);
        item.appendChild(actions);

        list.appendChild(item);
      });
    }

    const snapshotOverlayElement = document.getElementById('snapshotOverlay');
    const snapshotCreateBtn = document.getElementById('snapshotCreateBtn');
    if (snapshotOverlayElement) {
      snapshotOverlayElement.addEventListener('click', (event) => {
        if (event.target === snapshotOverlayElement) {
          snapshotOverlayElement.classList.remove('active');
          snapshotOverlayChannel = null;
        }
      });
      const snapshotCard = snapshotOverlayElement.querySelector('.overlay-card');
      if (snapshotCard) {
        snapshotCard.addEventListener('click', (event) => event.stopPropagation());
      }
    }

    if (snapshotCreateBtn) {
      snapshotCreateBtn.addEventListener('click', () => {
        if (!snapshotOverlayChannel) return;
        const nextIndex = snapshotOverlayChannel.snapshots.length + 1;
        const label = window.prompt('Snapshot name?', `Snapshot ${nextIndex}`);
        if (label === null) return;
        const snap = snapshotOverlayChannel.createSnapshot(label.trim() || `Snapshot ${nextIndex}`);
        logRingEntry({
          type: 'snapshot',
          channelId: snapshotOverlayChannel.id,
          channelName: snapshotOverlayChannel.name,
          symbol: snap.name,
          headline: 'Snapshot saved',
          summary: `${snap.ledgerLength || 0} scenes captured`
        });
        renderSnapshotOverlay();
        persistState();
        showHelpBanner(`Snapshot saved: ${snap.name}`);
      });
    }


    function loadSnapshot(channel, snapshotId) {
      const snap = channel.snapshots.find(s => s.id === snapshotId);
      if (!snap) return;
      channel.grid = deepClone(snap.grid);
      channel.cells = deepClone(snap.cells);
      channel.observer = deepClone(snap.observer);
      channel.scorecard = deepClone(snap.scorecard);
      channel.tetrad = deepClone(snap.tetrad);
      channel.lastScene = deepClone(snap.lastScene);
      renderChannel(channel);
      persistState();
      showHelpBanner(`Snapshot loaded into ${channel.name}`);
      if (snapshotOverlayChannel === channel) {
        renderSnapshotOverlay();
      }
    }

    function renderTimeline() {
      appState.channels.forEach((channel, channelIdx) => {
        const rail = channel.dom?.channelRail;
        if (!rail) return;
        rail.innerHTML = '';
        
        // Show all channel numbers (scrollable list)
        appState.channels.forEach((target, idx) => {
          const button = document.createElement('button');
          button.className = 'channel-number';
          button.textContent = idx + 1;
          button.title = target.name;
          button.style.borderColor = target.channelColor;
          button.style.color = target.channelColor;
          
          // Each channel shows ITS OWN number lit up
          if (target.id === channel.id) {
            // This is the channel's own number - LIGHT IT UP
            button.classList.add('active');
            button.style.backgroundColor = target.channelColor;
            button.style.color = getComputedStyle(document.body).getPropertyValue('--bg');
            button.style.opacity = '1';
          } else {
            // Other channels - visible and ready
            button.style.opacity = '0.7';
          }
          
          button.addEventListener('click', (event) => {
            event.stopPropagation();
            focusChannel(target.id);
          });
          rail.appendChild(button);
        });
        const add = document.createElement('button');
        add.className = 'channel-number add';
        add.textContent = '+';
        add.title = 'Add channel';
        add.style.borderColor = getComputedStyle(document.body).getPropertyValue('--accent');
        add.style.color = getComputedStyle(document.body).getPropertyValue('--accent');
        add.addEventListener('click', (event) => {
          event.stopPropagation();
          const created = createChannel({ scenario: 'blank' });
          focusChannel(created.id);
        });
        rail.appendChild(add);
      });
    }

    function animateChannelTransition(fromChannel, toChannel) {
      const fromEl = fromChannel.dom?.column;
      const toEl = toChannel.dom?.column;
      if (!fromEl || !toEl) return;
      
      const fromRect = fromEl.getBoundingClientRect();
      const toRect = toEl.getBoundingClientRect();
      
      const ball = document.createElement('div');
      ball.style.cssText = `
        position: fixed;
        width: 24px;
        height: 24px;
        border-radius: 50%;
        background: ${fromChannel.channelColor};
        border: 3px solid ${toChannel.channelColor};
        box-shadow: 0 0 20px ${fromChannel.channelColor}, inset 0 0 10px ${toChannel.channelColor};
        z-index: 1000;
        pointer-events: none;
        left: ${fromRect.left + fromRect.width / 2 - 12}px;
        top: ${fromRect.top + fromRect.height / 2 - 12}px;
        transition: all 0.8s cubic-bezier(0.4, 0, 0.2, 1);
      `;
      
      document.body.appendChild(ball);
      
      requestAnimationFrame(() => {
        ball.style.left = `${toRect.left + toRect.width / 2 - 12}px`;
        ball.style.top = `${toRect.top + toRect.height / 2 - 12}px`;
        ball.style.transform = 'scale(1.5)';
        ball.style.opacity = '0.8';
      });
      
      setTimeout(() => {
        ball.style.opacity = '0';
        ball.style.transform = 'scale(0.5)';
        setTimeout(() => ball.remove(), 300);
      }, 800);
    }

    function focusChannel(channelId) {
      // Set as current
      appState.currentChannelId = channelId;
      
      // Get the channel element
      const element = document.querySelector(`[data-channel-id="${channelId}"]`);
      if (!element) return;
      
      // Scroll to it NOW - smooth and to the left edge
      const scroller = document.getElementById('channelScroller');
      if (scroller) {
        scroller.scrollTo({
          left: element.offsetLeft,
          behavior: 'smooth'
        });
      }
      
      // Remove active from all
      document.querySelectorAll('.channel-column').forEach(col => {
        col.classList.remove('channel-active');
      });
      
      // Add active to this one
      element.classList.add('channel-active');
      
      // Update timeline to show which number is lit
      renderTimeline();
      
      // Get active channel and scroll its number to top
      const activeChannel = appState.channels.find(ch => ch.id === channelId);
      const channelIndex = appState.channels.findIndex(ch => ch.id === channelId);
      
      // If page is bright, scroll its number to the top
      if (activeChannel?.dom?.channelRail && channelIndex !== -1) {
        setTimeout(() => {
          const rail = activeChannel.dom.channelRail;
          const buttons = Array.from(rail.querySelectorAll('.channel-number'));
          const activeButton = buttons[channelIndex];
          if (activeButton) {
            activeButton.scrollIntoView({ behavior: 'smooth', block: 'start' });
          }
        }, 100);
      }
      
      // Update global scenario
      const globalScenarioSelect = document.getElementById('globalScenarioSelect');
      if (activeChannel && globalScenarioSelect) {
        globalScenarioSelect.value = activeChannel.scenario;
      }
      
      persistState();
    }

    function refreshAllChannels() {
      appState.channels.forEach(channel => renderChannel(channel));
    }
    
    function setupChannelVisibilityObserver() {
      const scroller = document.querySelector('.channel-scroller');
      if (!scroller) return;
      
      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting && entry.intersectionRatio > 0.5) {
            const channelId = entry.target.dataset.channelId;
            if (channelId && channelId !== appState.currentChannelId) {
              appState.currentChannelId = channelId;
              renderTimeline();
              
              // Update active channel highlighting
              document.querySelectorAll('.channel-column').forEach(col => {
                col.classList.remove('channel-active');
              });
              entry.target.classList.add('channel-active');
            }
          }
        });
      }, {
        root: scroller,
        threshold: 0.5
      });
      
      document.querySelectorAll('.channel-column[data-channel-id]').forEach(col => {
        observer.observe(col);
      });
    }

    async function composeScene(channel, message) {
      if (channel.pending) return;
      channel.pending = true;
      channel.dom.sendBtn.disabled = true;
      channel.dom.column.classList.add('composing');
      const gridCells = channel.dom.gridEl?.querySelectorAll('.grid-cell');
      // Use the user's actual prompt text for animation!
      const composeText = (message || '').toUpperCase().replace(/[^A-Z0-9\s]/g, '').replace(/\s+/g, '');
      const entropy = []; // Collect entropy from random walks
      
      console.log('[ANIMATION] Using prompt text:', composeText);
      
      gridCells?.forEach((cell, idx) => {
        cell.classList.add('loading');
        cell.style.animationDelay = `${(idx * 0.05) % 0.8}s`;
      });
      
      // Start random walk letters
      const walkLetters = (iterations = 0) => {
        if (iterations > 20 || !channel.pending) return;
        
        // Spawn new walkers
        const numWalkers = Math.floor(Math.random() * 3) + 2;
        for (let i = 0; i < numWalkers; i++) {
          const letter = composeText[Math.floor(Math.random() * composeText.length)] || 'C';
          let currentIdx = Math.floor(Math.random() * 81);
          
          // Random walk algorithm
          const walk = (steps = 0) => {
            if (steps > 8 || !channel.pending) {
              gridCells[currentIdx]?.classList.remove('composing-active');
              gridCells[currentIdx]?.removeAttribute('data-compose-letter');
              return;
            }
            
            // Remove from old cell
            gridCells[currentIdx]?.classList.remove('composing-active');
            
            // Calculate next position (random walk on 9x9 grid)
            const x = currentIdx % 9;
            const y = Math.floor(currentIdx / 9);
            const moves = [];
            if (x > 0) moves.push(currentIdx - 1);     // left
            if (x < 8) moves.push(currentIdx + 1);     // right
            if (y > 0) moves.push(currentIdx - 9);     // up
            if (y < 8) moves.push(currentIdx + 9);     // down
            
            // Add diagonal moves (Monte Carlo style)
            if (x > 0 && y > 0) moves.push(currentIdx - 10); // up-left
            if (x < 8 && y > 0) moves.push(currentIdx - 8);  // up-right
            if (x > 0 && y < 8) moves.push(currentIdx + 8);  // down-left
            if (x < 8 && y < 8) moves.push(currentIdx + 10); // down-right
            
            // Pick random move and record entropy
            const moveIdx = Math.floor(Math.random() * moves.length);
            currentIdx = moves[moveIdx];
            entropy.push(moveIdx); // Dice roll data!
            
            // Add to new cell
            const cell = gridCells[currentIdx];
            if (cell) {
              cell.setAttribute('data-compose-letter', letter);
              cell.classList.add('composing-active');
            }
            
            // Continue walk
            setTimeout(() => walk(steps + 1), 150 + Math.random() * 100);
          };
          
          walk();
        }
        
        setTimeout(() => walkLetters(iterations + 1), 600);
      };
      
      walkLetters();
      
      // Store entropy for use as randomness source
      channel.entropy = entropy;
      await initSound();
      playComposingTick();
      const tickInterval = setInterval(() => playComposingTick(), 800);
      addMessageToChannel(channel, 'system', 'Composing scene…', { autoCollapse: true });
      try {
        const payload = {
          rules: createRuleContract(),
          currentState: channel.lastScene,
          scenario: scenarios[channel.scenario],
          message,
          history: channel.messages.slice(-6).map(m => ({ role: m.role, text: m.text }))
        };
        const scene = await callOpenAI('SceneAssembler', payload);
        channel.pendingTetrad = true;
        applyScene(channel, scene);
        const ringEntry = logRingEntry({
          type: 'scene',
          channelId: channel.id,
          channelName: channel.name,
          symbol: channel.name,
          headline: scene.sceneTitle || '',
          summary: scene.sceneSummary || ''
        });
        if (!channel.ringBinding) {
          channel.ringBinding = ringEntry.id;
        }
        const tetrad = await callOpenAI('TetradGenerator', {
          scenario: scenarios[channel.scenario],
          scene,
          history: channel.messages.slice(-2).map(m => ({ role: m.role, text: m.text })),
          perspective: channel.tetradPerspective || null
        });
        channel.tetrad = tetrad;
        renderTetradPanel(channel);
        persistState();
        playRevealChime();
        const lastMsg = channel.dom.messageList?.lastElementChild;
        if (lastMsg) lastMsg.classList.add('reveal');
      } catch (err) {
        console.error('Scene assembly error:', err);
        const errorDetail = err.stack || err.message || String(err);
        addMessageToChannel(channel, 'system', `Scene assembly failed:\n${errorDetail}`);
      } finally {
        clearInterval(tickInterval);
        channel.dom.column.classList.remove('composing');
        const gridCells = channel.dom.gridEl?.querySelectorAll('.grid-cell');
        gridCells?.forEach(cell => {
          cell.classList.remove('loading');
          cell.classList.remove('composing-active');
          cell.removeAttribute('data-compose-letter');
        });
        channel.pending = false;
        channel.dom.sendBtn.disabled = false;
        channel.pendingTetrad = false;
        renderTetradPanel(channel);
      }
    }

    function createRuleContract() {
      return {
        blockTypes: blockPalette.map(p => p.type),
        gridSize: 9,
        maxPlacements: 18,
        schema: {
          sceneTitle: 'string',
          sceneSummary: 'string',
          entities: [{
            id: 'slug',
            type: 'blockType',
            name: 'string',
            location: 'slug|optional',
            relations: [{ type: 'string', target: 'slug' }]
          }],
          gridMapping: [{
            id: 'slug',
            type: 'blockType',
            label: 'string|optional',
            x: '0..8',
            y: '0..8'
          }],
          plot: {
            prior: { caution: '0..1', progress: '0..1' },
            posterior: { caution: '0..1', progress: '0..1' }
          },
          direction: 'up|down|left|right',
          tension: '0..1',
          scorecard: {
            progress: '0..1',
            caution: '0..1',
            movesRemaining: 'int',
            goalDistance: 'int'
          }
        }
      };
    }

    async function callOpenAI(kind, payload) {
      if (!appState.apiKey) {
        throw new Error('Missing API key. Click ◎ in corner menu to set your OpenAI API key.');
      }
      
      console.log('═══════════════════════════════════════');
      console.log('[API CALL] Type:', kind);
      console.log('[API CALL] API Key length:', appState.apiKey.length);
      console.log('[API CALL] Payload:', JSON.stringify(payload, null, 2));
      
      const prompts = {
        SceneAssembler: [
          {
            role: 'system',
            content: [
              'You are LEGOS-G (Liberation Engine Grid Ontology Synthesizer) - a HYPERCLAY world sculptor.',
              'Return valid JSON matching the schema provided.',
              'Place 8-14 elements on a 9x9 grid. Coordinates are 0-8.',
              'CRITICAL: BE TRANSFORMATIVE, NOT CONSERVATIVE.',
              '- REMOVE elements that are no longer relevant (2-4 removals per beat)',
              '- ADD new elements that emerge from the narrative (2-4 additions per beat)',
              '- Change entity states and conditions dramatically',
              '- Introduce new objects, environments, or complications',
              '- Remove obstacles once overcome, add new ones',
              '- The grid should feel ALIVE and REACTIVE, not static',
              'AVOID: Just shuffling existing elements around. That is boring.',
              'DO: Transform the scene. New entities appear, old ones vanish, the world reshapes itself.',
              'Position proximity = relationship strength. Distant = tension/separation.',
              'Use the full grid space. Create visual patterns that mirror story dynamics.',
              'Entity names should be full, memorable words (not truncated).',
              'Keep IDs consistent only for persistent elements. Generate new IDs for new elements.',
              'Update scorecard (progress 0-1, movesRemaining int, goalDistance int).'
            ].join(' ')
          },
          { role: 'user', content: JSON.stringify(payload) }
        ],
        TetradGenerator: [
          {
            role: 'system',
            content: payload.perspective
              ? `Generate TRANSFORMATIVE tetrad entries from ${payload.perspective}'s perspective. Each entry should CHANGE THE SCENE dramatically: add new elements, remove old ones, alter states. ENHANCE: what new elements/complications appear? REVERSE: what inverts or transforms? RETRIEVE: what returns or emerges? OBSOLESCE: what vanishes or fades? Be specific about entities/objects entering or leaving. Motivations: ${payload.perspective}'s desires/fears. Text <= 80 words, score 0-100. Return JSON.`
              : 'Generate TRANSFORMATIVE tetrad entries. Each must CHANGE THE SCENE: ENHANCE adds new elements/complications, REVERSE transforms existing ones, RETRIEVE brings back elements, OBSOLESCE removes elements. Be specific about what enters or exits the grid. Text <= 80 words, score 0-100. Return JSON.'
          },
          { role: 'user', content: JSON.stringify(payload) }
        ]
      };

      const requestBody = {
        model: 'gpt-4o-mini',
        temperature: kind === 'SceneAssembler' ? 0.7 : 0.8,
        messages: prompts[kind],
        max_tokens: kind === 'SceneAssembler' ? 2500 : 600,
        response_format: { type: 'json_object' }
      };
      
      console.log('[API CALL] Model:', requestBody.model);
      console.log('[API CALL] Temperature:', requestBody.temperature);
      console.log('[API CALL] Max Tokens:', requestBody.max_tokens);
      console.log('[API CALL] Messages:', prompts[kind].length, 'messages');
      prompts[kind].forEach((msg, idx) => {
        console.log(`  [${idx}] ${msg.role}:`, msg.content.substring(0, 100) + (msg.content.length > 100 ? '...' : ''));
      });
      
      let response;
      try {
        console.log('[API CALL] Sending request to OpenAI...');
        const startTime = Date.now();
        
        response = await fetch('https://api.openai.com/v1/chat/completions', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${appState.apiKey}`
          },
          body: JSON.stringify(requestBody)
        });
        
        const duration = Date.now() - startTime;
        console.log('[API RESPONSE] Status:', response.status, 'Duration:', duration + 'ms');
      } catch (fetchError) {
        console.error('[API ERROR] Fetch failed:', fetchError);
        console.error('[API ERROR] Error details:', {
          message: fetchError.message,
          name: fetchError.name,
          stack: fetchError.stack
        });
        throw new Error(`Network error: Cannot reach OpenAI API. Check your internet connection and API key. ${fetchError.message}`);
      }
      
      if (!response.ok) {
        const text = await response.text();
        console.error('[API] HTTP error:', response.status, text);
        if (response.status === 401) {
          throw new Error(`Invalid API key. Please check your OpenAI API key in corner menu (◎).`);
        } else if (response.status === 429) {
          throw new Error(`Rate limit exceeded. Please wait a moment and try again.`);
        }
        throw new Error(`HTTP ${response.status}: ${text}`);
      }
      const data = await response.json();
      console.log('[API RESPONSE] Usage:', data.usage);
      console.log('[API RESPONSE] Model:', data.model);
      console.log('[API RESPONSE] Finish reason:', data.choices?.[0]?.finish_reason);
      
      const raw = data.choices?.[0]?.message?.content;
      if (!raw) {
        console.error('[API ERROR] Empty response from API');
        throw new Error('Empty response from API.');
      }
      
      console.log('[API RESPONSE] Content length:', raw.length, 'characters');
      console.log('[API RESPONSE] Content preview:', raw.substring(0, 200) + (raw.length > 200 ? '...' : ''));
      
      try {
        const parsed = JSON.parse(raw);
        console.log('[API SUCCESS] Parsed JSON successfully');
        console.log('═══════════════════════════════════════\n');
        return parsed;
      } catch (parseErr) {
        console.error('[API ERROR] JSON parse error:', parseErr);
        console.error('[API ERROR] Raw response:', raw);
        
        // Try to repair truncated JSON by closing open structures
        console.log('[API REPAIR] Attempting to repair truncated JSON...');
        let repaired = raw.trim();
        
        // Count open braces/brackets
        const openBraces = (repaired.match(/\{/g) || []).length;
        const closeBraces = (repaired.match(/\}/g) || []).length;
        const openBrackets = (repaired.match(/\[/g) || []).length;
        const closeBrackets = (repaired.match(/\]/g) || []).length;
        
        // Remove incomplete string at end
        if (repaired.endsWith('"')) {
          repaired = repaired.slice(0, -1) + '" ';
        } else if (!repaired.endsWith('}') && !repaired.endsWith(']')) {
          // Find last complete property
          const lastComma = repaired.lastIndexOf(',');
          const lastBrace = repaired.lastIndexOf('}');
          const lastBracket = repaired.lastIndexOf(']');
          const cutPoint = Math.max(lastComma, lastBrace, lastBracket);
          if (cutPoint > 0) {
            repaired = repaired.substring(0, cutPoint + 1);
          }
        }
        
        // Close open arrays
        for (let i = 0; i < openBrackets - closeBrackets; i++) {
          repaired += ']';
        }
        
        // Close open objects
        for (let i = 0; i < openBraces - closeBraces; i++) {
          repaired += '}';
        }
        
        console.log('[API REPAIR] Repaired JSON:', repaired.substring(Math.max(0, repaired.length - 200)));
        
        try {
          const parsed = JSON.parse(repaired);
          console.log('[API SUCCESS] Repaired JSON parsed successfully!');
          console.log('═══════════════════════════════════════\n');
          return parsed;
        } catch (repairErr) {
          console.error('[API ERROR] Repair failed:', repairErr);
          throw new Error(`Invalid JSON from API (repair failed): ${parseErr.message}. Raw: ${raw.substring(0, 200)}`);
        }
      }
    }

    function showSceneLog(changes) {
      // Grid IS the terminal - log to console only
      console.log('[SCENE CHANGES]', changes.join(' | '));
    }
    
    function applyScene(channel, scene) {
      const oldScene = channel.lastScene;
      channel.lastScene = scene;
      channel.ledger.push(scene);
      
      // Track what changed
      const changes = [];
      const oldPositions = new Map();
      
      if (oldScene?.gridMapping) {
        oldScene.gridMapping.forEach(item => {
          oldPositions.set(item.id, {x: item.x, y: item.y, type: item.type});
        });
      }
      
      // Animate old cells with different effects based on what happens to them
      const oldCells = channel.dom.gridEl?.querySelectorAll('.grid-cell.occupied');
      oldCells?.forEach((cell, idx) => {
        const y = parseInt(cell.dataset.y);
        const x = parseInt(cell.dataset.x);
        const oldCell = channel.grid[y]?.[x];
        
        if (!oldCell) return;
        
        // Check if this element appears in new scene
        const newPlacement = (scene.gridMapping || []).find(p => p.id === oldCell.id);
        
        setTimeout(() => {
          if (!newPlacement) {
            // Element DISAPPEARS - dramatic fade with red tint
            cell.style.transition = 'opacity 0.5s, transform 0.5s, filter 0.5s, box-shadow 0.5s';
            cell.style.opacity = '0';
            cell.style.transform = 'scale(0) rotate(180deg)';
            cell.style.filter = 'blur(4px) hue-rotate(-30deg)';
            cell.style.boxShadow = '0 0 20px rgba(248, 113, 113, 0.8)';
            changes.push(`❌ ${oldCell.label || oldCell.type} disappeared`);
            
            // Show terminal-style status on cell
            const status = document.createElement('div');
            status.style.cssText = `
              position: absolute;
              top: 50%;
              left: 50%;
              transform: translate(-50%, -50%);
              font-size: 7px;
              font-family: 'Courier New', monospace;
              color: #f87171;
              letter-spacing: 0.1em;
              pointer-events: none;
              text-shadow: 0 0 8px #f87171;
            `;
            status.textContent = 'REMOVED';
            cell.style.position = 'relative';
            cell.appendChild(status);
            setTimeout(() => status.remove(), 1500);
          } else if (newPlacement.x !== x || newPlacement.y !== y) {
            // Element MOVES - slide out with blue tint
            const dx = (newPlacement.x - x) * 100;
            const dy = (newPlacement.y - y) * 100;
            cell.style.transition = 'transform 0.6s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.3s, box-shadow 0.3s';
            cell.style.transform = `translate(${dx}px, ${dy}px) scale(0.8)`;
            cell.style.opacity = '0.3';
            cell.style.boxShadow = '0 0 20px rgba(96, 165, 250, 0.6)';
            changes.push(`↔ ${oldCell.label || oldCell.type} moved (${x},${y})→(${newPlacement.x},${newPlacement.y})`);
          } else {
            // Element STAYS - gentle fade
            cell.style.transition = 'opacity 0.3s';
            cell.style.opacity = '0.5';
          }
        }, idx * 15);
      });
      
      // Display changes in terminal log overlay
      if (changes.length) {
        console.log('[SCENE UPDATE]', changes.join(' | '));
        showSceneLog(changes);
      }
      
      setTimeout(() => {
        channel.grid = createEmptyGrid();
        channel.cells = {};
        
        const placements = (scene.gridMapping || []).slice(0, 18);
        const newElements = [];
        
        placements.forEach(item => {
          if (item.x < 0 || item.x > 8 || item.y < 0 || item.y > 8) return;
          const entity = (scene.entities || []).find(e => e.id === item.id) || null;
          const label = sanitizeLabel(entity?.name || item.label || '');
          channel.grid[item.y][item.x] = {
            id: item.id,
            type: item.type,
            symbol: blockPalette.find(p => p.type === item.type)?.symbol || item.type[0],
            label,
            entity
          };
          logCellEvent(channel, item.x, item.y, `Agent placed ${item.type}${label ? `: ${label}` : ''}`);
          
          // Track new elements
          if (!oldPositions.has(item.id)) {
            newElements.push(`✨ ${label || item.type} appeared @ (${item.x},${item.y})`);
          }
        });
        
        // Show new elements in log
        if (newElements.length) {
          showSceneLog(newElements);
        }
        
        channel.observer = {
          plot: scene.plot || channel.observer.plot,
          direction: scene.direction || 'up',
          tension: scene.tension ?? channel.observer.tension,
          narrative: scene.sceneSummary || channel.observer.narrative
        };
        channel.scorecard = scene.scorecard || createDefaultScorecard();

        // Auto-name blank canvas channels based on scene
        if (channel.scenario === 'blank' && scene.sceneTitle) {
          const generatedName = sanitizeHandle(scene.sceneTitle, channel.symbolicId);
          if (generatedName && generatedName !== 'BLANK CANV') {
            channel.name = generatedName;
          }
        }
        
        addMessageToChannel(channel, 'assistant', `${scene.sceneTitle}\n${scene.sceneSummary}`);
        renderChannel(channel);
      }, 400); // Delay to show clearing animation

      // Trigger animations for placed elements
      setTimeout(() => {
        const gridCells = channel.dom.gridEl?.querySelectorAll('.grid-cell.occupied');
        gridCells?.forEach((cell, idx) => {
          const y = parseInt(cell.dataset.y);
          const x = parseInt(cell.dataset.x);
          const cellData = channel.grid[y][x];
          if (!cellData) return;
          
          // Check if this is a NEW element (wasn't in old scene)
          const isNew = oldPositions.size > 0 && !oldPositions.has(cellData.id);
          const oldPos = oldPositions.get(cellData.id);
          const moved = oldPos && (oldPos.x !== x || oldPos.y !== y);
          
          setTimeout(() => {
            if (isNew) {
              // NEW element - dramatic entrance
              cell.style.animation = 'none';
              cell.style.transform = 'scale(0) rotate(-180deg)';
              cell.style.opacity = '0';
              
              // Show terminal status - color by element type
              const status = document.createElement('div');
              const typeColor = cellData.type === 'Entity' ? '#86efac' : 
                               cellData.type === 'Object' ? '#60a5fa' : 
                               cellData.type === 'Environment' ? '#c084fc' : '#fbbf24';
              status.style.cssText = `
                position: absolute;
                top: -8px;
                left: 50%;
                transform: translateX(-50%);
                font-size: 6px;
                font-family: 'Courier New', monospace;
                color: ${typeColor};
                letter-spacing: 0.15em;
                pointer-events: none;
                white-space: nowrap;
                text-shadow: 0 0 8px ${typeColor};
                animation: sparkle 3s ease-in-out infinite;
              `;
              status.textContent = '✨ NEW';
              cell.style.position = 'relative';
              cell.appendChild(status);
              
              setTimeout(() => {
                cell.style.transition = 'all 0.6s cubic-bezier(0.4, 0, 0.2, 1)';
                cell.style.transform = 'scale(1) rotate(0)';
                cell.style.opacity = '1';
                // Keep NEW label longer with sparkle
                setTimeout(() => status.remove(), 4000);
              }, 50);
            } else if (moved) {
              // MOVED element - pulse
              cell.style.animation = 'pulse 0.6s ease-in-out';
              
              // Show terminal status - color by element type
              const status = document.createElement('div');
              const typeColor = cellData.type === 'Entity' ? '#86efac' : 
                               cellData.type === 'Object' ? '#60a5fa' : 
                               cellData.type === 'Environment' ? '#c084fc' : '#fbbf24';
              status.style.cssText = `
                position: absolute;
                top: -8px;
                left: 50%;
                transform: translateX(-50%);
                font-size: 6px;
                font-family: 'Courier New', monospace;
                color: ${typeColor};
                letter-spacing: 0.15em;
                pointer-events: none;
                white-space: nowrap;
                text-shadow: 0 0 8px ${typeColor};
              `;
              status.textContent = '↔ MOVED';
              cell.style.position = 'relative';
              cell.appendChild(status);
              setTimeout(() => status.remove(), 2000);
            }
            
            // Ripple effect
            cell.classList.add('resonance-field');
            setTimeout(() => cell.classList.remove('resonance-field'), 1200);
          }, idx * 150); // Slower stagger for smoother appearance
        });
      }, 450); // Longer delay to show transitions
    }

    // Dice roll using entropy from random walks
    function rollDice(channel, sides = 6, count = 1) {
      if (!channel.entropy || channel.entropy.length === 0) {
        // Fallback to Math.random if no entropy
        return Array.from({ length: count }, () => Math.floor(Math.random() * sides) + 1);
      }
      
      const rolls = [];
      for (let i = 0; i < count; i++) {
        // Consume entropy from the random walk
        const entropyIdx = channel.entropy.shift();
        if (entropyIdx === undefined) {
          // Entropy depleted, use standard random
          rolls.push(Math.floor(Math.random() * sides) + 1);
        } else {
          // Use entropy value, map to dice range
          const roll = (entropyIdx % sides) + 1;
          rolls.push(roll);
        }
      }
      
      // Log the roll for narrative purposes
      const rollText = rolls.length === 1 ? `Rolled ${rolls[0]}` : `Rolled ${rolls.join(', ')}`;
      console.log(`[DICE] ${rollText} using entropy (${channel.entropy.length} remaining)`);
      
      return rolls;
    }
    
    function logCellEvent(channel, x, y, text) {
      const key = `${x},${y}`;
      if (!channel.cells[key]) channel.cells[key] = [];
      channel.cells[key].push({ text, timestamp: new Date().toISOString() });
    }

    function gatherNearbyCells(channel, x, y, radius = 2.5) {
      const results = [];
      channel.grid.forEach((row, yy) => {
        row.forEach((cell, xx) => {
          if (!cell || (xx === x && yy === y)) return;
          const dx = xx - x;
          const dy = yy - y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          if (distance <= radius) {
            results.push({ cell, x: xx, y: yy, distance });
          }
        });
      });
      return results.sort((a, b) => a.distance - b.distance);
    }

    function describeCellEnvironment(channel, x, y) {
      const cell = channel.grid[y]?.[x] || null;
      const neighbours = gatherNearbyCells(channel, x, y);
      const observer = channel.observer || {};
      const scorecard = channel.scorecard || {};
      const pieces = [];
      if (neighbours.length) {
        const sample = neighbours.slice(0, 3).map(item => {
          const label = item.cell.label || item.cell.type;
          return `${label} @ (${item.x},${item.y})`;
        }).join('; ');
        pieces.push(`Nearby signals: ${sample}.`);
      } else {
        pieces.push('Nearby signals: none detected within two cells.');
      }
      if (observer.tension != null) {
        pieces.push(`Scene tension ${Math.round((observer.tension || 0) * 100)}%.`);
      }
      if (observer.direction) {
        pieces.push(`Narrative drift ${observer.direction.toUpperCase()}.`);
      }
      if (scorecard.progress != null || scorecard.caution != null) {
        const progress = scorecard.progress != null ? (scorecard.progress * 100).toFixed(0) : '0';
        const caution = scorecard.caution != null ? (scorecard.caution * 100).toFixed(0) : '0';
        pieces.push(`Progress ${progress}%, caution ${caution}%.`);
      }
      if (!cell) {
        pieces.push('Cell is currently empty, awaiting placement.');
      }
      return pieces.join(' ');
    }

    function computeRelationshipScores(channel, x, y) {
      const source = channel.grid[y]?.[x];
      if (!source) return [];
      const relations = source.entity?.relations || [];
      const results = [];
      channel.grid.forEach((row, yy) => {
        row.forEach((cell, xx) => {
          if (!cell || (xx === x && yy === y)) return;
          const dx = xx - x;
          const dy = yy - y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          const proximity = 1 / (1 + distance);
          const typeBoost = cell.type === source.type ? 0.15 : 0;
          const relationBoost = relations.some(rel => rel.target === cell.id) ? 0.25 : 0;
          const score = Math.min(0.99, proximity + typeBoost + relationBoost);
          const label = sanitizeLabel(cell.label || `${cell.type} (${cell.symbol || '?'})`);
          results.push({
            label,
            type: cell.type,
            score,
            distance,
            relation: relationBoost > 0
          });
        });
      });
      return results.sort((a, b) => b.score - a.score).slice(0, 5);
    }

    function openCellOverlay(channel, x, y) {
      const cell = channel.grid[y][x];
      const logs = channel.cells[`${x},${y}`] || [];
      const content = document.getElementById('cellOverlayContent');
      content.innerHTML = '';
      const close = document.createElement('button');
      close.className = 'close-overlay';
      close.textContent = '×';
      close.addEventListener('click', () => document.getElementById('cellOverlay').classList.remove('active'));
      content.appendChild(close);

      const header = document.createElement('div');
      header.className = 'overlay-section';
      const label = document.createElement('div');
      label.className = 'overlay-label';
      label.textContent = `${channel.name} · CELL (${x}, ${y})`;
      const value = document.createElement('div');
      value.className = 'overlay-value';
      value.textContent = cell ? `${cell.type} · ${cell.label || '—'}` : 'Empty cell';
      header.appendChild(label);
      header.appendChild(value);
      content.appendChild(header);

      if (cell?.entity) {
        if (cell.entity.description) {
          const section = document.createElement('div');
          section.className = 'overlay-section';
          const l = document.createElement('div');
          l.className = 'overlay-label';
          l.textContent = 'Description';
          const v = document.createElement('div');
          v.className = 'overlay-value';
          v.textContent = cell.entity.description;
          section.appendChild(l);
          section.appendChild(v);
          content.appendChild(section);
        }
        if (cell.entity.relations?.length) {
          const section = document.createElement('div');
          section.className = 'overlay-section';
          const l = document.createElement('div');
          l.className = 'overlay-label';
          l.textContent = 'Relations';
          section.appendChild(l);
          cell.entity.relations.forEach(rel => {
            const v = document.createElement('div');
            v.className = 'overlay-value';
            v.textContent = `${rel.type}: ${rel.target}`;
            section.appendChild(v);
          });
          content.appendChild(section);
        }
      }

      // CULTURAL FRAMEWORK & BDI STATE DISPLAY
      if (channel.culturalAgents) {
        const key = `${x}_${y}`;
        const agent = channel.culturalAgents[key];
        
        if (agent) {
          const section = document.createElement('div');
          section.className = 'overlay-section';
          section.style.backgroundColor = 'rgba(100, 50, 200, 0.1)';
          section.style.border = '1px solid rgba(100, 50, 200, 0.3)';
          
          const l = document.createElement('div');
          l.className = 'overlay-label';
          const fw = channel.culturalParams?.framework || 'epstein';
          const frameworkEmoji = {
            'epstein': '⚡',
            'bdi': '🧠',
            'rebeland': '🏛️',
            'iruba': '⚔️',
            'ccim': '🌍',
            'axelrod': '🎭',
            'schelling': '🏘️'
          };
          l.textContent = `${frameworkEmoji[fw] || '◉'} Cultural State (${fw})`;
          section.appendChild(l);
          
          // Cultural type and symbolic role
          const typeVal = document.createElement('div');
          typeVal.className = 'overlay-value';
          const roleLabel = agent.legosCellRef?.entity?.symbolicRole || 'neutral';
          typeVal.textContent = `Type: ${agent.type} (${roleLabel})`;
          section.appendChild(typeVal);
          
          // Traits
          if (agent.traits) {
            const traitsVal = document.createElement('div');
            traitsVal.className = 'overlay-value';
            traitsVal.textContent = `Hardship: ${(agent.traits.hardship * 100).toFixed(0)}%, Risk Aversion: ${(agent.traits.riskAversion * 100).toFixed(0)}%`;
            section.appendChild(traitsVal);
          }
          
          // Fear/Energy
          const stateVal = document.createElement('div');
          stateVal.className = 'overlay-value';
          stateVal.textContent = `Fear: ${(agent.fear * 100).toFixed(0)}%, Energy: ${(agent.energy * 100).toFixed(0)}%`;
          section.appendChild(stateVal);
          
          // BDI STATE (if active)
          if (agent.bdiAgent && channel.culturalParams?.useBDI) {
            const bdiLabel = document.createElement('div');
            bdiLabel.className = 'overlay-label';
            bdiLabel.textContent = '🧠 BDI Reasoning';
            bdiLabel.style.marginTop = '8px';
            section.appendChild(bdiLabel);
            
            // Beliefs
            const beliefsVal = document.createElement('div');
            beliefsVal.className = 'overlay-value';
            beliefsVal.textContent = `Beliefs: ${agent.bdiAgent.beliefs.nearbyThreats.length} threats, ${agent.bdiAgent.beliefs.nearbyAllies.length} allies, legitimacy ${(agent.bdiAgent.beliefs.perceivedLegitimacy * 100).toFixed(0)}%`;
            section.appendChild(beliefsVal);
            
            // Desires
            if (agent.bdiAgent.desires.size > 0) {
              const desiresVal = document.createElement('div');
              desiresVal.className = 'overlay-value';
              desiresVal.textContent = `Desires: ${Array.from(agent.bdiAgent.desires).join(', ')}`;
              section.appendChild(desiresVal);
            }
            
            // Current Intention
            if (agent.bdiAgent.currentIntention) {
              const intentionVal = document.createElement('div');
              intentionVal.className = 'overlay-value';
              intentionVal.style.fontWeight = 'bold';
              intentionVal.textContent = `→ Intention: ${agent.bdiAgent.currentIntention.type} (priority ${agent.bdiAgent.currentIntention.priority})`;
              section.appendChild(intentionVal);
            }
          }
          
          content.appendChild(section);
        }
      }

      if (logs.length) {
        const section = document.createElement('div');
        section.className = 'overlay-section';
        const l = document.createElement('div');
        l.className = 'overlay-label';
        l.textContent = `Event History (last 10 of ${logs.length})`;
        section.appendChild(l);
        // Show only last 10 events
        logs.slice(-10).reverse().forEach(log => {
          const v = document.createElement('div');
          v.className = 'overlay-value';
          v.textContent = `${new Date(log.timestamp).toLocaleTimeString()} · ${log.text}`;
          section.appendChild(v);
        });
        content.appendChild(section);
      }

      if (channel.ledger.length) {
        const section = document.createElement('div');
        section.className = 'overlay-section';
        const label = document.createElement('div');
        label.className = 'overlay-label';
        label.textContent = 'Recent Scenes';
        section.appendChild(label);
        channel.ledger.slice(-3).reverse().forEach(scene => {
          const summary = (scene.sceneSummary || '').trim();
          const compact = summary.length > 160 ? `${summary.slice(0, 160)}…` : summary;
          const value = document.createElement('div');
          value.className = 'overlay-value';
          value.textContent = `${scene.sceneTitle || 'Scene'} — ${compact}`;
          section.appendChild(value);
        });
        content.appendChild(section);
      }

      const awareness = describeCellEnvironment(channel, x, y);
      if (awareness) {
        const section = document.createElement('div');
        section.className = 'overlay-section';
        const label = document.createElement('div');
        label.className = 'overlay-label';
        label.textContent = 'Local Awareness';
        const value = document.createElement('div');
        value.className = 'overlay-value';
        value.textContent = awareness;
        section.appendChild(label);
        section.appendChild(value);
        content.appendChild(section);
      }

      const relationshipScores = computeRelationshipScores(channel, x, y);
      if (relationshipScores.length) {
        const section = document.createElement('div');
        section.className = 'overlay-section';
        const label = document.createElement('div');
        label.className = 'overlay-label';
        label.textContent = 'Relational Probabilities';
        section.appendChild(label);
        relationshipScores.forEach(item => {
          const value = document.createElement('div');
          value.className = 'overlay-value';
          const percent = Math.round(item.score * 100);
          value.textContent = `${item.label} — ${percent}% resonance` + (item.relation ? ' (linked)' : '');
          section.appendChild(value);
        });
        content.appendChild(section);
      }

      const actionRow = [];
      
      // Send to Chat button
      if (cell) {
        const sendToChatBtn = document.createElement('button');
        sendToChatBtn.className = 'primary-btn';
        sendToChatBtn.textContent = 'SEND TO CHAT';
        sendToChatBtn.addEventListener('click', () => {
          const cellContext = `Regarding ${cell.label || cell.type} at (${x},${y}): `;
          if (channel.dom?.input) {
            channel.dom.input.value = cellContext;
            channel.dom.input.focus();
          }
          document.getElementById('cellOverlay').classList.remove('active');
        });
        actionRow.push(sendToChatBtn);
      }
      
      const spawnBtn = document.createElement('button');
      spawnBtn.className = 'primary-btn';
      spawnBtn.textContent = 'SPAWN POV CHANNEL';
      spawnBtn.addEventListener('click', () => {
        document.getElementById('cellOverlay').classList.remove('active');
        spawnCellPerspectiveChannel(channel, x, y, cell);
      });
      actionRow.push(spawnBtn);

      if (cell) {
        const canRunPerspective = Boolean(appState.apiKey);
        const perspectiveBtn = document.createElement('button');
        perspectiveBtn.className = 'primary-btn';
        perspectiveBtn.textContent = 'RUN ELEMENT PERSPECTIVE';
        perspectiveBtn.disabled = !canRunPerspective;
        if (canRunPerspective) {
          perspectiveBtn.addEventListener('click', () => {
            document.getElementById('cellOverlay').classList.remove('active');
            showEntityPerspective(channel, x, y, cell);
          });
        } else {
          perspectiveBtn.title = 'Store an API key to analyze this element POV.';
        }
        actionRow.push(perspectiveBtn);
        
        // Add Tetrad Intervention button
        const tetradBtn = document.createElement('button');
        tetradBtn.className = 'primary-btn tetrad-intervention-btn';
        tetradBtn.innerHTML = '⋔ TETRAD INTERVENTION';
        tetradBtn.disabled = !canRunPerspective;
        
        // Glowing effect when API ready
        if (canRunPerspective) {
          tetradBtn.classList.add('glow-active');
          tetradBtn.addEventListener('click', async () => {
            tetradBtn.disabled = true;
            tetradBtn.textContent = '⋔ GENERATING...';
            tetradBtn.classList.add('glow-processing');
            
            try {
              const tetrad = await callOpenAI('TetradGenerator', {
                scenario: scenarios[channel.scenario],
                scene: channel.lastScene,
                history: channel.messages.slice(-2).map(m => ({ role: m.role, text: m.text })),
                perspective: cell.label,
                elementContext: {
                  type: cell.type,
                  position: {x, y},
                  environment: describeCellEnvironment(channel, x, y)
                }
              });
              
              channel.tetrad = tetrad;
              channel.tetradPerspective = cell.label;
              persistState();
              renderChannelMessages(channel);
              
              tetradBtn.textContent = '✓ TETRAD GENERATED';
              tetradBtn.classList.remove('glow-processing');
              tetradBtn.classList.add('glow-success');
              
              setTimeout(() => {
                document.getElementById('cellOverlay').classList.remove('active');
              }, 1000);
            } catch (err) {
              tetradBtn.textContent = '✗ GENERATION FAILED';
              tetradBtn.classList.remove('glow-processing');
              tetradBtn.disabled = false;
            }
          });
        } else {
          tetradBtn.title = 'Store an API key to generate tetrad for this element.';
        }
        
        actionRow.push(tetradBtn);
      }

      if (actionRow.length) {
        const actions = document.createElement('div');
        actions.className = 'overlay-action-row';
        actionRow.forEach(btn => actions.appendChild(btn));
        content.appendChild(actions);
      }

      document.getElementById('cellOverlay').classList.add('active');
    }

    async function showEntityPerspective(channel, x, y, cell) {
      const panel = document.getElementById('perspectiveOverlayContent');
      panel.innerHTML = '';
      const close = document.createElement('button');
      close.className = 'close-overlay';
      close.textContent = '×';
      close.addEventListener('click', () => document.getElementById('perspectiveOverlay').classList.remove('active'));
      panel.appendChild(close);

      // Show loading screen
      const loadingScreen = document.createElement('div');
      loadingScreen.style.cssText = `
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 40px 20px;
        gap: 16px;
      `;
      
      const loadingText = document.createElement('div');
      loadingText.style.cssText = `
        font-size: 12px;
        font-weight: 700;
        letter-spacing: 0.15em;
        color: var(--accent);
        text-transform: uppercase;
        text-align: center;
      `;
      loadingText.textContent = `Analyzing ${cell.label || cell.type}'s Perspective...`;
      
      const loadingSubtext = document.createElement('div');
      loadingSubtext.style.cssText = `
        font-size: 9px;
        color: var(--text-muted);
        text-align: center;
        max-width: 300px;
      `;
      loadingSubtext.textContent = 'Consulting current scene and relationships...';
      
      loadingScreen.appendChild(loadingText);
      loadingScreen.appendChild(loadingSubtext);
      panel.appendChild(loadingScreen);
      
      // Show message history dots for this cell
      const cellLogs = channel.cells[`${x},${y}`] || [];
      if (cellLogs.length) {
        const historySection = document.createElement('div');
        historySection.className = 'overlay-section';
        historySection.style.cssText = 'display: flex; gap: 6px; align-items: center; padding: 8px 0;';
        
        const historyLabel = document.createElement('div');
        historyLabel.className = 'overlay-label';
        historyLabel.textContent = 'Modified by:';
        historyLabel.style.marginBottom = '0';
        historySection.appendChild(historyLabel);
        
        const dotRow = document.createElement('div');
        dotRow.style.cssText = 'display: flex; gap: 4px; flex-wrap: wrap;';
        
        cellLogs.slice(-5).forEach((log, idx) => {
          const dot = document.createElement('span');
          dot.style.cssText = `
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: ${channel.channelColor};
            border: 2px solid ${idx === cellLogs.length - 1 ? 'var(--accent)' : 'var(--border)'};
            display: inline-block;
            flex-shrink: 0;
            box-shadow: 0 0 8px ${channel.channelColor};
          `;
          dot.title = `${new Date(log.timestamp).toLocaleTimeString()}: ${log.text}`;
          dotRow.appendChild(dot);
        });
        
        historySection.appendChild(dotRow);
        panel.appendChild(historySection);
      }
      
      document.getElementById('perspectiveOverlay').classList.add('active');

      const entityPayload = cell?.entity ? { ...cell.entity } : {
        name: cell?.label || `${cell?.type || 'Cell'} (${x},${y})`,
        type: cell?.type || 'Unknown',
        relations: []
      };
      if (!entityPayload.relations) {
        entityPayload.relations = [];
      }
      const environmentSummary = describeCellEnvironment(channel, x, y);
      const relationshipScores = computeRelationshipScores(channel, x, y);

      try {
        console.log('[PERSPECTIVE API] Starting perspective analysis for:', cell.label || cell.type);
        console.log('[PERSPECTIVE API] Scene context:', channel.lastScene?.sceneTitle);
        
        // Always generate single standard perspective
        // Tetrad mode handled separately through tetrad chips
        let analyses = [];
        let analysis = null; // Define at function scope
        
        if (false) { // Disabled tetrad mode in perspective
          // Generate 4 defractive perspectives through tetrad lenses
          const tetradLenses = [
            {key: 'enhance', label: 'ENHANCE', prompt: 'amplifying and intensifying their current situation', icon: '▲'},
            {key: 'reverse', label: 'REVERSE', prompt: 'reversing or inverting their current trajectory', icon: '⇄'},
            {key: 'retrieve', label: 'RETRIEVE', prompt: 'retrieving past elements and memories', icon: '↺'},
            {key: 'obsolesce', label: 'OBSOLESCE', prompt: 'elements becoming obsolete or fading away', icon: '▼'}
          ];
          
          // Generate all 4 perspectives in parallel
          const promises = tetradLenses.map(lens => 
            fetch('https://api.openai.com/v1/chat/completions', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${appState.apiKey}`
              },
              body: JSON.stringify({
                model: 'gpt-4o-mini',
                temperature: 0.7,
                messages: [
                  {
                    role: 'system',
                    content: `You analyze an entity's perspective through the tetrad lens of "${lens.label}" (${lens.prompt}). Return JSON with perspective, emotionalState, plotImpact, nextMove, all filtered through this ${lens.label} lens. Keep each field under 60 words.`
                  },
                  {
                    role: 'user',
                    content: JSON.stringify({
                      scenario: scenarios[channel.scenario],
                      currentScene: channel.lastScene,
                      entity: entityPayload,
                      cellType: cell?.type || 'Unknown',
                      cellPosition: { x, y },
                      plot: channel.observer.plot,
                      environment: environmentSummary,
                      tetradLens: lens.label
                    })
                  }
                ],
                max_tokens: 400,
                response_format: { type: 'json_object' }
              })
            }).then(r => r.ok ? r.json() : Promise.reject(`HTTP ${r.status}`))
              .then(data => ({
                ...JSON.parse(data.choices?.[0]?.message?.content || '{}'),
                lens: lens
              }))
          );
          
          analyses = await Promise.all(promises);
        } else {
          // Standard single perspective
          console.log('[PERSPECTIVE API] Generating standard perspective');
          console.log('[PERSPECTIVE API] Entity:', entityPayload.name);
          console.log('[PERSPECTIVE API] Environment:', environmentSummary);
          
          const response = await fetch('https://api.openai.com/v1/chat/completions', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${appState.apiKey}`
            },
            body: JSON.stringify({
              model: 'gpt-4o-mini',
              temperature: 0.7,
              messages: [
                {
                  role: 'system',
                  content: 'You analyze an entity perspective in a LEGOS grid. Return JSON with perspective, emotionalState, plotImpact, nextMove.'
                },
                {
                  role: 'user',
                  content: JSON.stringify({
                    scenario: scenarios[channel.scenario],
                    currentScene: channel.lastScene,
                    entity: entityPayload,
                    cellType: cell?.type || 'Unknown',
                    cellPosition: { x, y },
                    plot: channel.observer.plot,
                    environment: environmentSummary
                  })
                }
              ],
              max_tokens: 500,
              response_format: { type: 'json_object' }
            })
          });
          if (!response.ok) {
            console.error('[PERSPECTIVE API] HTTP error:', response.status);
            throw new Error(`HTTP ${response.status}`);
          }
          const data = await response.json();
          console.log('[PERSPECTIVE API] Response received');
          console.log('[PERSPECTIVE API] Usage:', data.usage);
          
          const rawContent = data.choices?.[0]?.message?.content || '{}';
          console.log('[PERSPECTIVE API] Raw content:', rawContent.substring(0, 200));
          
          analysis = JSON.parse(rawContent);
          console.log('[PERSPECTIVE API] Parsed analysis:', analysis);
          analyses = [analysis];
        }

        console.log('[PERSPECTIVE] Total analyses:', analyses.length);
        console.log('[PERSPECTIVE] First analysis:', analyses[0]);

        panel.innerHTML = '';
        const closeBtn = document.createElement('button');
        closeBtn.className = 'close-overlay';
        closeBtn.textContent = '×';
        closeBtn.addEventListener('click', () => document.getElementById('perspectiveOverlay').classList.remove('active'));
        panel.appendChild(closeBtn);

        // Always use standard mode display (never tetrad cards)
        if (false && analyses.length > 1) {
          // Tetrad mode: Show 4 defractive perspectives as cards
          const header = document.createElement('div');
          header.style.cssText = 'font-size: 12px; font-weight: 700; letter-spacing: 0.15em; color: var(--accent); margin-bottom: 16px; text-transform: uppercase; text-align: center;';
          header.textContent = `${cell.label || cell.type} · DEFRACTIVE PERSPECTIVES`;
          panel.appendChild(header);
          
          const subheader = document.createElement('div');
          subheader.style.cssText = 'font-size: 9px; color: var(--text-muted); margin-bottom: 16px; text-align: center;';
          subheader.textContent = 'Four perspectives through tetrad lenses — Click any to add to chat';
          panel.appendChild(subheader);
          
          const cardsContainer = document.createElement('div');
          cardsContainer.style.cssText = 'display: grid; grid-template-columns: repeat(2, 1fr); gap: 12px;';
          
          analyses.forEach(analysis => {
            const card = document.createElement('div');
            card.style.cssText = `
              background: var(--panel-dark);
              border: 2px solid var(--border);
              border-radius: 8px;
              padding: 12px;
              cursor: pointer;
              transition: all 0.2s;
            `;
            
            const cardHeader = document.createElement('div');
            cardHeader.style.cssText = 'display: flex; align-items: center; gap: 6px; margin-bottom: 8px;';
            cardHeader.innerHTML = `
              <span style="font-size: 18px;">${analysis.lens.icon}</span>
              <span style="font-size: 9px; font-weight: 700; letter-spacing: 0.1em; color: var(--accent);">${analysis.lens.label}</span>
            `;
            card.appendChild(cardHeader);
            
            ['perspective', 'emotionalState', 'nextMove'].forEach(key => {
              if (!analysis[key]) return;
              const field = document.createElement('div');
              field.style.cssText = 'margin-bottom: 8px;';
              field.title = analysis[key]; // Hover tooltip
              const label = key === 'nextMove' ? 'NEXT ACTION' : key.replace(/([A-Z])/g, ' $1').trim();
              field.innerHTML = `
                <div style="font-size: 7px; text-transform: uppercase; color: var(--text-muted); margin-bottom: 2px; letter-spacing: 0.1em;">${label}</div>
                <div style="font-size: 9px; line-height: 1.4; color: var(--text);">${analysis[key]}</div>
              `;
              card.appendChild(field);
            });
            
            // Add copy button to card
            const copyBtn = document.createElement('button');
            copyBtn.style.cssText = `
              margin-top: 8px;
              padding: 4px 8px;
              background: var(--accent);
              color: var(--bg);
              border: none;
              border-radius: 4px;
              cursor: pointer;
              font-size: 8px;
              font-weight: 700;
              text-transform: uppercase;
              width: 100%;
            `;
            copyBtn.textContent = '📋 COPY TO CHAT';
            copyBtn.addEventListener('click', (e) => {
              e.stopPropagation();
              const textarea = channel.dom?.input;
              if (textarea) {
                const text = `${analysis.lens.icon} ${analysis.lens.label}:\n${analysis.perspective}\n\nNext Move: ${analysis.nextMove}`;
                textarea.value = text;
                textarea.focus();
                textarea.style.height = 'auto';
                textarea.style.height = textarea.scrollHeight + 'px';
                copyBtn.textContent = '✓ COPIED';
                setTimeout(() => copyBtn.textContent = '📋 COPY TO CHAT', 1500);
              }
            });
            card.appendChild(copyBtn);
            
            card.addEventListener('mouseenter', () => {
              card.style.borderColor = 'var(--accent)';
              card.style.transform = 'scale(1.02)';
            });
            
            card.addEventListener('mouseleave', () => {
              card.style.borderColor = 'var(--border)';
              card.style.transform = '';
            });
            
            cardsContainer.appendChild(card);
          });
          
          panel.appendChild(cardsContainer);
        } else {
          // Standard mode: Show single perspective
          const analysis = analyses[0];
          const heading = document.createElement('div');
          heading.className = 'overlay-section clickable';
          heading.title = 'Click to send to chat';
          const heLabel = document.createElement('div');
          heLabel.className = 'overlay-label';
          heLabel.textContent = `${cell.label || cell.type} · Perspective`;
          const heVal = document.createElement('div');
          heVal.className = 'overlay-value';
          heVal.textContent = analysis.perspective || '—';
          heading.appendChild(heLabel);
          heading.appendChild(heVal);
          
          // Make section selectable - button appears on selection
          heading.style.position = 'relative';
          heading.style.cursor = 'pointer';
          heading.style.transition = 'all 0.2s';
          
          // Add red ball send button (hidden by default)
          const sendBtn = document.createElement('button');
          sendBtn.style.cssText = `
            position: absolute;
            top: 50%;
            right: 12px;
            transform: translateY(-50%) scale(0);
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background: linear-gradient(135deg, #f87171, #dc2626);
            border: 2px solid #991b1b;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            box-shadow: 0 4px 12px rgba(248, 113, 113, 0.6);
            z-index: 10;
            opacity: 0;
          `;
          sendBtn.textContent = '→';
          sendBtn.title = 'Send to input';
          
          // Click section to select and show button
          heading.addEventListener('click', (e) => {
            if (e.target === sendBtn) return; // Don't trigger if clicking button
            
            // Deselect all other sections
            panel.querySelectorAll('.overlay-section').forEach(s => {
              s.style.background = '';
              const btn = s.querySelector('button');
              if (btn) {
                btn.style.transform = 'translateY(-50%) scale(0)';
                btn.style.opacity = '0';
              }
            });
            
            // Select this section
            heading.style.background = 'var(--accent-soft)';
            sendBtn.style.transform = 'translateY(-50%) scale(1)';
            sendBtn.style.opacity = '1';
          });
          
          sendBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            const textarea = channel.dom?.input;
            if (textarea) {
              textarea.value = heVal.textContent;
              textarea.focus();
              textarea.style.height = 'auto';
              textarea.style.height = textarea.scrollHeight + 'px';
              
              // Flash and close
              heading.style.background = 'var(--accent)';
              sendBtn.style.transform = 'translateY(-50%) scale(1.2)';
              
              setTimeout(() => {
                // Close the modal
                document.getElementById('perspectiveOverlay').classList.remove('active');
              }, 300);
            }
          });
          heading.appendChild(sendBtn);
          panel.appendChild(heading);

          ['emotionalState', 'plotImpact', 'nextMove'].forEach(key => {
            if (!analysis[key]) return;
            const section = document.createElement('div');
            section.className = 'overlay-section';
            section.style.position = 'relative';
            section.style.cursor = 'pointer';
            section.style.transition = 'all 0.2s';
            
            const l2 = document.createElement('div');
            l2.className = 'overlay-label';
            const labelText = key === 'nextMove' ? 'NEXT ACTION' : key.replace(/([A-Z])/g, ' $1').toUpperCase();
            l2.textContent = labelText;
            const v2 = document.createElement('div');
            v2.className = 'overlay-value';
            v2.textContent = analysis[key];
            section.appendChild(l2);
            section.appendChild(v2);
            
            // Add red ball send button (hidden by default)
            const fieldSendBtn = document.createElement('button');
            fieldSendBtn.style.cssText = `
              position: absolute;
              top: 50%;
              right: 12px;
              transform: translateY(-50%) scale(0);
              width: 40px;
              height: 40px;
              border-radius: 50%;
              background: linear-gradient(135deg, #f87171, #dc2626);
              border: 2px solid #991b1b;
              cursor: pointer;
              display: flex;
              align-items: center;
              justify-content: center;
              font-size: 18px;
              transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
              box-shadow: 0 4px 12px rgba(248, 113, 113, 0.6);
              z-index: 10;
              opacity: 0;
            `;
            fieldSendBtn.textContent = '→';
            fieldSendBtn.title = 'Send to input';
            
            // Click section to select and show button
            section.addEventListener('click', (e) => {
              if (e.target === fieldSendBtn) return;
              
              // Deselect all other sections
              panel.querySelectorAll('.overlay-section').forEach(s => {
                s.style.background = '';
                const btn = s.querySelector('button');
                if (btn) {
                  btn.style.transform = 'translateY(-50%) scale(0)';
                  btn.style.opacity = '0';
                }
              });
              
              // Select this section
              section.style.background = 'var(--accent-soft)';
              fieldSendBtn.style.transform = 'translateY(-50%) scale(1)';
              fieldSendBtn.style.opacity = '1';
            });
            
            fieldSendBtn.addEventListener('click', (e) => {
              e.stopPropagation();
              const textarea = channel.dom?.input;
              if (textarea) {
                textarea.value = v2.textContent;
                textarea.focus();
                textarea.style.height = 'auto';
                textarea.style.height = textarea.scrollHeight + 'px';
                
                // Flash and close
                section.style.background = 'var(--accent)';
                fieldSendBtn.style.transform = 'translateY(-50%) scale(1.2)';
                
                setTimeout(() => {
                  // Close the modal
                  document.getElementById('perspectiveOverlay').classList.remove('active');
                }, 300);
              }
            });
            
            section.appendChild(fieldSendBtn);
            panel.appendChild(section);
          });
        }
        
        // Log perspective to ring memory for narrative depth
        const firstAnalysis = analyses[0];
        const perspectiveSummary = `${cell.label || cell.type}: ${firstAnalysis.perspective ? firstAnalysis.perspective.substring(0, 100) : 'analyzed'}`;
        logRingEntry({
          type: 'perspective',
          channelId: channel.id,
          channelName: channel.name,
          symbol: `${cell.symbol || cell.type[0]}@(${x},${y})`,
          headline: `Perspective: ${cell.label || cell.type}`,
          summary: perspectiveSummary,
          metadata: {
            cellPosition: { x, y },
            cellType: cell.type,
            analysis: analysis
          }
        });

        if (environmentSummary) {
          const section = document.createElement('div');
          section.className = 'overlay-section clickable';
          section.title = 'Click to send to chat';
          const lEnv = document.createElement('div');
          lEnv.className = 'overlay-label';
          lEnv.textContent = 'Local Awareness';
          const vEnv = document.createElement('div');
          vEnv.className = 'overlay-value';
          vEnv.textContent = environmentSummary;
          section.appendChild(lEnv);
          section.appendChild(vEnv);
          section.addEventListener('click', () => {
            const text = `${lEnv.textContent}: ${vEnv.textContent}`;
            sendPerspectiveToChat(channel, text);
          });
          panel.appendChild(section);
        }

        if (relationshipScores.length) {
          const section = document.createElement('div');
          section.className = 'overlay-section clickable';
          section.title = 'Click to send to chat';
          const lRel = document.createElement('div');
          lRel.className = 'overlay-label';
          lRel.textContent = 'Relational Probabilities';
          section.appendChild(lRel);
          const relationsText = relationshipScores.map(item => {
            const percent = Math.round(item.score * 100);
            return `${item.label} — ${percent}% resonance` + (item.relation ? ' (linked)' : '');
          }).join('; ');
          relationshipScores.forEach(item => {
            const value = document.createElement('div');
            value.className = 'overlay-value';
            const percent = Math.round(item.score * 100);
            value.textContent = `${item.label} — ${percent}% resonance` + (item.relation ? ' (linked)' : '');
            section.appendChild(value);
          });
          section.addEventListener('click', () => {
            const text = `${lRel.textContent}: ${relationsText}`;
            sendPerspectiveToChat(channel, text);

          });
          panel.appendChild(section);
        }

        const sendToChatBtn = document.createElement('button');
        sendToChatBtn.className = 'primary-btn';
        sendToChatBtn.textContent = 'SEND TO CHAT';
        sendToChatBtn.addEventListener('click', () => {
          const summary = `${cell.label || cell.type} perspective: ${analysis.perspective || ''}`;
          if (channel.dom?.input) {
            channel.dom.input.value = summary;
            channel.dom.input.focus();
          }
          document.getElementById('perspectiveOverlay').classList.remove('active');
        });
        
        const forkBtn = document.createElement('button');
        forkBtn.className = 'secondary-btn';
        forkBtn.textContent = 'FORK POV CHANNEL';
        forkBtn.addEventListener('click', () => {
          document.getElementById('perspectiveOverlay').classList.remove('active');
          spawnCellPerspectiveChannel(channel, x, y, cell);
        });
        
        const controlRow = document.createElement('div');
        controlRow.className = 'overlay-action-row';
        controlRow.appendChild(sendToChatBtn);
        controlRow.appendChild(forkBtn);
        panel.appendChild(controlRow);
      } catch (err) {
        panel.innerHTML = '';
        const closeBtn = document.createElement('button');
        closeBtn.className = 'close-overlay';
        closeBtn.textContent = '×';
        closeBtn.addEventListener('click', () => document.getElementById('perspectiveOverlay').classList.remove('active'));
        panel.appendChild(closeBtn);

        const fail = document.createElement('div');
        fail.className = 'overlay-section';
        const l = document.createElement('div');
        l.className = 'overlay-label';
        l.textContent = 'Perspective Failed';
        const v = document.createElement('div');
        v.className = 'overlay-value';
        v.textContent = err.message;
        fail.appendChild(l);
        fail.appendChild(v);
        panel.appendChild(fail);
      }
    }

    function spawnCellPerspectiveChannel(sourceChannel, x, y, cell) {
      const labelRoot = cell?.label || cell?.type || `Cell (${x},${y})`;
      const safeLabel = labelRoot.replace(/\s+/g, ' ').trim() || `Cell (${x},${y})`;
      const shortLabel = `${safeLabel}`.toUpperCase().slice(0, 16);
      const systemInstruction = [
        sourceChannel.systemInstruction,
        `Stay in viewpoint as ${safeLabel}. Anchor narrative to grid cell (${x},${y}) and reference its event history when relevant.`
      ].join('\n');

      const newChannel = createChannel({
        name: `${sourceChannel.name} • ${shortLabel} POV`,
        scenario: sourceChannel.scenario,
        systemInstruction,
        parentChannelId: sourceChannel.id,
        forkPoint: {
          mode: 'cell-perspective',
          coordinates: { x, y },
          cellId: cell?.id || null
        },
        grid: deepClone(sourceChannel.grid),
        cells: deepClone(sourceChannel.cells),
        observer: deepClone(sourceChannel.observer),
        scorecard: deepClone(sourceChannel.scorecard),
        tetrad: {},
        lastScene: deepClone(sourceChannel.lastScene),
        messages: []
      });

      addMessageToChannel(newChannel, 'system', `POV channel launched for ${safeLabel} at (${x},${y}).`);
      if (sourceChannel.lastScene?.sceneSummary) {
        const title = sourceChannel.lastScene.sceneTitle || 'Latest Scene';
        addMessageToChannel(
          newChannel,
          'system',
          `${title} — ${sourceChannel.lastScene.sceneSummary}`,
          { autoCollapse: true }
        );
      }
      if (newChannel.dom?.input) {
        newChannel.dom.input.value = `From ${safeLabel}'s perspective, ...`;
        newChannel.dom.input.focus();
      }
      showHelpBanner(`POV channel launched for ${safeLabel}.`);
      focusChannel(newChannel.id);
    }

    function routeMessage(sourceChannel, targetChannel, message) {
      addMessageToChannel(targetChannel, 'user', message.text, { fromChannel: sourceChannel.name });
      focusChannel(targetChannel.id);
      showHelpBanner(`Routed message to ${targetChannel.name}`);
    }

    function forkChannel(channel, message, mode, options = {}) {
      const messageId = message?.id ?? null;
      const idx = channel.messages.findIndex(m => m.id === messageId);
      const history = idx >= 0 ? channel.messages.slice(0, idx + 1) : channel.messages.slice();
      const label = forkLabels[mode] || 'Fork';
      const baseName = sanitizeHandle(`${channel.name}-${label}`, label);
      let newChannelConfig;

      if (mode === 'blank') {
        newChannelConfig = {
          name: baseName,
          scenario: channel.scenario,
          parentChannelId: channel.id,
          forkPoint: { messageId, mode },
          ringBinding: channel.ringBinding || null
        };
      } else if (mode === 'snapshot') {
        const snapshotId = options.snapshotId || window.prompt('Snapshot ID or name?');
        const snapshot = channel.snapshots.find(s => s.id === snapshotId || s.name === snapshotId);
        if (!snapshot) {
          showHelpBanner('Snapshot not found.');
          return;
        }
        newChannelConfig = {
          name: baseName,
          scenario: channel.scenario,
          parentChannelId: channel.id,
          forkPoint: { messageId, mode, snapshotId: snapshot.id },
          grid: deepClone(snapshot.grid),
          cells: deepClone(snapshot.cells),
          observer: deepClone(snapshot.observer),
          scorecard: deepClone(snapshot.scorecard),
          tetrad: deepClone(snapshot.tetrad),
          lastScene: deepClone(snapshot.lastScene),
          messages: deepClone(history),
          ringBinding: channel.ringBinding || null
        };
      } else if (mode === 'perspective') {
        const entityName = window.prompt('Which entity perspective?');
        const systemInstruction = `${channel.systemInstruction}
Focus entirely on the perspective of ${entityName || 'the selected entity'}. Provide POV insights per turn.`;
        newChannelConfig = {
          name: sanitizeHandle(`${channel.name}-POV`, baseName),
          scenario: channel.scenario,
          parentChannelId: channel.id,
          systemInstruction,
          forkPoint: { messageId, mode, entity: entityName },
          grid: deepClone(channel.grid),
          cells: deepClone(channel.cells),
          observer: deepClone(channel.observer),
          scorecard: deepClone(channel.scorecard),
          tetrad: {},
          lastScene: deepClone(channel.lastScene),
          messages: deepClone(history),
          ringBinding: channel.ringBinding || null
        };
      } else if (['continue', 'enhance', 'reverse', 'retrieve', 'obsolesce'].includes(mode)) {
        newChannelConfig = {
          name: baseName,
          scenario: channel.scenario,
          systemInstruction: channel.systemInstruction,
          parentChannelId: channel.id,
          forkPoint: { messageId, mode },
          grid: deepClone(channel.grid),
          cells: deepClone(channel.cells),
          observer: deepClone(channel.observer),
          scorecard: deepClone(channel.scorecard),
          tetrad: {},
          lastScene: deepClone(channel.lastScene),
          messages: deepClone(history),
          ringBinding: channel.ringBinding || null
        };
      } else {
        newChannelConfig = {
          name: baseName,
          scenario: channel.scenario,
          parentChannelId: channel.id,
          forkPoint: { messageId, mode },
          ringBinding: channel.ringBinding || null
        };
      }

      if (options.ringEntryId) {
        newChannelConfig.ringBinding = options.ringEntryId;
      }

      const forked = createChannel(newChannelConfig);
      if (mode !== 'blank') {
        if (['enhance', 'reverse', 'retrieve', 'obsolesce'].includes(mode) && channel.tetrad?.[mode]?.text) {
          addMessageToChannel(forked, 'system', `Forked via ${mode.toUpperCase()} tetrad option.`);
          addMessageToChannel(forked, 'user', channel.tetrad[mode].text, { forkLabel: mode.toUpperCase() });
        } else {
          addMessageToChannel(forked, 'system', `Forked from ${channel.name} @ message ${messageId ?? '—'} (${label}).`);
        }
      } else {
        addMessageToChannel(forked, 'system', 'Blank fork created. Describe a new trajectory.');
      }
      const forkEntry = logRingEntry({
        type: 'fork',
        channelId: forked.id,
        channelName: forked.name,
        symbol: forked.name,
        headline: `Forked via ${label}`,
        summary: message?.text || ''
      });
      forked.ringBinding = forkEntry.id;
      renderChannel(forked);
      
      // Animate colored ball moving to new forked channel
      setTimeout(() => animateChannelTransition(channel, forked), 100);
      
      renderTimeline();
      focusChannel(forked.id);
      persistState();
    }

    function setChannelScenario(channel, scenarioId) {
      if (!scenarios[scenarioId]) return;
      const previousDefault = resolveChannelName('', channel.scenario, channel.symbolicId);
      channel.scenario = scenarioId;
      if (channel.name === previousDefault) {
        channel.name = resolveChannelName('', scenarioId, channel.symbolicId);
      }
      channel.systemInstruction = scenarios[scenarioId].systemInstruction;
      channel.resetState();
      if (snapshotOverlayChannel === channel) {
        snapshotOverlayChannel = null;
        const overlay = document.getElementById('snapshotOverlay');
        if (overlay) overlay.classList.remove('active');
      }
      addMessageToChannel(channel, 'system', `${scenarios[scenarioId].name} scenario primed. ${scenarios[scenarioId].intro}`);
      if (scenarios[scenarioId].initialPrompt) {
        channel.dom.input.value = scenarios[scenarioId].initialPrompt;
      }
      renderChannel(channel);
      persistState();
    }

    function exportState() {
      const overlay = document.getElementById('exportOverlay');
      overlay.classList.remove('active');
      const payload = {
        exportedAt: new Date().toISOString(),
        theme: appState.theme,
        channels: appState.channels.map(ch => ch.serialize()),
        ring: {
          entries: ringMemory.entries,
          mainline: ringMemory.mainline,
          contextMode: ringMemory.contextMode,
          contextAnchor: ringMemory.contextAnchor,
          counter: ringEntryCounter
        }
      };
      const blob = new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `legos-multi-channel-${Date.now()}.json`;
      a.click();
      URL.revokeObjectURL(url);
      showHelpBanner('Exported multi-channel state.');
    }

    function handleImportFile(event) {
      const file = event.target.files?.[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const data = JSON.parse(e.target.result);
          restoreFromImport(data);
          showHelpBanner('Imported multi-channel session.');
        } catch (err) {
          console.error(err);
          showHelpBanner('Import failed. Invalid file.');
        }
      };
      reader.readAsText(file);
      event.target.value = '';
    }

    function restoreFromImport(data) {
      const snapshotOverlay = document.getElementById('snapshotOverlay');
      if (snapshotOverlay) snapshotOverlay.classList.remove('active');
      snapshotOverlayChannel = null;
      document.getElementById('channelScroller').innerHTML = '';
      appState.channels = [];
      channelMap.clear();
      (data.channels || []).forEach(cfg => {
        const channel = new Channel(cfg);
        channelMap.set(channel.id, channel);
        appState.channels.push(channel);
        mountChannel(channel);
        const numeric = parseInt((channel.symbolicId || '').replace(/[^0-9]/g, ''), 10);
        if (!Number.isNaN(numeric)) {
          channelSequence = Math.max(channelSequence, numeric + 1);
        }
      });
      appState.currentChannelId = appState.channels[0]?.id || null;
      if (data.theme) {
        applyTheme(data.theme);
      } else {
        applyTheme(appState.theme);
      }
      ringMemory.entries = [];
      ringMemory.mainline = null;
      ringMemory.contextMode = 'all';
      ringMemory.contextAnchor = null;
      ringEntryCounter = 1;
      if (data.ring) {
        const restoredEntries = (data.ring.entries || []).map(entry => ({
          ...entry,
          channelName: sanitizeHandle(entry.channelName || 'GLOBAL', 'GLOBAL'),
          symbol: sanitizeHandle(entry.symbol || entry.channelName || 'ENTRY', 'ENTRY'),
          type: sanitizeHandle(entry.type || 'NOTE', 'NOTE')
        }));
        ringMemory.entries = restoredEntries.slice(-ringMemory.capacity);
        ringMemory.mainline = data.ring.mainline || null;
        ringMemory.contextMode = data.ring.contextMode || 'all';
        ringMemory.contextAnchor = data.ring.contextAnchor
          || ringMemory.entries[ringMemory.entries.length - 1]?.id
          || null;
        const storedCounter = parseInt(data.ring.counter, 10);
        if (Number.isFinite(storedCounter) && storedCounter > ringEntryCounter) {
          ringEntryCounter = storedCounter;
        } else if (ringMemory.entries.length && !storedCounter) {
          const numeric = ringMemory.entries
            .map(entry => parseInt(String(entry.id).replace(/[^0-9]/g, ''), 10))
            .filter(Number.isFinite);
          if (numeric.length) {
            ringEntryCounter = Math.max(...numeric) + 1;
          }
        }
      }
      renderTimeline();
      renderRingBar();
      renderRingContext();
      syncRingContextButtons();
      persistState();
    }

    // Sound system
    let soundInitialized = false;
    let synth = null;

    async function initSound() {
      if (soundInitialized || typeof Tone === 'undefined') return;
      try {
        await Tone.start();
        synth = new Tone.Synth({
          oscillator: { type: 'sine' },
          envelope: { attack: 0.02, decay: 0.1, sustain: 0, release: 0.2 }
        }).toDestination();
        synth.volume.value = -24;
        soundInitialized = true;
      } catch (e) {
        console.warn('Sound init failed:', e);
      }
    }

    function playComposingTick() {
      if (!soundInitialized || !synth) return;
      try {
        synth.triggerAttackRelease('C5', '0.05');
      } catch (e) {
        console.warn('Sound play failed:', e);
      }
    }

    function playRevealChime() {
      if (!soundInitialized || !synth) return;
      try {
        synth.triggerAttackRelease('E5', '0.1');
        setTimeout(() => synth.triggerAttackRelease('G5', '0.1'), 100);
      } catch (e) {
        console.warn('Sound play failed:', e);
      }
    }

    document.addEventListener('click', async (event) => {
      if (!soundInitialized) await initSound();
      if (!event.target.closest('.message')) {
        closeAllMenus();
      }
    });

    window.addEventListener('beforeunload', persistState);

    document.addEventListener('DOMContentLoaded', initApp);
  </script>
  
  <!-- Tutorial System - Draws LEGOS on grid -->
  <script src="tutorial-system.js"></script>
</body>
</html>
